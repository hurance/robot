{"map":"{\"version\":3,\"sources\":[\"Dash.js\"],\"names\":[\"modules\",\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"__webpack_exports__\",\"eval\"],\"mappings\":\"CAAS,SAAUA,GAET,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAJ,EAAQG,GAAUK,KAAKH,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBO,EAAIT,EAGxBE,EAAoBQ,EAAIT,EAGxBC,EAAoBS,EAAI,SAASP,EAASQ,EAAMC,GAC3CX,EAAoBY,EAAEV,EAASQ,IAClCG,OAAOC,eAAeZ,EAASQ,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEX,EAAoBiB,EAAI,SAASf,GACX,oBAAXgB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeZ,EAASgB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeZ,EAAS,aAAc,CAAEkB,OAAO,KAQvDpB,EAAoBqB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQpB,EAAoBoB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAzB,EAAoBiB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOpB,EAAoBS,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRxB,EAAoB4B,EAAI,SAASzB,GAChC,IAAIQ,EAASR,GAAUA,EAAOoB,WAC7B,WAAwB,OAAOpB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG9B,EAAoBiC,EAAI,GAIjBjC,EAAoBA,EAAoBkC,EAAI,IAnFpD,CAsFC,CAEJ,SAAU/B,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,29XAIC,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,iwIAIC,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,0/fAIC,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,+nzBAIC,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,46rDAIC,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,oyQAIC,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK,uzgMAGE,CAED,SAAUjC,OAAQD,SAExBkC,KAAK,2gBAGE,CACC,CACA,CACA,CACA,CAEF,SAAUjC,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK\"}","code":"!function(t){var n={};function c(e){if(n[e])return n[e].exports;var l=n[e]={i:e,l:!1,exports:{}};return t[e].call(l.exports,l,l.exports,c),l.l=!0,l.exports}c.m=t,c.c=n,c.d=function(t,n,e){c.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},c.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},c.t=function(t,n){if(1&n&&(t=c(t)),8&n)return t;if(4&n&&\"object\"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(c.r(e),Object.defineProperty(e,\"default\",{enumerable:!0,value:t}),2&n&&\"string\"!=typeof t)for(var l in t)c.d(e,l,function(n){return t[n]}.bind(null,l));return e},c.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return c.d(n,\"a\",n),n},c.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},c.p=\"\",c(c.s=14)}([function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Car; });\\nclass Car {\\n  constructor(x = 0, y = 0, rotation = 0) {\\n    this.setPose(x, y, rotation);\\n  }\\n\\n  static getFrontAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\\n  }\\n\\n  static getFakeAxlePosition(pos, rot) {\\n    return Car.frontToRearAxlePosition(pos, rot);\\n  }\\n\\n  static centerToRearAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\\n  }\\n\\n  static frontToRearAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\\n  }\\n\\n  get pose() {\\n    return { pos: this.rearAxlePosition.clone(), rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: this.dCurv, ddCurv: this.ddCurv };\\n  }\\n\\n  get curvature() {\\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\\n  }\\n\\n  get rearAxlePosition() {\\n    const { x, y } = this.position;\\n    const rot = this.rotation;\\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\\n  }\\n\\n  get frontAxlePosition() {\\n    const { x, y } = this.position;\\n    const rot = this.rotation;\\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\\n  }\\n\\n  setPose(x, y, rotation) {\\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\\n\\n    this.position = new THREE.Vector2(x, y);\\n    this.rotation = Math.wrapAngle(rotation);\\n    this.velocity = 0;\\n    this.acceleration = 0;\\n    this.wheelAngle = 0;\\n    this.wheelAngularVelocity = 0;\\n    this.dCurv = 0; // derivative with respect to arc length\\n    this.ddCurv = 0; // derivative with respect to arc length\\n  }\\n\\n  step(dt) {\\n    const curvPrev = this.curvature;\\n    const dCurvPrev = this.dCurv;\\n\\n    const drag = (0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * Math.abs(this.velocity) + Car.ROLL_RESIST) * -this.velocity;\\n    this.velocity += (this.acceleration + drag / Car.MASS) * dt;\\n\\n    const velocitySq = this.velocity * this.velocity;\\n    const maxWheelAngle = Math.clamp(Math.atan(Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / velocitySq), 0.07, Car.MAX_WHEEL_ANGLE);\\n    this.wheelAngle = Math.clamp(Math.wrapAngle(this.wheelAngle + this.wheelAngularVelocity * dt), -maxWheelAngle, maxWheelAngle);\\n\\n    const angularVelocity = this.velocity * this.curvature;\\n    this.rotation = Math.wrapAngle(this.rotation + angularVelocity * dt);\\n\\n    const dist = this.velocity * dt;\\n    this.position = THREE.Vector2.fromAngle(this.rotation).multiplyScalar(dist).add(this.position);\\n\\n    this.dCurv = dist > 0.1 ? (this.curvature - curvPrev) / dist : 0;\\n    this.ddCurv = dist > 0.1 ? (this.dCurv - dCurvPrev) / dist : 0;\\n  }\\n\\n  update(controls, dt) {\\n    const gas = Math.clamp(controls.gas, -1, +1);\\n    const brake = Math.clamp(controls.brake, 0, 1);\\n    const steer = Math.clamp(controls.steer, -1, +1);\\n\\n    if (brake > 0) {\\n      this.acceleration = -Math.sign(this.velocity) * Car.MAX_BRAKE_DECEL * brake;\\n      const newVelocity = this.velocity + this.acceleration * dt;\\n\\n      // If applying the braking deceleration at the next step would cause the velocity\\n      // to change directions, then just set the car as stopped.\\n      if (Math.sign(newVelocity) != Math.sign(this.velocity)) {\\n        this.velocity = 0;\\n        this.acceleration = 0;\\n      }\\n    } else {\\n      this.acceleration = Car.MAX_GAS_ACCEL * gas;\\n    }\\n\\n    if (steer != 0) {\\n      this.wheelAngularVelocity = steer * Car.MAX_STEER_SPEED;\\n    } else {\\n      this.wheelAngularVelocity = Math.clamp(-this.wheelAngle / Car.MAX_WHEEL_ANGLE * this.velocity * this.velocity * dt, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED);\\n    }\\n  }\\n}\\n\\nCar.HALF_CAR_LENGTH = 2.5; // meters\\nCar.HALF_CAR_WIDTH = 1; // meters\\nCar.HALF_WHEEL_LENGTH = 0.38; // meters\\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\\nCar.MASS = 1600; // kg\\nCar.DRAG_COEFF = 0.7;\\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\\nCar.FRONTAL_AREA = 1.85; // m^2\\nCar.ROLL_RESIST = 0;\\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\\nCar.WHEEL_LATERAL_POS = 0.843; // meters\\nCar.FRONT_AXLE_POS = 1.6; // meters\\nCar.REAR_AXLE_POS = -1.43; // meters\\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9waHlzaWNzL0Nhci5qcz8yYzBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLHlDQUF5QztBQUN6QyxnQkFBZ0I7QUFDaEI7QUFDQSwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEMsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQix3REFBd0Q7QUFDeEQsNkJBQTZCIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBDYXIge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHJvdGF0aW9uID0gMCkge1xuICAgIHRoaXMuc2V0UG9zZSh4LCB5LCByb3RhdGlvbik7XG4gIH1cblxuICBzdGF0aWMgZ2V0RnJvbnRBeGxlUG9zaXRpb24ocG9zLCByb3QpIHtcbiAgICByZXR1cm4gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUocm90KS5tdWx0aXBseVNjYWxhcihDYXIuV0hFRUxfQkFTRSkuYWRkKHBvcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmFrZUF4bGVQb3NpdGlvbihwb3MsIHJvdCkge1xuICAgIHJldHVybiBDYXIuZnJvbnRUb1JlYXJBeGxlUG9zaXRpb24ocG9zLCByb3QpO1xuICB9XG5cbiAgc3RhdGljIGNlbnRlclRvUmVhckF4bGVQb3NpdGlvbihwb3MsIHJvdCkge1xuICAgIHJldHVybiBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QpLm11bHRpcGx5U2NhbGFyKENhci5SRUFSX0FYTEVfUE9TKS5hZGQocG9zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9udFRvUmVhckF4bGVQb3NpdGlvbihwb3MsIHJvdCkge1xuICAgIHJldHVybiBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QpLm11bHRpcGx5U2NhbGFyKC1DYXIuV0hFRUxfQkFTRSkuYWRkKHBvcyk7XG4gIH1cblxuICBnZXQgcG9zZSgpIHtcbiAgICByZXR1cm4geyBwb3M6IHRoaXMucmVhckF4bGVQb3NpdGlvbi5jbG9uZSgpLCByb3Q6IHRoaXMucm90YXRpb24sIHZlbG9jaXR5OiB0aGlzLnZlbG9jaXR5LCBjdXJ2OiB0aGlzLmN1cnZhdHVyZSwgZEN1cnY6IHRoaXMuZEN1cnYsIGRkQ3VydjogdGhpcy5kZEN1cnYgfTtcbiAgfVxuXG4gIGdldCBjdXJ2YXR1cmUoKSB7XG4gICAgcmV0dXJuIE1hdGgudGFuKHRoaXMud2hlZWxBbmdsZSkgLyBDYXIuV0hFRUxfQkFTRTtcbiAgfVxuXG4gIGdldCByZWFyQXhsZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCByb3QgPSB0aGlzLnJvdGF0aW9uO1xuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMih4ICsgTWF0aC5jb3Mocm90KSAqIENhci5SRUFSX0FYTEVfUE9TLCB5ICsgTWF0aC5zaW4ocm90KSAqIENhci5SRUFSX0FYTEVfUE9TKTtcbiAgfVxuXG4gIGdldCBmcm9udEF4bGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucG9zaXRpb247XG4gICAgY29uc3Qgcm90ID0gdGhpcy5yb3RhdGlvbjtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoeCArIE1hdGguY29zKHJvdCkgKiBDYXIuRlJPTlRfQVhMRV9QT1MsIHkgKyBNYXRoLnNpbihyb3QpICogQ2FyLkZST05UX0FYTEVfUE9TKTtcbiAgfVxuXG4gIHNldFBvc2UoeCwgeSwgcm90YXRpb24pIHtcbiAgICAvLyBUcmFuc2xhdGUgc28gdGhhdCB4IGFuZCB5IGJlY29tZSB0aGUgY2VudGVyIG9mIHRoZSB2ZWhpY2xlIChpbnN0ZWFkIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJlYXIgYXhsZSlcbiAgICB4IC09IENhci5SRUFSX0FYTEVfUE9TICogTWF0aC5jb3Mocm90YXRpb24pO1xuICAgIHkgLT0gQ2FyLlJFQVJfQVhMRV9QT1MgKiBNYXRoLnNpbihyb3RhdGlvbik7XG5cbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjIoeCwgeSk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IE1hdGgud3JhcEFuZ2xlKHJvdGF0aW9uKTtcbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IDA7XG4gICAgdGhpcy53aGVlbEFuZ2xlID0gMDtcbiAgICB0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLmRDdXJ2ID0gMDsgLy8gZGVyaXZhdGl2ZSB3aXRoIHJlc3BlY3QgdG8gYXJjIGxlbmd0aFxuICAgIHRoaXMuZGRDdXJ2ID0gMDsgLy8gZGVyaXZhdGl2ZSB3aXRoIHJlc3BlY3QgdG8gYXJjIGxlbmd0aFxuICB9XG5cbiAgc3RlcChkdCkge1xuICAgIGNvbnN0IGN1cnZQcmV2ID0gdGhpcy5jdXJ2YXR1cmU7XG4gICAgY29uc3QgZEN1cnZQcmV2ID0gdGhpcy5kQ3VydjtcblxuICAgIGNvbnN0IGRyYWcgPSAoMC41ICogQ2FyLkRSQUdfQ09FRkYgKiBDYXIuRlJPTlRBTF9BUkVBICogQ2FyLkRFTlNJVFlfT0ZfQUlSICogTWF0aC5hYnModGhpcy52ZWxvY2l0eSkgKyBDYXIuUk9MTF9SRVNJU1QpICogLXRoaXMudmVsb2NpdHk7XG4gICAgdGhpcy52ZWxvY2l0eSArPSAodGhpcy5hY2NlbGVyYXRpb24gKyBkcmFnIC8gQ2FyLk1BU1MpICogZHQ7XG5cbiAgICBjb25zdCB2ZWxvY2l0eVNxID0gdGhpcy52ZWxvY2l0eSAqIHRoaXMudmVsb2NpdHk7XG4gICAgY29uc3QgbWF4V2hlZWxBbmdsZSA9IE1hdGguY2xhbXAoTWF0aC5hdGFuKENhci5NQVhfTEFURVJBTF9BQ0NFTCAqIENhci5XSEVFTF9CQVNFIC8gdmVsb2NpdHlTcSksIDAuMDcsIENhci5NQVhfV0hFRUxfQU5HTEUpO1xuICAgIHRoaXMud2hlZWxBbmdsZSA9IE1hdGguY2xhbXAoTWF0aC53cmFwQW5nbGUodGhpcy53aGVlbEFuZ2xlICsgdGhpcy53aGVlbEFuZ3VsYXJWZWxvY2l0eSAqIGR0KSwgLW1heFdoZWVsQW5nbGUsIG1heFdoZWVsQW5nbGUpO1xuXG4gICAgY29uc3QgYW5ndWxhclZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eSAqIHRoaXMuY3VydmF0dXJlO1xuICAgIHRoaXMucm90YXRpb24gPSBNYXRoLndyYXBBbmdsZSh0aGlzLnJvdGF0aW9uICsgYW5ndWxhclZlbG9jaXR5ICogZHQpO1xuXG4gICAgY29uc3QgZGlzdCA9IHRoaXMudmVsb2NpdHkgKiBkdDtcbiAgICB0aGlzLnBvc2l0aW9uID0gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUodGhpcy5yb3RhdGlvbikubXVsdGlwbHlTY2FsYXIoZGlzdCkuYWRkKHRoaXMucG9zaXRpb24pO1xuXG4gICAgdGhpcy5kQ3VydiA9IGRpc3QgPiAwLjEgPyAodGhpcy5jdXJ2YXR1cmUgLSBjdXJ2UHJldikgLyBkaXN0IDogMDtcbiAgICB0aGlzLmRkQ3VydiA9IGRpc3QgPiAwLjEgPyAodGhpcy5kQ3VydiAtIGRDdXJ2UHJldikgLyBkaXN0IDogMDtcbiAgfVxuXG4gIHVwZGF0ZShjb250cm9scywgZHQpIHtcbiAgICBjb25zdCBnYXMgPSBNYXRoLmNsYW1wKGNvbnRyb2xzLmdhcywgLTEsICsxKTtcbiAgICBjb25zdCBicmFrZSA9IE1hdGguY2xhbXAoY29udHJvbHMuYnJha2UsIDAsIDEpO1xuICAgIGNvbnN0IHN0ZWVyID0gTWF0aC5jbGFtcChjb250cm9scy5zdGVlciwgLTEsICsxKTtcblxuICAgIGlmIChicmFrZSA+IDApIHtcbiAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gLU1hdGguc2lnbih0aGlzLnZlbG9jaXR5KSAqIENhci5NQVhfQlJBS0VfREVDRUwgKiBicmFrZTtcbiAgICAgIGNvbnN0IG5ld1ZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eSArIHRoaXMuYWNjZWxlcmF0aW9uICogZHQ7XG5cbiAgICAgIC8vIElmIGFwcGx5aW5nIHRoZSBicmFraW5nIGRlY2VsZXJhdGlvbiBhdCB0aGUgbmV4dCBzdGVwIHdvdWxkIGNhdXNlIHRoZSB2ZWxvY2l0eVxuICAgICAgLy8gdG8gY2hhbmdlIGRpcmVjdGlvbnMsIHRoZW4ganVzdCBzZXQgdGhlIGNhciBhcyBzdG9wcGVkLlxuICAgICAgaWYgKE1hdGguc2lnbihuZXdWZWxvY2l0eSkgIT0gTWF0aC5zaWduKHRoaXMudmVsb2NpdHkpKSB7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gQ2FyLk1BWF9HQVNfQUNDRUwgKiBnYXM7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVyICE9IDApIHtcbiAgICAgIHRoaXMud2hlZWxBbmd1bGFyVmVsb2NpdHkgPSBzdGVlciAqIENhci5NQVhfU1RFRVJfU1BFRUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2hlZWxBbmd1bGFyVmVsb2NpdHkgPSBNYXRoLmNsYW1wKC10aGlzLndoZWVsQW5nbGUgLyBDYXIuTUFYX1dIRUVMX0FOR0xFICogdGhpcy52ZWxvY2l0eSAqIHRoaXMudmVsb2NpdHkgKiBkdCwgLUNhci5NQVhfU1RFRVJfU1BFRUQsIENhci5NQVhfU1RFRVJfU1BFRUQpO1xuICAgIH1cbiAgfVxufVxuXG5DYXIuSEFMRl9DQVJfTEVOR1RIID0gMi41OyAvLyBtZXRlcnNcbkNhci5IQUxGX0NBUl9XSURUSCA9IDE7IC8vIG1ldGVyc1xuQ2FyLkhBTEZfV0hFRUxfTEVOR1RIID0gMC4zODsgLy8gbWV0ZXJzXG5DYXIuSEFMRl9XSEVFTF9XSURUSCA9IDAuMTI7IC8vIG1ldGVyc1xuQ2FyLk1BWF9XSEVFTF9BTkdMRSA9IDMyIC8gMTgwICogTWF0aC5QSTsgLy8gcmFkaWFuc1xuQ2FyLk1BU1MgPSAxNjAwOyAvLyBrZ1xuQ2FyLkRSQUdfQ09FRkYgPSAwLjc7XG5DYXIuREVOU0lUWV9PRl9BSVIgPSAxLjg1ODA2MDg7IC8vIChrZy9tXjMpXG5DYXIuRlJPTlRBTF9BUkVBID0gMS44NTsgLy8gbV4yXG5DYXIuUk9MTF9SRVNJU1QgPSAwO1xuQ2FyLk1BWF9TVEVFUl9TUEVFRCA9IDAuODsvLzEuMjsgLy8gUmFkaWFucyBwZXIgc2Vjb25kXG5DYXIuTUFYX0dBU19BQ0NFTCA9IDMuNTsgLy8gbSAvIHNeMlxuQ2FyLk1BWF9CUkFLRV9ERUNFTCA9IDYuNTsgLy8gbSAvIHNeMlxuQ2FyLldIRUVMX0xBVEVSQUxfUE9TID0gMC44NDM7IC8vIG1ldGVyc1xuQ2FyLkZST05UX0FYTEVfUE9TID0gMS42OyAvLyBtZXRlcnNcbkNhci5SRUFSX0FYTEVfUE9TID0gLTEuNDM7IC8vIG1ldGVyc1xuQ2FyLldIRUVMX0JBU0UgPSBDYXIuRlJPTlRfQVhMRV9QT1MgLSBDYXIuUkVBUl9BWExFX1BPUzsgLy8gbWV0ZXJzXG5DYXIuTUFYX0xBVEVSQUxfQUNDRUwgPSA5LjgxOyAvLyBtIC8gc14yXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///0\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return StaticObstacle; });\\nclass StaticObstacle {\\n  static hydrate(obj) {\\n    Object.setPrototypeOf(obj, StaticObstacle.prototype);\\n    Object.setPrototypeOf(obj.pos, THREE.Vector2.prototype);\\n  }\\n\\n  static fromJSON(json) {\\n    return new StaticObstacle(new THREE.Vector2(json.p[0], json.p[1]), json.r, json.w, json.h);\\n  }\\n\\n  constructor(pos, rot, width, height) {\\n    this.pos = pos;\\n    this.rot = rot;\\n    this.width = width;\\n    this.height = height;\\n\\n    this.updateVertices();\\n  }\\n\\n  toJSON() {\\n    const trunc = n => +n.toFixed(5);\\n\\n    return {\\n      p: [trunc(this.pos.x), trunc(this.pos.y)],\\n      r: trunc(this.rot),\\n      w: trunc(this.width),\\n      h: trunc(this.height)\\n    };\\n  }\\n\\n  updateVertices() {\\n    this.vertices = [];\\n\\n    const cosRot = Math.cos(this.rot);\\n    const sinRot = Math.sin(this.rot);\\n    const halfWidth = this.width / 2;\\n    const halfHeight = this.height / 2;\\n\\n    const hWcR = halfWidth * cosRot;\\n    const hWsR = halfWidth * sinRot;\\n    const hHcR = halfHeight * cosRot;\\n    const hHsR = halfHeight * sinRot;\\n\\n    const v1 = [-hWcR - hHsR + this.pos.x, -hWsR + hHcR + this.pos.y];\\n    const v2 = [-hWcR + hHsR + this.pos.x, -hWsR - hHcR + this.pos.y];\\n    const v3 = [hWcR + hHsR + this.pos.x, hWsR - hHcR + this.pos.y];\\n    const v4 = [hWcR - hHsR + this.pos.x, hWsR + hHcR + this.pos.y];\\n\\n    this.vertices = [\\n      v1[0], v1[1],\\n      v2[0], v2[1],\\n      v3[0], v3[1],\\n      v3[0], v3[1],\\n      v4[0], v4[1],\\n      v1[0], v1[1]\\n    ];\\n  }\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9TdGF0aWNPYnN0YWNsZS5qcz84OTA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGljT2JzdGFjbGUge1xuICBzdGF0aWMgaHlkcmF0ZShvYmopIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBTdGF0aWNPYnN0YWNsZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmoucG9zLCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIHJldHVybiBuZXcgU3RhdGljT2JzdGFjbGUobmV3IFRIUkVFLlZlY3RvcjIoanNvbi5wWzBdLCBqc29uLnBbMV0pLCBqc29uLnIsIGpzb24udywganNvbi5oKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBvcywgcm90LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5yb3QgPSByb3Q7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHRydW5jID0gbiA9PiArbi50b0ZpeGVkKDUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IFt0cnVuYyh0aGlzLnBvcy54KSwgdHJ1bmModGhpcy5wb3MueSldLFxuICAgICAgcjogdHJ1bmModGhpcy5yb3QpLFxuICAgICAgdzogdHJ1bmModGhpcy53aWR0aCksXG4gICAgICBoOiB0cnVuYyh0aGlzLmhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlVmVydGljZXMoKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuXG4gICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3ModGhpcy5yb3QpO1xuICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHRoaXMucm90KTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSB0aGlzLndpZHRoIC8gMjtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgY29uc3QgaFdjUiA9IGhhbGZXaWR0aCAqIGNvc1JvdDtcbiAgICBjb25zdCBoV3NSID0gaGFsZldpZHRoICogc2luUm90O1xuICAgIGNvbnN0IGhIY1IgPSBoYWxmSGVpZ2h0ICogY29zUm90O1xuICAgIGNvbnN0IGhIc1IgPSBoYWxmSGVpZ2h0ICogc2luUm90O1xuXG4gICAgY29uc3QgdjEgPSBbLWhXY1IgLSBoSHNSICsgdGhpcy5wb3MueCwgLWhXc1IgKyBoSGNSICsgdGhpcy5wb3MueV07XG4gICAgY29uc3QgdjIgPSBbLWhXY1IgKyBoSHNSICsgdGhpcy5wb3MueCwgLWhXc1IgLSBoSGNSICsgdGhpcy5wb3MueV07XG4gICAgY29uc3QgdjMgPSBbaFdjUiArIGhIc1IgKyB0aGlzLnBvcy54LCBoV3NSIC0gaEhjUiArIHRoaXMucG9zLnldO1xuICAgIGNvbnN0IHY0ID0gW2hXY1IgLSBoSHNSICsgdGhpcy5wb3MueCwgaFdzUiArIGhIY1IgKyB0aGlzLnBvcy55XTtcblxuICAgIHRoaXMudmVydGljZXMgPSBbXG4gICAgICB2MVswXSwgdjFbMV0sXG4gICAgICB2MlswXSwgdjJbMV0sXG4gICAgICB2M1swXSwgdjNbMV0sXG4gICAgICB2M1swXSwgdjNbMV0sXG4gICAgICB2NFswXSwgdjRbMV0sXG4gICAgICB2MVswXSwgdjFbMV1cbiAgICBdO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CubicPath; });\\nconst SIMPSONS_INTERVALS = 8;\\nconst NEWTON_ITERATIONS = 16;\\nconst RELAXATION_ITERATIONS = 32;\\nconst CONVERGENCE_ERROR = 0.01;\\n\\nconst jacobian = new THREE.Matrix3();\\nconst invJacobian = new THREE.Matrix3();\\n\\n// Alternate reference implementation: https://github.com/ApolloAuto/apollo/blob/master/modules/planning/math/spiral_curve/cubic_spiral_curve.cc\\nclass CubicPath {\\n  constructor(start, end, params = null) {\\n    this.start = Object.assign({}, start);\\n    this.end = Object.assign({}, end);\\n\\n    if (start.pos) {\\n      this.start.x = start.pos.x;\\n      this.start.y = start.pos.y\\n    }\\n\\n    if (end.pos) {\\n      this.end.x = end.pos.x;\\n      this.end.y = end.pos.y\\n    }\\n\\n    const diffX = this.end.x - this.start.x;\\n    const diffY = this.end.y - this.start.y;\\n    const sinRot = Math.sin(this.start.rot);\\n    const cosRot = Math.cos(this.start.rot);\\n\\n    this.goal = {\\n      x: cosRot * diffX + sinRot * diffY,\\n      y: -sinRot * diffX + cosRot * diffY,\\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\\n      curv: this.end.curv\\n    };\\n\\n    if (params)\\n      this.params = Object.assign({}, params, { p0: this.start.curv, p3: this.end.curv });\\n    else\\n      this.guessInitialParams();\\n\\n    this.converged = false;\\n  }\\n\\n  guessInitialParams() {\\n    const originalGoal = this.goal;\\n    const dStartCurv = this.start.curv / RELAXATION_ITERATIONS;\\n    const dGoalY = originalGoal.y / RELAXATION_ITERATIONS;\\n    const dGoalRot = originalGoal.rot / RELAXATION_ITERATIONS;\\n    const dGoalCurv = originalGoal.curv / RELAXATION_ITERATIONS;\\n\\n    this.goal = {\\n      x: originalGoal.x,\\n      y: 0,\\n      rot: 0,\\n      curv: 0\\n    };\\n\\n    this.params = {\\n      p0: 0,\\n      p1: 0,\\n      p2: 0,\\n      p3: 0,\\n      sG: originalGoal.x\\n    };\\n\\n    for (let i = 0; i < RELAXATION_ITERATIONS; i++) {\\n      this.params.p0 += dStartCurv;\\n      this.params.p3 += dGoalCurv;\\n      this.goal.y += dGoalY;\\n      this.goal.rot += dGoalRot;\\n      this.goal.curv += dGoalCurv;\\n\\n      this.iterate();\\n    }\\n\\n    this.goal = originalGoal;\\n  }\\n\\n  optimize() {\\n    for (let i = 0; i < NEWTON_ITERATIONS; i++) {\\n      if (this.iterate()) {\\n        this.converged = true;\\n        return true;\\n      }\\n    }\\n\\n    this.converged = false;\\n    return false;\\n  }\\n\\n  iterate() {\\n    const { p0, p1, p2, p3, sG } = this.params;\\n\\n    const ds = sG / SIMPSONS_INTERVALS;\\n    const sG_2 = sG * sG;\\n    const sG_3 = sG_2 * sG;\\n\\n    let dX_p1 = 0;\\n    let dX_p2 = 0;\\n    let dX_sG = 0;\\n    let dY_p1 = 0;\\n    let dY_p2 = 0;\\n    let dY_sG = 0;\\n    let guessX = 0;\\n    let guessY = 0;\\n\\n    let theta, cosTheta, sinTheta, dT_p1, dT_p2, dT_sG;\\n\\n    for (let i = 0, s = 0; i <= SIMPSONS_INTERVALS; i++, s += ds) {\\n      const coeff = i == 0 || i == SIMPSONS_INTERVALS ? 1 : i % 2 == 0 ? 2 : 4;\\n\\n      const a = p0;\\n      const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\\n      const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\\n      const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\\n\\n      theta = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s;\\n      cosTheta = Math.cos(theta);\\n      sinTheta = Math.sin(theta);\\n\\n      const s_sG = s / sG;\\n      dT_p1 = ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s;\\n      dT_p2 = ((-3.375 * s_sG + 6) * s_sG - 2.25) * s_sG * s;\\n      dT_sG = ((3.375 * (p0 - 3 * p1 + 3 * p2 - p3) * s_sG - 3 * (2 * p0 - 5 * p1 + 4 * p2 - p3)) * s_sG + 0.25 * (11 * p0 - 18 * p1 + 9 * p2 - 2 * p3)) * s_sG * s_sG;\\n\\n      dX_p1 -= coeff * sinTheta * dT_p1;\\n      dX_p2 -= coeff * sinTheta * dT_p2;\\n      dX_sG -= coeff * sinTheta * dT_sG;\\n\\n      dY_p1 += coeff * cosTheta * dT_p1;\\n      dY_p2 += coeff * cosTheta * dT_p2;\\n      dY_sG += coeff * cosTheta * dT_sG;\\n\\n      guessX += coeff * cosTheta;\\n      guessY += coeff * sinTheta;\\n    }\\n\\n    // After the Simpson\\'s integration loop, `theta`, `cosTheta`, `sinTheta`,\\n    // `dT_p1`, `dT_p2`, and `dT_sG` hold the appropriate values for `sG`.\\n\\n    const hOver3 = sG / SIMPSONS_INTERVALS / 3;\\n\\n    const deltaX = this.goal.x - guessX * hOver3;\\n    const deltaY = this.goal.y - guessY * hOver3;\\n    const deltaRot = Math.wrapAngle(this.goal.rot - theta);\\n\\n    if (Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaRot) < CONVERGENCE_ERROR)\\n      return true;\\n\\n    jacobian.set(\\n      dX_p1 * hOver3, dX_p2 * hOver3, cosTheta + dX_sG * hOver3,\\n      dY_p1 * hOver3, dY_p2 * hOver3, sinTheta + dY_sG * hOver3,\\n      dT_p1, dT_p2, dT_sG\\n    );\\n\\n    const [m11, m21, m31, m12, m22, m32, m13, m23, m33] = invJacobian.getInverse(jacobian).elements;\\n\\n    this.params.p1 += m11 * deltaX + m12 * deltaY + m13 * deltaRot;\\n    this.params.p2 += m21 * deltaX + m22 * deltaY + m23 * deltaRot;\\n    this.params.sG += m31 * deltaX + m32 * deltaY + m33 * deltaRot;\\n\\n    return false;\\n  }\\n\\n  buildPath(num) {\\n    const { p0, p1, p2, p3, sG } = this.params;\\n\\n    const sG_2 = sG * sG;\\n    const sG_3 = sG_2 * sG;\\n\\n    const a = p0;\\n    const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\\n    const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\\n    const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\\n\\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\\n    const ds = sG / (num - 1);\\n    let s = ds;\\n    let dx = 0;\\n    let dy = 0;\\n    let prevCosRot = Math.cos(path[0].rot);\\n    let prevSinRot = Math.sin(path[0].rot);\\n\\n    for (let i = 1; i < num - 1; i++) {\\n      const rot = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s + this.start.rot;\\n      const curv = ((d * s + c) * s + b) * s + a;\\n      const cosRot = Math.cos(rot);\\n      const sinRot = Math.sin(rot);\\n\\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\\n\\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\\n\\n      s += ds;\\n      prevCosRot = cosRot;\\n      prevSinRot = sinRot;\\n    }\\n\\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\\n\\n    return path;\\n  }\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL0N1YmljUGF0aC5qcz85NDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNlO0FBQ2Y7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsV0FBVyx5Q0FBeUM7QUFDeEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHlCQUF5QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxxQkFBcUI7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlHQUFpRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsNkZBQTZGOztBQUU5RztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHlGQUF5Rjs7QUFFeEc7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTSU1QU09OU19JTlRFUlZBTFMgPSA4O1xuY29uc3QgTkVXVE9OX0lURVJBVElPTlMgPSAxNjtcbmNvbnN0IFJFTEFYQVRJT05fSVRFUkFUSU9OUyA9IDMyO1xuY29uc3QgQ09OVkVSR0VOQ0VfRVJST1IgPSAwLjAxO1xuXG5jb25zdCBqYWNvYmlhbiA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5jb25zdCBpbnZKYWNvYmlhbiA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cbi8vIEFsdGVybmF0ZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9BcG9sbG9BdXRvL2Fwb2xsby9ibG9iL21hc3Rlci9tb2R1bGVzL3BsYW5uaW5nL21hdGgvc3BpcmFsX2N1cnZlL2N1YmljX3NwaXJhbF9jdXJ2ZS5jY1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3ViaWNQYXRoIHtcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgcGFyYW1zID0gbnVsbCkge1xuICAgIHRoaXMuc3RhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFydCk7XG4gICAgdGhpcy5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBlbmQpO1xuXG4gICAgaWYgKHN0YXJ0LnBvcykge1xuICAgICAgdGhpcy5zdGFydC54ID0gc3RhcnQucG9zLng7XG4gICAgICB0aGlzLnN0YXJ0LnkgPSBzdGFydC5wb3MueVxuICAgIH1cblxuICAgIGlmIChlbmQucG9zKSB7XG4gICAgICB0aGlzLmVuZC54ID0gZW5kLnBvcy54O1xuICAgICAgdGhpcy5lbmQueSA9IGVuZC5wb3MueVxuICAgIH1cblxuICAgIGNvbnN0IGRpZmZYID0gdGhpcy5lbmQueCAtIHRoaXMuc3RhcnQueDtcbiAgICBjb25zdCBkaWZmWSA9IHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0Lnk7XG4gICAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4odGhpcy5zdGFydC5yb3QpO1xuICAgIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHRoaXMuc3RhcnQucm90KTtcblxuICAgIHRoaXMuZ29hbCA9IHtcbiAgICAgIHg6IGNvc1JvdCAqIGRpZmZYICsgc2luUm90ICogZGlmZlksXG4gICAgICB5OiAtc2luUm90ICogZGlmZlggKyBjb3NSb3QgKiBkaWZmWSxcbiAgICAgIHJvdDogTWF0aC53cmFwQW5nbGUodGhpcy5lbmQucm90IC0gdGhpcy5zdGFydC5yb3QpLFxuICAgICAgY3VydjogdGhpcy5lbmQuY3VydlxuICAgIH07XG5cbiAgICBpZiAocGFyYW1zKVxuICAgICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHsgcDA6IHRoaXMuc3RhcnQuY3VydiwgcDM6IHRoaXMuZW5kLmN1cnYgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5ndWVzc0luaXRpYWxQYXJhbXMoKTtcblxuICAgIHRoaXMuY29udmVyZ2VkID0gZmFsc2U7XG4gIH1cblxuICBndWVzc0luaXRpYWxQYXJhbXMoKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxHb2FsID0gdGhpcy5nb2FsO1xuICAgIGNvbnN0IGRTdGFydEN1cnYgPSB0aGlzLnN0YXJ0LmN1cnYgLyBSRUxBWEFUSU9OX0lURVJBVElPTlM7XG4gICAgY29uc3QgZEdvYWxZID0gb3JpZ2luYWxHb2FsLnkgLyBSRUxBWEFUSU9OX0lURVJBVElPTlM7XG4gICAgY29uc3QgZEdvYWxSb3QgPSBvcmlnaW5hbEdvYWwucm90IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xuICAgIGNvbnN0IGRHb2FsQ3VydiA9IG9yaWdpbmFsR29hbC5jdXJ2IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xuXG4gICAgdGhpcy5nb2FsID0ge1xuICAgICAgeDogb3JpZ2luYWxHb2FsLngsXG4gICAgICB5OiAwLFxuICAgICAgcm90OiAwLFxuICAgICAgY3VydjogMFxuICAgIH07XG5cbiAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgIHAwOiAwLFxuICAgICAgcDE6IDAsXG4gICAgICBwMjogMCxcbiAgICAgIHAzOiAwLFxuICAgICAgc0c6IG9yaWdpbmFsR29hbC54XG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUkVMQVhBVElPTl9JVEVSQVRJT05TOyBpKyspIHtcbiAgICAgIHRoaXMucGFyYW1zLnAwICs9IGRTdGFydEN1cnY7XG4gICAgICB0aGlzLnBhcmFtcy5wMyArPSBkR29hbEN1cnY7XG4gICAgICB0aGlzLmdvYWwueSArPSBkR29hbFk7XG4gICAgICB0aGlzLmdvYWwucm90ICs9IGRHb2FsUm90O1xuICAgICAgdGhpcy5nb2FsLmN1cnYgKz0gZEdvYWxDdXJ2O1xuXG4gICAgICB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmdvYWwgPSBvcmlnaW5hbEdvYWw7XG4gIH1cblxuICBvcHRpbWl6ZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLml0ZXJhdGUoKSkge1xuICAgICAgICB0aGlzLmNvbnZlcmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29udmVyZ2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXRlcmF0ZSgpIHtcbiAgICBjb25zdCB7IHAwLCBwMSwgcDIsIHAzLCBzRyB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICBjb25zdCBkcyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTO1xuICAgIGNvbnN0IHNHXzIgPSBzRyAqIHNHO1xuICAgIGNvbnN0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgICBsZXQgZFhfcDEgPSAwO1xuICAgIGxldCBkWF9wMiA9IDA7XG4gICAgbGV0IGRYX3NHID0gMDtcbiAgICBsZXQgZFlfcDEgPSAwO1xuICAgIGxldCBkWV9wMiA9IDA7XG4gICAgbGV0IGRZX3NHID0gMDtcbiAgICBsZXQgZ3Vlc3NYID0gMDtcbiAgICBsZXQgZ3Vlc3NZID0gMDtcblxuICAgIGxldCB0aGV0YSwgY29zVGhldGEsIHNpblRoZXRhLCBkVF9wMSwgZFRfcDIsIGRUX3NHO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrLCBzICs9IGRzKSB7XG4gICAgICBjb25zdCBjb2VmZiA9IGkgPT0gMCB8fCBpID09IFNJTVBTT05TX0lOVEVSVkFMUyA/IDEgOiBpICUgMiA9PSAwID8gMiA6IDQ7XG5cbiAgICAgIGNvbnN0IGEgPSBwMDtcbiAgICAgIGNvbnN0IGIgPSAoLTUuNSAqIHAwICsgOSAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcbiAgICAgIGNvbnN0IGMgPSAoOSAqIHAwIC0gMjIuNSAqIHAxICsgMTggKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XG4gICAgICBjb25zdCBkID0gKC00LjUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykpIC8gc0dfMztcblxuICAgICAgdGhldGEgPSAoKChkICogcyAvIDQgKyBjIC8gMykgKiBzICsgYiAvIDIpICogcyArIGEpICogcztcbiAgICAgIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIGNvbnN0IHNfc0cgPSBzIC8gc0c7XG4gICAgICBkVF9wMSA9ICgoMy4zNzUgKiBzX3NHIC0gNy41KSAqIHNfc0cgKyA0LjUpICogc19zRyAqIHM7XG4gICAgICBkVF9wMiA9ICgoLTMuMzc1ICogc19zRyArIDYpICogc19zRyAtIDIuMjUpICogc19zRyAqIHM7XG4gICAgICBkVF9zRyA9ICgoMy4zNzUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykgKiBzX3NHIC0gMyAqICgyICogcDAgLSA1ICogcDEgKyA0ICogcDIgLSBwMykpICogc19zRyArIDAuMjUgKiAoMTEgKiBwMCAtIDE4ICogcDEgKyA5ICogcDIgLSAyICogcDMpKSAqIHNfc0cgKiBzX3NHO1xuXG4gICAgICBkWF9wMSAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDE7XG4gICAgICBkWF9wMiAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDI7XG4gICAgICBkWF9zRyAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfc0c7XG5cbiAgICAgIGRZX3AxICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wMTtcbiAgICAgIGRZX3AyICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wMjtcbiAgICAgIGRZX3NHICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9zRztcblxuICAgICAgZ3Vlc3NYICs9IGNvZWZmICogY29zVGhldGE7XG4gICAgICBndWVzc1kgKz0gY29lZmYgKiBzaW5UaGV0YTtcbiAgICB9XG5cbiAgICAvLyBBZnRlciB0aGUgU2ltcHNvbidzIGludGVncmF0aW9uIGxvb3AsIGB0aGV0YWAsIGBjb3NUaGV0YWAsIGBzaW5UaGV0YWAsXG4gICAgLy8gYGRUX3AxYCwgYGRUX3AyYCwgYW5kIGBkVF9zR2AgaG9sZCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzIGZvciBgc0dgLlxuXG4gICAgY29uc3QgaE92ZXIzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFMgLyAzO1xuXG4gICAgY29uc3QgZGVsdGFYID0gdGhpcy5nb2FsLnggLSBndWVzc1ggKiBoT3ZlcjM7XG4gICAgY29uc3QgZGVsdGFZID0gdGhpcy5nb2FsLnkgLSBndWVzc1kgKiBoT3ZlcjM7XG4gICAgY29uc3QgZGVsdGFSb3QgPSBNYXRoLndyYXBBbmdsZSh0aGlzLmdvYWwucm90IC0gdGhldGEpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRlbHRhWCkgKyBNYXRoLmFicyhkZWx0YVkpICsgTWF0aC5hYnMoZGVsdGFSb3QpIDwgQ09OVkVSR0VOQ0VfRVJST1IpXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGphY29iaWFuLnNldChcbiAgICAgIGRYX3AxICogaE92ZXIzLCBkWF9wMiAqIGhPdmVyMywgY29zVGhldGEgKyBkWF9zRyAqIGhPdmVyMyxcbiAgICAgIGRZX3AxICogaE92ZXIzLCBkWV9wMiAqIGhPdmVyMywgc2luVGhldGEgKyBkWV9zRyAqIGhPdmVyMyxcbiAgICAgIGRUX3AxLCBkVF9wMiwgZFRfc0dcbiAgICApO1xuXG4gICAgY29uc3QgW20xMSwgbTIxLCBtMzEsIG0xMiwgbTIyLCBtMzIsIG0xMywgbTIzLCBtMzNdID0gaW52SmFjb2JpYW4uZ2V0SW52ZXJzZShqYWNvYmlhbikuZWxlbWVudHM7XG5cbiAgICB0aGlzLnBhcmFtcy5wMSArPSBtMTEgKiBkZWx0YVggKyBtMTIgKiBkZWx0YVkgKyBtMTMgKiBkZWx0YVJvdDtcbiAgICB0aGlzLnBhcmFtcy5wMiArPSBtMjEgKiBkZWx0YVggKyBtMjIgKiBkZWx0YVkgKyBtMjMgKiBkZWx0YVJvdDtcbiAgICB0aGlzLnBhcmFtcy5zRyArPSBtMzEgKiBkZWx0YVggKyBtMzIgKiBkZWx0YVkgKyBtMzMgKiBkZWx0YVJvdDtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGJ1aWxkUGF0aChudW0pIHtcbiAgICBjb25zdCB7IHAwLCBwMSwgcDIsIHAzLCBzRyB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICBjb25zdCBzR18yID0gc0cgKiBzRztcbiAgICBjb25zdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gICAgY29uc3QgYSA9IHAwO1xuICAgIGNvbnN0IGIgPSAoLTUuNSAqIHAwICsgOSAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcbiAgICBjb25zdCBjID0gKDkgKiBwMCAtIDIyLjUgKiBwMSArIDE4ICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xuICAgIGNvbnN0IGQgPSAoLTQuNSAqIChwMCAtIDMgKiBwMSArIDMgKiBwMiAtIHAzKSkgLyBzR18zO1xuXG4gICAgY29uc3QgcGF0aCA9IFt7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5zdGFydC54LCB0aGlzLnN0YXJ0LnkpLCByb3Q6IHRoaXMuc3RhcnQucm90LCBjdXJ2OiB0aGlzLnN0YXJ0LmN1cnYgfV07XG4gICAgY29uc3QgZHMgPSBzRyAvIChudW0gLSAxKTtcbiAgICBsZXQgcyA9IGRzO1xuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcbiAgICBsZXQgcHJldkNvc1JvdCA9IE1hdGguY29zKHBhdGhbMF0ucm90KTtcbiAgICBsZXQgcHJldlNpblJvdCA9IE1hdGguc2luKHBhdGhbMF0ucm90KTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCByb3QgPSAoKChkICogcyAvIDQgKyBjIC8gMykgKiBzICsgYiAvIDIpICogcyArIGEpICogcyArIHRoaXMuc3RhcnQucm90O1xuICAgICAgY29uc3QgY3VydiA9ICgoZCAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuICAgICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3Mocm90KTtcbiAgICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHJvdCk7XG5cbiAgICAgIGR4ID0gZHggKiAoaSAtIDEpIC8gaSArIChjb3NSb3QgKyBwcmV2Q29zUm90KSAvICgyICogaSk7XG4gICAgICBkeSA9IGR5ICogKGkgLSAxKSAvIGkgKyAoc2luUm90ICsgcHJldlNpblJvdCkgLyAoMiAqIGkpO1xuXG4gICAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHMgKiBkeCArIHRoaXMuc3RhcnQueCwgcyAqIGR5ICsgdGhpcy5zdGFydC55KSwgcm90OiByb3QsIGN1cnY6IGN1cnYgfSk7XG5cbiAgICAgIHMgKz0gZHM7XG4gICAgICBwcmV2Q29zUm90ID0gY29zUm90O1xuICAgICAgcHJldlNpblJvdCA9IHNpblJvdDtcbiAgICB9XG5cbiAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuZW5kLngsIHRoaXMuZW5kLnkpLCByb3Q6IHRoaXMuZW5kLnJvdCwgY3VydjogdGhpcy5lbmQuY3VydiB9KTtcblxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///2\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return LanePath; });\\nconst halfLaneWidth = 3.7;\\n\\nconst centerlineGeometry = new THREE.Geometry();\\nconst leftBoundaryGeometry = new THREE.Geometry();\\nconst rightBoundaryGeometry = new THREE.Geometry();\\n\\nclass LanePath {\\n  static hydrate(obj) {\\n    Object.setPrototypeOf(obj, LanePath.prototype);\\n  }\\n\\n  constructor() {\\n    this.anchors = [];\\n    this.centerlines = [];\\n    this.sampleLengths = [];\\n    this.arcLengths = [];\\n    this.leftBoundaries = [];\\n    this.rightBoundaries = [];\\n  }\\n\\n  get centerline() {\\n    return [].concat(...this.centerlines);\\n  }\\n\\n  get leftBoundary() {\\n    return [].concat(...this.leftBoundaries);\\n  }\\n\\n  get rightBoundary() {\\n    return [].concat(...this.rightBoundaries);\\n  }\\n\\n  get arcLength() {\\n    return this.arcLengths.reduce((sum, l) => sum + l, 0);\\n  }\\n\\n  sampleStations(startStation, num, interval) {\\n    const samples = [];\\n    let anchorIndex = 0;\\n    let sampleIndex = 0;\\n    let totalLength = 0;\\n    let nextStation = startStation;\\n\\n    while (totalLength + this.arcLengths[anchorIndex] < nextStation) {\\n      totalLength += this.arcLengths[anchorIndex];\\n\\n      if (++anchorIndex >= this.arcLengths.length)\\n        return samples;\\n    }\\n\\n    for (let i = 0; i < num; i++) {\\n      let length = this.sampleLengths[anchorIndex][sampleIndex];\\n      while (totalLength + length < nextStation) {\\n        totalLength += length;\\n\\n        if (++sampleIndex >= this.sampleLengths[anchorIndex].length) {\\n          sampleIndex = 0;\\n\\n          if (++anchorIndex >= this.sampleLengths.length)\\n            return samples;\\n        }\\n\\n        length = this.sampleLengths[anchorIndex][sampleIndex];\\n      }\\n\\n      const [p0, p1, p2, p3] = this.anchorsForSplineIndex(anchorIndex);\\n      const weight = (sampleIndex + (nextStation - totalLength) / length) / this.sampleLengths[anchorIndex].length;\\n      const pos = catmullRomVec(weight, p0, p1, p2, p3);\\n      const tangent = tangentAt(weight, p0, p1, p2, p3);\\n      const rot = Math.atan2(tangent.y, tangent.x);\\n      const curv = curvatureAt(weight, p0, p1, p2, p3);\\n\\n      samples.push({ pos, rot, curv });\\n      nextStation += interval;\\n    }\\n\\n    return samples;\\n  }\\n\\n  stationLatitudeFromPosition(position, aroundAnchorIndex = null) {\\n    const [anchorIndex, sampleIndex, sampleStation, prevSampleStation] = this._findClosestSample(position, aroundAnchorIndex);\\n\\n    if (anchorIndex === undefined) return [0, 0, 0];\\n\\n    let prevPoint;\\n    let nextPoint;\\n    let prevStation;\\n    let nextStation;\\n\\n    if (anchorIndex == 0 && sampleIndex == 0) {\\n      prevPoint = this.centerlines[anchorIndex][sampleIndex];\\n      nextPoint = this.centerlines[anchorIndex][sampleIndex + 1];\\n      prevStation = 0;\\n      nextStation = this.sampleLengths[anchorIndex][sampleIndex];\\n    } else if (anchorIndex == this.centerlines.length - 1 && sampleIndex == this.centerlines[anchorIndex].length - 1) {\\n      prevPoint = this.centerlines[anchorIndex][sampleIndex - 1];\\n      nextPoint = this.centerlines[anchorIndex][sampleIndex];\\n      prevStation = prevSampleStation;\\n      nextStation = sampleStation;\\n    } else {\\n      prevPoint = sampleIndex == 0 ? this.centerlines[anchorIndex - 1][this.centerlines[anchorIndex - 1].length - 1] : this.centerlines[anchorIndex][sampleIndex - 1];\\n      nextPoint = sampleIndex == this.centerlines[anchorIndex].length - 1 ? this.centerlines[anchorIndex + 1][0] : this.centerlines[anchorIndex][sampleIndex + 1];\\n\\n      const possibleNext = this.centerlines[anchorIndex][sampleIndex];\\n      const possibleProgress = position.clone().sub(prevPoint).dot(possibleNext.clone().sub(prevPoint)) / prevPoint.distanceToSquared(possibleNext);\\n\\n      if (possibleProgress < 1) {\\n        nextPoint = possibleNext;\\n        prevStation = prevSampleStation;\\n        nextStation = sampleStation;\\n      } else {\\n        prevPoint = possibleNext;\\n        prevStation = sampleStation;\\n        nextStation = sampleStation + this.sampleLengths[anchorIndex][sampleIndex];\\n      }\\n    }\\n\\n    const progress = Math.clamp(position.clone().sub(prevPoint).dot(nextPoint.clone().sub(prevPoint)) / prevPoint.distanceToSquared(nextPoint), 0, 1);\\n    const projectedPosition = nextPoint.clone().sub(prevPoint).multiplyScalar(progress).add(prevPoint);\\n\\n    const station = prevStation + (nextStation - prevStation) * progress;\\n    const latitude = Math.sign((nextPoint.x - prevPoint.x) * (position.y - prevPoint.y) - (nextPoint.y - prevPoint.y) * (position.x - prevPoint.x)) * position.distanceTo(projectedPosition);\\n\\n    return [station, latitude, anchorIndex];\\n  }\\n\\n  _findClosestSample(position, aroundAnchorIndex = null) {\\n    let closest = Number.POSITIVE_INFINITY;\\n    let bestAnchorIndex;\\n    let bestSampleIndex;\\n    let bestStation;\\n    let bestPrevStation;\\n\\n    let currStation = 0;\\n    let prevStation = 0;\\n\\n    let startAnchorIndex = 0;\\n    let endAnchorIndex = this.centerlines.length - 1;\\n\\n    if (aroundAnchorIndex !== null) {\\n      startAnchorIndex = Math.max(0, aroundAnchorIndex - 2);\\n      endAnchorIndex = Math.min(this.centerlines.length - 1, aroundAnchorIndex + 2);\\n    }\\n\\n    if (startAnchorIndex > 0) {\\n      for (let anchorIndex = 0; anchorIndex < startAnchorIndex; anchorIndex++) {\\n        currStation += this.arcLengths[anchorIndex];\\n      }\\n\\n      prevStation = currStation - this.sampleLengths[startAnchorIndex - 1][this.sampleLengths[startAnchorIndex - 1].length - 1];\\n    }\\n\\n    for (let anchorIndex = startAnchorIndex; anchorIndex <= endAnchorIndex; anchorIndex++) {\\n      const centerline = this.centerlines[anchorIndex];\\n      for (let sampleIndex = 0; sampleIndex < centerline.length; sampleIndex++) {\\n        const distSq = position.distanceToSquared(centerline[sampleIndex]);\\n        if (distSq < closest) {\\n          closest = distSq;\\n          bestAnchorIndex = anchorIndex;\\n          bestSampleIndex = sampleIndex;\\n          bestStation = currStation;\\n          bestPrevStation = prevStation;\\n        }\\n\\n        prevStation = currStation;\\n        currStation += this.sampleLengths[anchorIndex][sampleIndex];\\n      }\\n    }\\n\\n    return [bestAnchorIndex, bestSampleIndex, bestStation, bestPrevStation];\\n  }\\n\\n  addAnchor(position, resample = true) {\\n    const index = this.anchors.push(position) - 1;\\n\\n    if (resample) {\\n      for (let i = index - 2; i < index; i++)\\n        this.resample(i);\\n    }\\n  }\\n\\n  updateAnchor(index, position) {\\n    this.anchors[index] = position;\\n\\n    for (let i = index - 2; i <= index + 1; i++)\\n      this.resample(i);\\n  }\\n\\n  removeAnchor(index) {\\n    if (index < 0 || index >= this.anchors.length) return;\\n\\n    this.anchors.splice(index, 1);\\n\\n    const segmentIndex = index < this.anchors.length ? index : index - 1;\\n    this.centerlines.splice(segmentIndex, 1);\\n    this.sampleLengths.splice(segmentIndex, 1);\\n    this.leftBoundaries.splice(segmentIndex, 1);\\n    this.rightBoundaries.splice(segmentIndex, 1);\\n    this.arcLengths.splice(segmentIndex, 1);\\n\\n    for (let i = segmentIndex - 2; i <= segmentIndex; i++)\\n      this.resample(i);\\n  }\\n\\n  resample(index) {\\n    if (index < 0 || index > this.anchors.length - 2) return;\\n\\n    const [p0, p1, p2, p3] = this.anchorsForSplineIndex(index);\\n    const points = [];\\n    const lengths = [];\\n    const leftBoundary = [];\\n    const rightBoundary = [];\\n    let prevPoint = null;\\n\\n    const pointsPerSegment = Math.max(10, Math.ceil(p1.distanceTo(p2) / 1));\\n    const numPoints = index == this.anchors.length - 2 ? pointsPerSegment + 1 : pointsPerSegment;\\n\\n    for (let i = 0; i < numPoints; i++) {\\n      const t = i / pointsPerSegment;\\n      const point = catmullRomVec(t, p0, p1, p2, p3);\\n      points.push(point);\\n\\n      if (prevPoint != null)\\n        lengths.push(prevPoint.distanceTo(point));\\n      prevPoint = point;\\n\\n      const tangent = tangentAt(t, p0, p1, p2, p3);\\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\\n\\n      leftBoundary.push(normal.clone().multiplyScalar(-halfLaneWidth).add(point));\\n      rightBoundary.push(normal.clone().multiplyScalar(halfLaneWidth).add(point));\\n    }\\n\\n    lengths.push(prevPoint.distanceTo(p2));\\n\\n    this.centerlines[index] = points;\\n    this.sampleLengths[index] = lengths;\\n    this.leftBoundaries[index] = leftBoundary;\\n    this.rightBoundaries[index] = rightBoundary;\\n    this.arcLengths[index] = lengths.reduce((sum, l) => sum + l, 0);\\n  }\\n\\n  resampleAll() {\\n    for (let i = 0; i < this.anchors.length; i++)\\n      this.resample(i);\\n  }\\n\\n  anchorsForSplineIndex(index) {\\n    let p;\\n    if (index == 0)\\n      p = [this.anchors[0]].concat(this.anchors.slice(0, 3));\\n    else\\n      p = this.anchors.slice(index - 1, index + 3);\\n\\n    if (p[3] === undefined)\\n      p[3] = p[2];\\n\\n    return p;\\n  }\\n}\\n\\nfunction catmullRom(t, p0, p1, p2, p3) {\\n  const v0 = (p2 - p0) * 0.5;\\n  const v1 = (p3 - p1) * 0.5;\\n  const t2 = t * t;\\n  const t3 = t * t2;\\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\\n}\\n\\nfunction catmullRomVec(t, p0, p1, p2, p3) {\\n  return new THREE.Vector2(catmullRom(t, p0.x, p1.x, p2.x, p3.x), catmullRom(t, p0.y, p1.y, p2.y, p3.y));\\n}\\n\\nfunction tangentAt(t, p0, p1, p2, p3) {\\n  const delta = 0.0001;\\n  let t1 = t - delta;\\n  let t2 = t + delta;\\n\\n  if (t1 < 0) t1 = 0;\\n  if (t2 > 1) t2 = 1;\\n\\n  const prev = catmullRomVec(t1, p0, p1, p2, p3);\\n  const next = catmullRomVec(t2, p0, p1, p2, p3);\\n\\n  return next.sub(prev).normalize();\\n}\\n\\nfunction curvatureAt(t2, p0, p1, p2, p3) {\\n  const delta = 0.0001;\\n\\n  // If we\\'re estimating curvature at one of the endpoints of the spline,\\n  // slightly shift it inwards to avoid infinite curvature.\\n  if (t2 == 0) t2 = delta;\\n  if (t2 == 1) t2 = 1 - delta;\\n\\n  let t1 = t2 - delta;\\n  let t3 = t2 + delta;\\n\\n  if (t1 < 0) t1 = 0;\\n  if (t3 > 1) t3 = 1;\\n\\n  const pt1 = catmullRomVec(t1, p0, p1, p2, p3);\\n  const pt2 = catmullRomVec(t2, p0, p1, p2, p3);\\n  const pt3 = catmullRomVec(t3, p0, p1, p2, p3);\\n\\n  return (Math.atan2(pt3.y - pt2.y, pt3.x - pt2.x) - Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)) / pt2.distanceTo(pt1);\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9MYW5lUGF0aC5qcz8wZmE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoYWxmTGFuZVdpZHRoID0gMy43O1xuXG5jb25zdCBjZW50ZXJsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbmNvbnN0IGxlZnRCb3VuZGFyeUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5jb25zdCByaWdodEJvdW5kYXJ5R2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFuZVBhdGgge1xuICBzdGF0aWMgaHlkcmF0ZShvYmopIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBMYW5lUGF0aC5wcm90b3R5cGUpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hbmNob3JzID0gW107XG4gICAgdGhpcy5jZW50ZXJsaW5lcyA9IFtdO1xuICAgIHRoaXMuc2FtcGxlTGVuZ3RocyA9IFtdO1xuICAgIHRoaXMuYXJjTGVuZ3RocyA9IFtdO1xuICAgIHRoaXMubGVmdEJvdW5kYXJpZXMgPSBbXTtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcmllcyA9IFtdO1xuICB9XG5cbiAgZ2V0IGNlbnRlcmxpbmUoKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi50aGlzLmNlbnRlcmxpbmVzKTtcbiAgfVxuXG4gIGdldCBsZWZ0Qm91bmRhcnkoKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi50aGlzLmxlZnRCb3VuZGFyaWVzKTtcbiAgfVxuXG4gIGdldCByaWdodEJvdW5kYXJ5KCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4udGhpcy5yaWdodEJvdW5kYXJpZXMpO1xuICB9XG5cbiAgZ2V0IGFyY0xlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmNMZW5ndGhzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLCAwKTtcbiAgfVxuXG4gIHNhbXBsZVN0YXRpb25zKHN0YXJ0U3RhdGlvbiwgbnVtLCBpbnRlcnZhbCkge1xuICAgIGNvbnN0IHNhbXBsZXMgPSBbXTtcbiAgICBsZXQgYW5jaG9ySW5kZXggPSAwO1xuICAgIGxldCBzYW1wbGVJbmRleCA9IDA7XG4gICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICBsZXQgbmV4dFN0YXRpb24gPSBzdGFydFN0YXRpb247XG5cbiAgICB3aGlsZSAodG90YWxMZW5ndGggKyB0aGlzLmFyY0xlbmd0aHNbYW5jaG9ySW5kZXhdIDwgbmV4dFN0YXRpb24pIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHRoaXMuYXJjTGVuZ3Roc1thbmNob3JJbmRleF07XG5cbiAgICAgIGlmICgrK2FuY2hvckluZGV4ID49IHRoaXMuYXJjTGVuZ3Rocy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzYW1wbGVzO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgIGxldCBsZW5ndGggPSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIHdoaWxlICh0b3RhbExlbmd0aCArIGxlbmd0aCA8IG5leHRTdGF0aW9uKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblxuICAgICAgICBpZiAoKytzYW1wbGVJbmRleCA+PSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdLmxlbmd0aCkge1xuICAgICAgICAgIHNhbXBsZUluZGV4ID0gMDtcblxuICAgICAgICAgIGlmICgrK2FuY2hvckluZGV4ID49IHRoaXMuc2FtcGxlTGVuZ3Rocy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDNdID0gdGhpcy5hbmNob3JzRm9yU3BsaW5lSW5kZXgoYW5jaG9ySW5kZXgpO1xuICAgICAgY29uc3Qgd2VpZ2h0ID0gKHNhbXBsZUluZGV4ICsgKG5leHRTdGF0aW9uIC0gdG90YWxMZW5ndGgpIC8gbGVuZ3RoKSAvIHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF0ubGVuZ3RoO1xuICAgICAgY29uc3QgcG9zID0gY2F0bXVsbFJvbVZlYyh3ZWlnaHQsIHAwLCBwMSwgcDIsIHAzKTtcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSB0YW5nZW50QXQod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBjb25zdCByb3QgPSBNYXRoLmF0YW4yKHRhbmdlbnQueSwgdGFuZ2VudC54KTtcbiAgICAgIGNvbnN0IGN1cnYgPSBjdXJ2YXR1cmVBdCh3ZWlnaHQsIHAwLCBwMSwgcDIsIHAzKTtcblxuICAgICAgc2FtcGxlcy5wdXNoKHsgcG9zLCByb3QsIGN1cnYgfSk7XG4gICAgICBuZXh0U3RhdGlvbiArPSBpbnRlcnZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtcGxlcztcbiAgfVxuXG4gIHN0YXRpb25MYXRpdHVkZUZyb21Qb3NpdGlvbihwb3NpdGlvbiwgYXJvdW5kQW5jaG9ySW5kZXggPSBudWxsKSB7XG4gICAgY29uc3QgW2FuY2hvckluZGV4LCBzYW1wbGVJbmRleCwgc2FtcGxlU3RhdGlvbiwgcHJldlNhbXBsZVN0YXRpb25dID0gdGhpcy5fZmluZENsb3Nlc3RTYW1wbGUocG9zaXRpb24sIGFyb3VuZEFuY2hvckluZGV4KTtcblxuICAgIGlmIChhbmNob3JJbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gWzAsIDAsIDBdO1xuXG4gICAgbGV0IHByZXZQb2ludDtcbiAgICBsZXQgbmV4dFBvaW50O1xuICAgIGxldCBwcmV2U3RhdGlvbjtcbiAgICBsZXQgbmV4dFN0YXRpb247XG5cbiAgICBpZiAoYW5jaG9ySW5kZXggPT0gMCAmJiBzYW1wbGVJbmRleCA9PSAwKSB7XG4gICAgICBwcmV2UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XG4gICAgICBuZXh0UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCArIDFdO1xuICAgICAgcHJldlN0YXRpb24gPSAwO1xuICAgICAgbmV4dFN0YXRpb24gPSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICB9IGVsc2UgaWYgKGFuY2hvckluZGV4ID09IHRoaXMuY2VudGVybGluZXMubGVuZ3RoIC0gMSAmJiBzYW1wbGVJbmRleCA9PSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XS5sZW5ndGggLSAxKSB7XG4gICAgICBwcmV2UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgcHJldlN0YXRpb24gPSBwcmV2U2FtcGxlU3RhdGlvbjtcbiAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlBvaW50ID0gc2FtcGxlSW5kZXggPT0gMCA/IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXggLSAxXVt0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4IC0gMV0ubGVuZ3RoIC0gMV0gOiB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gc2FtcGxlSW5kZXggPT0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF0ubGVuZ3RoIC0gMSA/IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXggKyAxXVswXSA6IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4ICsgMV07XG5cbiAgICAgIGNvbnN0IHBvc3NpYmxlTmV4dCA9IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIGNvbnN0IHBvc3NpYmxlUHJvZ3Jlc3MgPSBwb3NpdGlvbi5jbG9uZSgpLnN1YihwcmV2UG9pbnQpLmRvdChwb3NzaWJsZU5leHQuY2xvbmUoKS5zdWIocHJldlBvaW50KSkgLyBwcmV2UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQocG9zc2libGVOZXh0KTtcblxuICAgICAgaWYgKHBvc3NpYmxlUHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgIG5leHRQb2ludCA9IHBvc3NpYmxlTmV4dDtcbiAgICAgICAgcHJldlN0YXRpb24gPSBwcmV2U2FtcGxlU3RhdGlvbjtcbiAgICAgICAgbmV4dFN0YXRpb24gPSBzYW1wbGVTdGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9zc2libGVOZXh0O1xuICAgICAgICBwcmV2U3RhdGlvbiA9IHNhbXBsZVN0YXRpb247XG4gICAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbiArIHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5jbGFtcChwb3NpdGlvbi5jbG9uZSgpLnN1YihwcmV2UG9pbnQpLmRvdChuZXh0UG9pbnQuY2xvbmUoKS5zdWIocHJldlBvaW50KSkgLyBwcmV2UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQobmV4dFBvaW50KSwgMCwgMSk7XG4gICAgY29uc3QgcHJvamVjdGVkUG9zaXRpb24gPSBuZXh0UG9pbnQuY2xvbmUoKS5zdWIocHJldlBvaW50KS5tdWx0aXBseVNjYWxhcihwcm9ncmVzcykuYWRkKHByZXZQb2ludCk7XG5cbiAgICBjb25zdCBzdGF0aW9uID0gcHJldlN0YXRpb24gKyAobmV4dFN0YXRpb24gLSBwcmV2U3RhdGlvbikgKiBwcm9ncmVzcztcbiAgICBjb25zdCBsYXRpdHVkZSA9IE1hdGguc2lnbigobmV4dFBvaW50LnggLSBwcmV2UG9pbnQueCkgKiAocG9zaXRpb24ueSAtIHByZXZQb2ludC55KSAtIChuZXh0UG9pbnQueSAtIHByZXZQb2ludC55KSAqIChwb3NpdGlvbi54IC0gcHJldlBvaW50LngpKSAqIHBvc2l0aW9uLmRpc3RhbmNlVG8ocHJvamVjdGVkUG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIFtzdGF0aW9uLCBsYXRpdHVkZSwgYW5jaG9ySW5kZXhdO1xuICB9XG5cbiAgX2ZpbmRDbG9zZXN0U2FtcGxlKHBvc2l0aW9uLCBhcm91bmRBbmNob3JJbmRleCA9IG51bGwpIHtcbiAgICBsZXQgY2xvc2VzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgYmVzdEFuY2hvckluZGV4O1xuICAgIGxldCBiZXN0U2FtcGxlSW5kZXg7XG4gICAgbGV0IGJlc3RTdGF0aW9uO1xuICAgIGxldCBiZXN0UHJldlN0YXRpb247XG5cbiAgICBsZXQgY3VyclN0YXRpb24gPSAwO1xuICAgIGxldCBwcmV2U3RhdGlvbiA9IDA7XG5cbiAgICBsZXQgc3RhcnRBbmNob3JJbmRleCA9IDA7XG4gICAgbGV0IGVuZEFuY2hvckluZGV4ID0gdGhpcy5jZW50ZXJsaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKGFyb3VuZEFuY2hvckluZGV4ICE9PSBudWxsKSB7XG4gICAgICBzdGFydEFuY2hvckluZGV4ID0gTWF0aC5tYXgoMCwgYXJvdW5kQW5jaG9ySW5kZXggLSAyKTtcbiAgICAgIGVuZEFuY2hvckluZGV4ID0gTWF0aC5taW4odGhpcy5jZW50ZXJsaW5lcy5sZW5ndGggLSAxLCBhcm91bmRBbmNob3JJbmRleCArIDIpO1xuICAgIH1cblxuICAgIGlmIChzdGFydEFuY2hvckluZGV4ID4gMCkge1xuICAgICAgZm9yIChsZXQgYW5jaG9ySW5kZXggPSAwOyBhbmNob3JJbmRleCA8IHN0YXJ0QW5jaG9ySW5kZXg7IGFuY2hvckluZGV4KyspIHtcbiAgICAgICAgY3VyclN0YXRpb24gKz0gdGhpcy5hcmNMZW5ndGhzW2FuY2hvckluZGV4XTtcbiAgICAgIH1cblxuICAgICAgcHJldlN0YXRpb24gPSBjdXJyU3RhdGlvbiAtIHRoaXMuc2FtcGxlTGVuZ3Roc1tzdGFydEFuY2hvckluZGV4IC0gMV1bdGhpcy5zYW1wbGVMZW5ndGhzW3N0YXJ0QW5jaG9ySW5kZXggLSAxXS5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBhbmNob3JJbmRleCA9IHN0YXJ0QW5jaG9ySW5kZXg7IGFuY2hvckluZGV4IDw9IGVuZEFuY2hvckluZGV4OyBhbmNob3JJbmRleCsrKSB7XG4gICAgICBjb25zdCBjZW50ZXJsaW5lID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF07XG4gICAgICBmb3IgKGxldCBzYW1wbGVJbmRleCA9IDA7IHNhbXBsZUluZGV4IDwgY2VudGVybGluZS5sZW5ndGg7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgICAgY29uc3QgZGlzdFNxID0gcG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoY2VudGVybGluZVtzYW1wbGVJbmRleF0pO1xuICAgICAgICBpZiAoZGlzdFNxIDwgY2xvc2VzdCkge1xuICAgICAgICAgIGNsb3Nlc3QgPSBkaXN0U3E7XG4gICAgICAgICAgYmVzdEFuY2hvckluZGV4ID0gYW5jaG9ySW5kZXg7XG4gICAgICAgICAgYmVzdFNhbXBsZUluZGV4ID0gc2FtcGxlSW5kZXg7XG4gICAgICAgICAgYmVzdFN0YXRpb24gPSBjdXJyU3RhdGlvbjtcbiAgICAgICAgICBiZXN0UHJldlN0YXRpb24gPSBwcmV2U3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZTdGF0aW9uID0gY3VyclN0YXRpb247XG4gICAgICAgIGN1cnJTdGF0aW9uICs9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYmVzdEFuY2hvckluZGV4LCBiZXN0U2FtcGxlSW5kZXgsIGJlc3RTdGF0aW9uLCBiZXN0UHJldlN0YXRpb25dO1xuICB9XG5cbiAgYWRkQW5jaG9yKHBvc2l0aW9uLCByZXNhbXBsZSA9IHRydWUpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYW5jaG9ycy5wdXNoKHBvc2l0aW9uKSAtIDE7XG5cbiAgICBpZiAocmVzYW1wbGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDI7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICB0aGlzLnJlc2FtcGxlKGkpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUFuY2hvcihpbmRleCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmFuY2hvcnNbaW5kZXhdID0gcG9zaXRpb247XG5cbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAyOyBpIDw9IGluZGV4ICsgMTsgaSsrKVxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgfVxuXG4gIHJlbW92ZUFuY2hvcihpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5hbmNob3JzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmNob3JzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBjb25zdCBzZWdtZW50SW5kZXggPSBpbmRleCA8IHRoaXMuYW5jaG9ycy5sZW5ndGggPyBpbmRleCA6IGluZGV4IC0gMTtcbiAgICB0aGlzLmNlbnRlcmxpbmVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIHRoaXMuc2FtcGxlTGVuZ3Rocy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcbiAgICB0aGlzLmxlZnRCb3VuZGFyaWVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIHRoaXMucmlnaHRCb3VuZGFyaWVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIHRoaXMuYXJjTGVuZ3Rocy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcblxuICAgIGZvciAobGV0IGkgPSBzZWdtZW50SW5kZXggLSAyOyBpIDw9IHNlZ21lbnRJbmRleDsgaSsrKVxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgfVxuXG4gIHJlc2FtcGxlKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuYW5jaG9ycy5sZW5ndGggLSAyKSByZXR1cm47XG5cbiAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDNdID0gdGhpcy5hbmNob3JzRm9yU3BsaW5lSW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aHMgPSBbXTtcbiAgICBjb25zdCBsZWZ0Qm91bmRhcnkgPSBbXTtcbiAgICBjb25zdCByaWdodEJvdW5kYXJ5ID0gW107XG4gICAgbGV0IHByZXZQb2ludCA9IG51bGw7XG5cbiAgICBjb25zdCBwb2ludHNQZXJTZWdtZW50ID0gTWF0aC5tYXgoMTAsIE1hdGguY2VpbChwMS5kaXN0YW5jZVRvKHAyKSAvIDEpKTtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBpbmRleCA9PSB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMiA/IHBvaW50c1BlclNlZ21lbnQgKyAxIDogcG9pbnRzUGVyU2VnbWVudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSBpIC8gcG9pbnRzUGVyU2VnbWVudDtcbiAgICAgIGNvbnN0IHBvaW50ID0gY2F0bXVsbFJvbVZlYyh0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG5cbiAgICAgIGlmIChwcmV2UG9pbnQgIT0gbnVsbClcbiAgICAgICAgbGVuZ3Rocy5wdXNoKHByZXZQb2ludC5kaXN0YW5jZVRvKHBvaW50KSk7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcblxuICAgICAgY29uc3QgdGFuZ2VudCA9IHRhbmdlbnRBdCh0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBjb25zdCBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xuXG4gICAgICBsZWZ0Qm91bmRhcnkucHVzaChub3JtYWwuY2xvbmUoKS5tdWx0aXBseVNjYWxhcigtaGFsZkxhbmVXaWR0aCkuYWRkKHBvaW50KSk7XG4gICAgICByaWdodEJvdW5kYXJ5LnB1c2gobm9ybWFsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaGFsZkxhbmVXaWR0aCkuYWRkKHBvaW50KSk7XG4gICAgfVxuXG4gICAgbGVuZ3Rocy5wdXNoKHByZXZQb2ludC5kaXN0YW5jZVRvKHAyKSk7XG5cbiAgICB0aGlzLmNlbnRlcmxpbmVzW2luZGV4XSA9IHBvaW50cztcbiAgICB0aGlzLnNhbXBsZUxlbmd0aHNbaW5kZXhdID0gbGVuZ3RocztcbiAgICB0aGlzLmxlZnRCb3VuZGFyaWVzW2luZGV4XSA9IGxlZnRCb3VuZGFyeTtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcmllc1tpbmRleF0gPSByaWdodEJvdW5kYXJ5O1xuICAgIHRoaXMuYXJjTGVuZ3Roc1tpbmRleF0gPSBsZW5ndGhzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLCAwKTtcbiAgfVxuXG4gIHJlc2FtcGxlQWxsKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmNob3JzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgfVxuXG4gIGFuY2hvcnNGb3JTcGxpbmVJbmRleChpbmRleCkge1xuICAgIGxldCBwO1xuICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgcCA9IFt0aGlzLmFuY2hvcnNbMF1dLmNvbmNhdCh0aGlzLmFuY2hvcnMuc2xpY2UoMCwgMykpO1xuICAgIGVsc2VcbiAgICAgIHAgPSB0aGlzLmFuY2hvcnMuc2xpY2UoaW5kZXggLSAxLCBpbmRleCArIDMpO1xuXG4gICAgaWYgKHBbM10gPT09IHVuZGVmaW5lZClcbiAgICAgIHBbM10gPSBwWzJdO1xuXG4gICAgcmV0dXJuIHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2F0bXVsbFJvbSh0LCBwMCwgcDEsIHAyLCBwMykge1xuICBjb25zdCB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgY29uc3QgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIGNvbnN0IHQyID0gdCAqIHQ7XG4gIGNvbnN0IHQzID0gdCAqIHQyO1xuICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG5cbmZ1bmN0aW9uIGNhdG11bGxSb21WZWModCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKGNhdG11bGxSb20odCwgcDAueCwgcDEueCwgcDIueCwgcDMueCksIGNhdG11bGxSb20odCwgcDAueSwgcDEueSwgcDIueSwgcDMueSkpO1xufVxuXG5mdW5jdGlvbiB0YW5nZW50QXQodCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XG4gIGxldCB0MSA9IHQgLSBkZWx0YTtcbiAgbGV0IHQyID0gdCArIGRlbHRhO1xuXG4gIGlmICh0MSA8IDApIHQxID0gMDtcbiAgaWYgKHQyID4gMSkgdDIgPSAxO1xuXG4gIGNvbnN0IHByZXYgPSBjYXRtdWxsUm9tVmVjKHQxLCBwMCwgcDEsIHAyLCBwMyk7XG4gIGNvbnN0IG5leHQgPSBjYXRtdWxsUm9tVmVjKHQyLCBwMCwgcDEsIHAyLCBwMyk7XG5cbiAgcmV0dXJuIG5leHQuc3ViKHByZXYpLm5vcm1hbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBjdXJ2YXR1cmVBdCh0MiwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XG5cbiAgLy8gSWYgd2UncmUgZXN0aW1hdGluZyBjdXJ2YXR1cmUgYXQgb25lIG9mIHRoZSBlbmRwb2ludHMgb2YgdGhlIHNwbGluZSxcbiAgLy8gc2xpZ2h0bHkgc2hpZnQgaXQgaW53YXJkcyB0byBhdm9pZCBpbmZpbml0ZSBjdXJ2YXR1cmUuXG4gIGlmICh0MiA9PSAwKSB0MiA9IGRlbHRhO1xuICBpZiAodDIgPT0gMSkgdDIgPSAxIC0gZGVsdGE7XG5cbiAgbGV0IHQxID0gdDIgLSBkZWx0YTtcbiAgbGV0IHQzID0gdDIgKyBkZWx0YTtcblxuICBpZiAodDEgPCAwKSB0MSA9IDA7XG4gIGlmICh0MyA+IDEpIHQzID0gMTtcblxuICBjb25zdCBwdDEgPSBjYXRtdWxsUm9tVmVjKHQxLCBwMCwgcDEsIHAyLCBwMyk7XG4gIGNvbnN0IHB0MiA9IGNhdG11bGxSb21WZWModDIsIHAwLCBwMSwgcDIsIHAzKTtcbiAgY29uc3QgcHQzID0gY2F0bXVsbFJvbVZlYyh0MywgcDAsIHAxLCBwMiwgcDMpO1xuXG4gIHJldHVybiAoTWF0aC5hdGFuMihwdDMueSAtIHB0Mi55LCBwdDMueCAtIHB0Mi54KSAtIE1hdGguYXRhbjIocHQyLnkgLSBwdDEueSwgcHQyLnggLSBwdDEueCkpIC8gcHQyLmRpc3RhbmNlVG8ocHQxKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///3\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return GPGPU; });\\n/* Partially adapted from https://github.com/turbo/js/blob/master/turbo.js\\n *\\n * Turbo.js License:\\n * Copyright (c) 2016 minxomat\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in all\\n * copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\nconst vertexShaderCode = `#version 300 es\\nin vec2 position;\\nin vec2 texture;\\nout vec2 kernelPosition;\\n\\nvoid main(void) {\\n  kernelPosition = texture;\\n  gl_Position = vec4(position.xy, 0.0, 1.0);\\n}\\n`;\\n\\nconst fragmentShaderHeader = `#version 300 es\\nprecision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp sampler2DArray;\\nprecision highp sampler3D;\\nprecision highp samplerCube;\\n\\nin vec2 kernelPosition;\\nout vec4 kernelOut;\\nuniform ivec2 kernelSize;\\n`;\\n\\nclass GPGPU {\\n  static alloc(size, stride) {\\n    if (!Number.isInteger(stride) || stride < 1 || stride > 4)\\n      throw new Error(\\\"Data stride must be an integer between 1 and 4.\\\");\\n\\n    // Find the smallest perfect square greater than or equal to size\\n    const squareSize = Math.pow(Math.ceil(Math.sqrt(size)), 2);\\n\\n    const data = new Float32Array(squareSize * stride);\\n    data.gpgpuSize = size;\\n    data.gpgpuStride = stride;\\n    return data;\\n  }\\n\\n  constructor(configs, shared = {}) {\\n    this._setUpGL();\\n\\n    this.outputTextures = {};\\n    this.sharedTextures = {};\\n\\n    this.programs = configs.map(c => this._prepareProgram(c));\\n\\n    for (const name in shared) {\\n      const options = shared[name];\\n      const { width, height, channels, data } = options;\\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\\n    }\\n  }\\n\\n  updateSharedTextures(shared) {\\n    this.sharedTextures = {};\\n\\n    for (const name in shared) {\\n      const options = shared[name];\\n      const { width, height, channels, data } = options;\\n      if (this.sharedTextures[name]) this.gl.deleteTexture(this.sharedTextures[name]);\\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\\n    }\\n  }\\n\\n  updateProgram(programOrProgramIndex, config) {\\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\\n\\n    if (config.inputs)\\n      throw new Error('The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.');\\n\\n    if (config.meta)\\n      program.meta = Object.assign(program.meta, config.meta);\\n\\n    if (config.width !== undefined && config.height !== undefined)\\n      this.updateProgramSize(program, config.width, config.height);\\n\\n    if (typeof(config.uniforms) == 'object')\\n      this.updateProgramUniforms(program, config.uniforms);\\n  }\\n\\n  updateProgramInputs(programIndex, inputs) {\\n    const program = this.programs[programIndex];\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programIndex} does not exist.`);\\n\\n    if (program.inputTextures.length != inputs.length)\\n      throw new Error(`You must provide the same number of inputs as when the program was set up: got ${inputs.length} but expected ${program.inputTextures.length}.`);\\n\\n    const previousInputWidth = program.inputWidth;\\n    const previousInputHeight = program.inputHeight;\\n\\n    const config = program.config;\\n\\n    if (config.width === undefined || config.height === undefined) {\\n      program.inputWidth = undefined;\\n      program.inputHeight = undefined;\\n      program.inputDataSize = undefined;\\n    }\\n\\n    this._prepareProgramInputs(program, inputs);\\n\\n    if (program.inputWidth != previousInputWidth || program.inputHeight != previousInputHeight) {\\n      this.gl.useProgram(program.glProgram);\\n      this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\\n      this._prepareProgramOutput(program);\\n    }\\n  }\\n\\n  updateProgramSize(programOrProgramIndex, width, height) {\\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\\n\\n    if (program.inputTextures.length != 0)\\n      throw new Error(`Size can only be updated on programs with no inputs.`);\\n\\n    if (width == program.inputWidth && height == program.inputHeight) return;\\n\\n    program.inputWidth = width;\\n    program.inputHeight = height;\\n    program.inputDataSize = width * height;\\n\\n    this.gl.useProgram(program.glProgram);\\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\\n    this._prepareProgramOutput(program);\\n  }\\n\\n  updateProgramUniforms(programOrProgramIndex, uniforms) {\\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\\n    this.gl.useProgram(program.glProgram);\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\\n\\n    for (const uniformName in uniforms) {\\n      const value = uniforms[uniformName];\\n      let uniform;\\n\\n      if (uniform = program.uniforms[uniformName]) {\\n        this._setUniform(uniform.type, uniform.location, value)\\n      } else if (uniform = program.uniformTextures[uniformName]) {\\n        if (typeof(value) != 'object' || value.type != 'texture')\\n          throw new Error(`Expected texture type for uniform ${uniformName}.`);\\n\\n        const { width, height, channels, data } = uniform;\\n        if (program.uniformTextures[uniformName].texture) this.gl.deleteTexture(program.uniformTextures[uniformName].texture);\\n        program.uniformTextures[uniformName].texture = this._createTexture(data, width, height, channels, uniform);\\n      } else {\\n        throw new Error(`The uniform ${uniformName} does not exist in this program.`);\\n      }\\n    }\\n  }\\n\\n  run() {\\n    const outputs = [];\\n\\n    for (const program of this.programs) {\\n      this.gl.useProgram(program.glProgram);\\n      this.gl.viewport(0, 0, program.inputWidth, program.inputHeight);\\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\\n\\n      for (const [index, inputTexture] of program.inputTextures.entries()) {\\n        this.gl.activeTexture(this.gl.TEXTURE0 + index);\\n        this.gl.bindTexture(this.gl.TEXTURE_2D, inputTexture);\\n      }\\n\\n      for (const uniformName in program.uniformTextures) {\\n        const uniformTexture = program.uniformTextures[uniformName];\\n        this.gl.activeTexture(this.gl.TEXTURE0 + uniformTexture.index);\\n        this.gl.bindTexture(uniformTexture.target, uniformTexture.texture || this.sharedTextures[uniformTexture.name] || this.outputTextures[uniformTexture.name]);\\n      }\\n\\n      if (typeof(program.draw) == 'function') {\\n        program.draw(this, program);\\n      } else {\\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);\\n        this.gl.enableVertexAttribArray(program.textureLocation);\\n        this.gl.vertexAttribPointer(program.textureLocation, 2, this.gl.FLOAT, false, 0, 0);\\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\\n        this.gl.enableVertexAttribArray(program.positionLocation);\\n        this.gl.vertexAttribPointer(program.positionLocation, 2, this.gl.FLOAT, false, 0, 0);\\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\\n\\n        if (program.drawProxy) {\\n          const draw = (() => this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)).bind(this);\\n          program.drawProxy(this, program, draw);\\n        } else {\\n          this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\\n        }\\n      }\\n\\n      if (program.output && program.output.name && !program.output.read) {\\n        outputs.push(null);\\n      } else {\\n        const output = new Float32Array(program.inputWidth * program.inputHeight * 4);\\n        this.gl.readPixels(0, 0, program.inputWidth, program.inputHeight, this.gl.RGBA, this.gl.FLOAT, output);\\n        outputs.push(output.subarray(0, program.inputDataSize * 4));\\n      }\\n    }\\n\\n    return outputs;\\n  }\\n\\n  _setUpGL() {\\n    let canvas;\\n\\n    if (self.document)\\n      canvas = document.createElement('canvas');\\n    else if (self.OffscreenCanvas)\\n      canvas = new OffscreenCanvas(0, 0);\\n    else\\n      throw new Error('Could not create a canvas.');\\n\\n    const attr = { alpha: false, antialias: false };\\n    this.gl = canvas.getContext(\\\"webgl2\\\", attr) || canvas.getContext(\\\"experimental-webgl2\\\", attr);\\n\\n    if (!this.gl)\\n      throw new Error(\\\"Unable to initialize WebGL2. Your browser may not support it.\\\");\\n\\n    if (!this.gl.getExtension('EXT_color_buffer_float'))\\n      throw new Error('Required WebGL extension EXT_color_buffer_float not supported.');\\n\\n    if (!this.gl.getExtension('OES_texture_float_linear'))\\n      throw new Error('Required WebGL extension OES_texture_float_linear not supported.');\\n\\n    this.positionBuffer = this._newBuffer([-1, -1, 1, -1, 1, 1, -1, 1]);\\n    this.textureBuffer = this._newBuffer([0, 0, 1, 0, 1, 1, 0, 1]);\\n    this.indexBuffer = this._newBuffer([1, 2, 0, 3, 0, 2], Uint16Array, this.gl.ELEMENT_ARRAY_BUFFER);\\n  }\\n\\n  _prepareProgram(config) {\\n    const program = { config };\\n\\n    program.draw = config.draw;\\n    program.drawProxy = config.drawProxy;\\n    program.meta = Object.assign({}, config.meta);\\n\\n    if (config.width && config.height) {\\n      program.inputWidth = config.width;\\n      program.inputHeight = config.height;\\n      program.inputDataSize = config.width * config.height;\\n    }\\n\\n    program.output = config.output;\\n\\n    const kernel = config.kernel;\\n\\n    if (typeof(kernel) != 'string' || kernel.length == 0)\\n      throw new Error(\\\"Kernel code cannot be empty.\\\");\\n\\n    const inputs = config.inputs || [];\\n    const uniforms = config.uniforms || {};\\n\\n    this._prepareProgramInputs(program, inputs);\\n\\n    let fragmentShaderConfig = \\\"\\\";\\n    \\n    for (const index in inputs)\\n      fragmentShaderConfig += `uniform sampler2D _input${index};\\\\n`;\\n\\n    if (program.inputWidth === undefined || program.inputHeight === undefined)\\n      throw new Error(\\\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\\\");\\n\\n    program.uniformTextures = {};\\n    program.uniforms = {};\\n\\n    for (const uniformName in uniforms) {\\n      const uniform = uniforms[uniformName];\\n\\n      if (typeof(uniform) == 'number') {\\n        program.uniforms[uniformName] = {\\n          type: 'float',\\n          value: uniform\\n        };\\n        fragmentShaderConfig += `uniform float ${uniformName};\\\\n`;\\n      } else if (Array.isArray(uniform)) {\\n        if (uniform.length < 2 || uniform.length > 4)\\n          throw new Error(`Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).`);\\n\\n        const type = ['vec2', 'vec3', 'vec4'][uniform.length - 2];\\n        program.uniforms[uniformName] = {\\n          type: type,\\n          value: uniform\\n        };\\n        fragmentShaderConfig += `uniform ${type} ${uniformName};\\\\n`;\\n      } else {\\n        const { type, width, height, channels, data, value, length, name } = uniform;\\n\\n        if (type == 'texture' || type == 'outputTexture' || type == 'sharedTexture') {\\n          let target, type;\\n\\n          if (uniform.textureType == '3D') {\\n            target = this.gl.TEXTURE_3D;\\n            type = 'sampler3D';\\n          } else if (uniform.textureType == '2DArray') {\\n            target = this.gl.TEXTURE_2D_ARRAY;\\n            type = 'sampler2DArray';\\n          } else {\\n            target = this.gl.TEXTURE_2D;\\n            type = 'sampler2D';\\n          }\\n\\n          if (type == 'texture') {\\n            program.uniformTextures[uniformName] = { target, texture: data ? this._createTexture(data, width, height, channels, uniform) : null };\\n          } else {\\n            program.uniformTextures[uniformName] = { target, texture: null, name: name || uniformName };\\n          }\\n\\n          fragmentShaderConfig += `uniform ${type} ${uniformName};\\\\n`;\\n        } else {\\n          program.uniforms[uniformName] = { type, value };\\n          if (length !== undefined)\\n            fragmentShaderConfig += `uniform ${type} ${uniformName}[${length}];\\\\n`;\\n          else\\n            fragmentShaderConfig += `uniform ${type} ${uniformName};\\\\n`;\\n        }\\n      }\\n    }\\n\\n    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\\n    this.gl.shaderSource(vertexShader, config.vertexShader || vertexShaderCode);\\n    this.gl.compileShader(vertexShader);\\n\\n    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\\n      throw new Error(\\n        \\\"Could not build vertex shader (fatal).\\\\n\\\" + \\\"\\\\n\\\" +\\n        \\\"--- CODE DUMP ---\\\\n\\\" + (config.vertexShader || vertexShaderCode) + \\\"\\\\n\\\\n\\\" +\\n        \\\"--- ERROR LOG ---\\\\n\\\" + this.gl.getShaderInfoLog(vertexShader)\\n      );\\n    }\\n\\n    const fragmentShaderMain = `\\nvoid main() {\\n  kernelOut = vec4(kernel(${[...Array(inputs.length).keys()].map(i => `texture(_input${i}, kernelPosition)`).join(', ')}));\\n}\\n    `;\\n\\n    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\\n    const fragmentShaderSource = fragmentShaderHeader + fragmentShaderConfig + kernel + fragmentShaderMain;\\n    this.gl.shaderSource(fragmentShader, fragmentShaderSource);\\n    this.gl.compileShader(fragmentShader);\\n\\n    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {\\n      const source = fragmentShaderSource.split('\\\\n');\\n      let dbgMsg = \\\"ERROR: Could not build shader (fatal).\\\\n\\\\n------------------ KERNEL CODE DUMP ------------------\\\\n\\\"\\n\\n      for (let l = 0; l < source.length; l++)\\n        dbgMsg += `${l + 1}> ${source[l]}\\\\n`;\\n\\n      dbgMsg += \\\"\\\\n--------------------- ERROR  LOG ---------------------\\\\n\\\" + this.gl.getShaderInfoLog(fragmentShader);\\n\\n      throw new Error(dbgMsg);\\n    }\\n\\n    program.glProgram = this.gl.createProgram();\\n    this.gl.attachShader(program.glProgram, vertexShader);\\n    this.gl.attachShader(program.glProgram, fragmentShader);\\n    this.gl.linkProgram(program.glProgram);\\n    this.gl.useProgram(program.glProgram);\\n\\n    if (!this.gl.getProgramParameter(program.glProgram, this.gl.LINK_STATUS))\\n      throw new Error('Failed to link GLSL program code.');\\n\\n    let textureIndex = 0;\\n\\n    for (const input of program.inputTextures) {\\n      const location = this.gl.getUniformLocation(program.glProgram, `_input${textureIndex}`);\\n      this.gl.uniform1i(location, textureIndex);\\n      textureIndex++;\\n    }\\n\\n    for (const uniformName in program.uniformTextures) {\\n      program.uniformTextures[uniformName].index = textureIndex;\\n      const location = this.gl.getUniformLocation(program.glProgram, uniformName);\\n      this.gl.uniform1i(location, textureIndex);\\n      textureIndex++;\\n    }\\n\\n    for (const uniformName in program.uniforms) {\\n      const { type, value } = program.uniforms[uniformName];\\n      const location = program.uniforms[uniformName].location = this.gl.getUniformLocation(program.glProgram, uniformName);\\n\\n      if (value !== undefined)\\n        this._setUniform(type, location, value);\\n\\n      delete program.uniforms[uniformName].value;\\n    }\\n\\n    program.kernelSizeLocation = this.gl.getUniformLocation(program.glProgram, 'kernelSize');\\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\\n\\n    program.positionLocation = this.gl.getAttribLocation(program.glProgram, 'position');\\n    program.textureLocation = this.gl.getAttribLocation(program.glProgram, 'texture');\\n\\n    program.frameBuffer = this.gl.createFramebuffer();\\n    this._prepareProgramOutput(program);\\n\\n    return program;\\n  }\\n\\n  _prepareProgramInputs(program, inputs) {\\n    if (program.inputTextures)\\n      program.inputTextures.forEach(t => this.gl.deleteTexture(t));\\n\\n    program.inputTextures = [];\\n\\n    for (const [index, data] of inputs.entries()) {\\n      if (data.gpgpuSize === undefined || data.gpgpuStride === undefined)\\n        throw new Error('GPGPU inputs must be created by the `alloc` function.');\\n\\n      const size = Math.sqrt(data.length / data.gpgpuStride);\\n      if (size <= 0 || size % 1 != 0)\\n        throw new Error('GPGPU input size is expected to be a perfect square.');\\n\\n      if (program.inputWidth === undefined || program.inputHeight === undefined) {\\n        program.inputWidth = size;\\n        program.inputHeight = size;\\n        program.inputDataSize = data.gpgpuSize;\\n      } else if (size != program.inputWidth || size != program.inputHeight) {\\n        throw new Error(`All GPGPU inputs must be of the same size. Received ${data.gpgpuSize} (internal ${size * size}) but expected ${program.inputDataSize} (internal ${program.inputWidth * program.inputHeight}).`);\\n      }\\n\\n      program.inputTextures.push(this._createTexture(data, size, size, data.gpgpuStride));\\n    }\\n  }\\n\\n  _prepareProgramOutput(program) {\\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\\n\\n    const outputTexture = this._createTexture(null, program.inputWidth, program.inputHeight, 4, program.output);\\n\\n    if (program.output && program.output.textureType !== '3D' && program.output.textureType !== '2DArray') {\\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, outputTexture, 0);\\n      const frameBufferStatus = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\\n      if (!frameBufferStatus)\\n        throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\\n    }\\n\\n    if (program.outputTexture !== undefined)\\n      this.gl.deleteTexture(program.outputTexture);\\n    program.outputTexture = outputTexture;\\n\\n    if (program.output && program.output.name)\\n      this.outputTextures[program.output.name] = outputTexture;\\n  }\\n\\n  _setUniform(type, location, value) {\\n    switch (type) {\\n      case 'int': this.gl.uniform1i(location, value); break;\\n      case 'float': Array.isArray(value) ? this.gl.uniform1fv(location, value) : this.gl.uniform1f(location, value); break;\\n      case 'vec2': this.gl.uniform2fv(location, value); break;\\n      case 'vec3': this.gl.uniform3fv(location, value); break;\\n      case 'vec4': this.gl.uniform4fv(location, value); break;\\n      case 'mat3': this.gl.uniformMatrix3fv(location, value); break;\\n      default: throw new Error(`Unknown uniform type ${type}.`);\\n    }\\n  }\\n\\n  _newBuffer(data, klass, target) {\\n    const buf = this.gl.createBuffer();\\n\\n    this.gl.bindBuffer((target || this.gl.ARRAY_BUFFER), buf);\\n    this.gl.bufferData((target || this.gl.ARRAY_BUFFER), new (klass || Float32Array)(data), this.gl.STATIC_DRAW);\\n\\n    return buf;\\n  }\\n\\n  _createTexture(data, width, height, channels, options = {}) {\\n    const texture = this.gl.createTexture();\\n\\n    let internalFormat, format;\\n\\n    switch (channels) {\\n      case 1:\\n        internalFormat = this.gl.R32F;\\n        format = this.gl.RED;\\n        break;\\n      case 2:\\n        internalFormat = this.gl.RG32F;\\n        format = this.gl.RG;\\n        break;\\n      case 3:\\n        internalFormat = this.gl.RGB32F;\\n        format = this.gl.RGB;\\n        break;\\n      case 4:\\n        internalFormat = this.gl.RGBA32F;\\n        format = this.gl.RGBA;\\n        break;\\n      default:\\n        throw(\\\"Texture channels must between 1 and 4.\\\");\\n    }\\n\\n    const target = options.textureType == '3D' ? this.gl.TEXTURE_3D : options.textureType == '2DArray' ? this.gl.TEXTURE_2D_ARRAY : this.gl.TEXTURE_2D;\\n\\n    this.gl.bindTexture(target, texture);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_MIN_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_MAG_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\\n\\n    if (options.textureType == '3D' || options.textureType == '2DArray') {\\n      this.gl.texImage3D(target, 0, internalFormat, width, height, options.depth, 0, format, this.gl.FLOAT, data);\\n    } else {\\n      this.gl.texImage2D(target, 0, internalFormat, width, height, 0, format, this.gl.FLOAT, data);\\n    }\\n\\n    this.gl.bindTexture(target, null);\\n\\n    return texture;\\n  }\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9HUEdQVS5qcz80NDJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsc0JBQXNCOztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxhQUFhOztBQUV6RDtBQUNBLHdHQUF3RyxjQUFjLGdCQUFnQiw2QkFBNkI7O0FBRW5LO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxzQkFBc0I7O0FBRWxFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxzQkFBc0I7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUM1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBQYXJ0aWFsbHkgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90dXJiby9qcy9ibG9iL21hc3Rlci90dXJiby5qc1xuICpcbiAqIFR1cmJvLmpzIExpY2Vuc2U6XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgbWlueG9tYXRcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IHZlcnRleFNoYWRlckNvZGUgPSBgI3ZlcnNpb24gMzAwIGVzXG5pbiB2ZWMyIHBvc2l0aW9uO1xuaW4gdmVjMiB0ZXh0dXJlO1xub3V0IHZlYzIga2VybmVsUG9zaXRpb247XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGtlcm5lbFBvc2l0aW9uID0gdGV4dHVyZTtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5LCAwLjAsIDEuMCk7XG59XG5gO1xuXG5jb25zdCBmcmFnbWVudFNoYWRlckhlYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5wcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyREFycmF5O1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIzRDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyQ3ViZTtcblxuaW4gdmVjMiBrZXJuZWxQb3NpdGlvbjtcbm91dCB2ZWM0IGtlcm5lbE91dDtcbnVuaWZvcm0gaXZlYzIga2VybmVsU2l6ZTtcbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdQR1BVIHtcbiAgc3RhdGljIGFsbG9jKHNpemUsIHN0cmlkZSkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzdHJpZGUpIHx8IHN0cmlkZSA8IDEgfHwgc3RyaWRlID4gNClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgc3RyaWRlIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQuXCIpO1xuXG4gICAgLy8gRmluZCB0aGUgc21hbGxlc3QgcGVyZmVjdCBzcXVhcmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHNpemVcbiAgICBjb25zdCBzcXVhcmVTaXplID0gTWF0aC5wb3coTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSksIDIpO1xuXG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc3F1YXJlU2l6ZSAqIHN0cmlkZSk7XG4gICAgZGF0YS5ncGdwdVNpemUgPSBzaXplO1xuICAgIGRhdGEuZ3BncHVTdHJpZGUgPSBzdHJpZGU7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWdzLCBzaGFyZWQgPSB7fSkge1xuICAgIHRoaXMuX3NldFVwR0woKTtcblxuICAgIHRoaXMub3V0cHV0VGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLnNoYXJlZFRleHR1cmVzID0ge307XG5cbiAgICB0aGlzLnByb2dyYW1zID0gY29uZmlncy5tYXAoYyA9PiB0aGlzLl9wcmVwYXJlUHJvZ3JhbShjKSk7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2hhcmVkKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gc2hhcmVkW25hbWVdO1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gb3B0aW9ucztcbiAgICAgIHRoaXMuc2hhcmVkVGV4dHVyZXNbbmFtZV0gPSB0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTaGFyZWRUZXh0dXJlcyhzaGFyZWQpIHtcbiAgICB0aGlzLnNoYXJlZFRleHR1cmVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2hhcmVkKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gc2hhcmVkW25hbWVdO1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gb3B0aW9ucztcbiAgICAgIGlmICh0aGlzLnNoYXJlZFRleHR1cmVzW25hbWVdKSB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy5zaGFyZWRUZXh0dXJlc1tuYW1lXSk7XG4gICAgICB0aGlzLnNoYXJlZFRleHR1cmVzW25hbWVdID0gdGhpcy5fY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUHJvZ3JhbShwcm9ncmFtT3JQcm9ncmFtSW5kZXgsIGNvbmZpZykge1xuICAgIGNvbnN0IHByb2dyYW0gPSB0eXBlb2YocHJvZ3JhbU9yUHJvZ3JhbUluZGV4KSA9PSAnbnVtYmVyJyA/IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbU9yUHJvZ3JhbUluZGV4XSA6IHByb2dyYW1PclByb2dyYW1JbmRleDtcblxuICAgIGlmICghcHJvZ3JhbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSB3aXRoIGluZGV4ICR7cHJvZ3JhbU9yUHJvZ3JhbUluZGV4fSBkb2VzIG5vdCBleGlzdC5gKTtcblxuICAgIGlmIChjb25maWcuaW5wdXRzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHVwZGF0ZVByb2dyYW1gIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIHVwZGF0ZSBpbnB1dHMuIFVzZSBgdXBkYXRlUHJvZ3JhbUlucHV0c2AgaW5zdGVhZC4nKTtcblxuICAgIGlmIChjb25maWcubWV0YSlcbiAgICAgIHByb2dyYW0ubWV0YSA9IE9iamVjdC5hc3NpZ24ocHJvZ3JhbS5tZXRhLCBjb25maWcubWV0YSk7XG5cbiAgICBpZiAoY29uZmlnLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmhlaWdodCAhPT0gdW5kZWZpbmVkKVxuICAgICAgdGhpcy51cGRhdGVQcm9ncmFtU2l6ZShwcm9ncmFtLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQpO1xuXG4gICAgaWYgKHR5cGVvZihjb25maWcudW5pZm9ybXMpID09ICdvYmplY3QnKVxuICAgICAgdGhpcy51cGRhdGVQcm9ncmFtVW5pZm9ybXMocHJvZ3JhbSwgY29uZmlnLnVuaWZvcm1zKTtcbiAgfVxuXG4gIHVwZGF0ZVByb2dyYW1JbnB1dHMocHJvZ3JhbUluZGV4LCBpbnB1dHMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtc1twcm9ncmFtSW5kZXhdO1xuXG4gICAgaWYgKCFwcm9ncmFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xuXG4gICAgaWYgKHByb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGggIT0gaW5wdXRzLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcHJvdmlkZSB0aGUgc2FtZSBudW1iZXIgb2YgaW5wdXRzIGFzIHdoZW4gdGhlIHByb2dyYW0gd2FzIHNldCB1cDogZ290ICR7aW5wdXRzLmxlbmd0aH0gYnV0IGV4cGVjdGVkICR7cHJvZ3JhbS5pbnB1dFRleHR1cmVzLmxlbmd0aH0uYCk7XG5cbiAgICBjb25zdCBwcmV2aW91c0lucHV0V2lkdGggPSBwcm9ncmFtLmlucHV0V2lkdGg7XG4gICAgY29uc3QgcHJldmlvdXNJbnB1dEhlaWdodCA9IHByb2dyYW0uaW5wdXRIZWlnaHQ7XG5cbiAgICBjb25zdCBjb25maWcgPSBwcm9ncmFtLmNvbmZpZztcblxuICAgIGlmIChjb25maWcud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb25maWcuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2dyYW0uaW5wdXRXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHByb2dyYW0uaW5wdXRIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1JbnB1dHMocHJvZ3JhbSwgaW5wdXRzKTtcblxuICAgIGlmIChwcm9ncmFtLmlucHV0V2lkdGggIT0gcHJldmlvdXNJbnB1dFdpZHRoIHx8IHByb2dyYW0uaW5wdXRIZWlnaHQgIT0gcHJldmlvdXNJbnB1dEhlaWdodCkge1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTJpKHByb2dyYW0ua2VybmVsU2l6ZUxvY2F0aW9uLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuICAgICAgdGhpcy5fcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUHJvZ3JhbVNpemUocHJvZ3JhbU9yUHJvZ3JhbUluZGV4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHR5cGVvZihwcm9ncmFtT3JQcm9ncmFtSW5kZXgpID09ICdudW1iZXInID8gdGhpcy5wcm9ncmFtc1twcm9ncmFtT3JQcm9ncmFtSW5kZXhdIDogcHJvZ3JhbU9yUHJvZ3JhbUluZGV4O1xuXG4gICAgaWYgKCFwcm9ncmFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtT3JQcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xuXG4gICAgaWYgKHByb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGggIT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2l6ZSBjYW4gb25seSBiZSB1cGRhdGVkIG9uIHByb2dyYW1zIHdpdGggbm8gaW5wdXRzLmApO1xuXG4gICAgaWYgKHdpZHRoID09IHByb2dyYW0uaW5wdXRXaWR0aCAmJiBoZWlnaHQgPT0gcHJvZ3JhbS5pbnB1dEhlaWdodCkgcmV0dXJuO1xuXG4gICAgcHJvZ3JhbS5pbnB1dFdpZHRoID0gd2lkdGg7XG4gICAgcHJvZ3JhbS5pbnB1dEhlaWdodCA9IGhlaWdodDtcbiAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSB3aWR0aCAqIGhlaWdodDtcblxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtLmdsUHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51bmlmb3JtMmkocHJvZ3JhbS5rZXJuZWxTaXplTG9jYXRpb24sIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCk7XG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSk7XG4gIH1cblxuICB1cGRhdGVQcm9ncmFtVW5pZm9ybXMocHJvZ3JhbU9yUHJvZ3JhbUluZGV4LCB1bmlmb3Jtcykge1xuICAgIGNvbnN0IHByb2dyYW0gPSB0eXBlb2YocHJvZ3JhbU9yUHJvZ3JhbUluZGV4KSA9PSAnbnVtYmVyJyA/IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbU9yUHJvZ3JhbUluZGV4XSA6IHByb2dyYW1PclByb2dyYW1JbmRleDtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuXG4gICAgaWYgKCFwcm9ncmFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtT3JQcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xuXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG4gICAgICBsZXQgdW5pZm9ybTtcblxuICAgICAgaWYgKHVuaWZvcm0gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXSkge1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKHVuaWZvcm0udHlwZSwgdW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHVuaWZvcm0gPSBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0pIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgIT0gJ29iamVjdCcgfHwgdmFsdWUudHlwZSAhPSAndGV4dHVyZScpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0ZXh0dXJlIHR5cGUgZm9yIHVuaWZvcm0gJHt1bmlmb3JtTmFtZX0uYCk7XG5cbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gdW5pZm9ybTtcbiAgICAgICAgaWYgKHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXS50ZXh0dXJlKSB0aGlzLmdsLmRlbGV0ZVRleHR1cmUocHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdLnRleHR1cmUpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0udGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIHVuaWZvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pZm9ybSAke3VuaWZvcm1OYW1lfSBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHByb2dyYW0uYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcnVuKCkge1xuICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgcHJvZ3JhbSBvZiB0aGlzLnByb2dyYW1zKSB7XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgcHJvZ3JhbS5mcmFtZUJ1ZmZlcik7XG5cbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBpbnB1dFRleHR1cmVdIG9mIHByb2dyYW0uaW5wdXRUZXh0dXJlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHByb2dyYW0udW5pZm9ybVRleHR1cmVzKSB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1UZXh0dXJlID0gcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdO1xuICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHVuaWZvcm1UZXh0dXJlLmluZGV4KTtcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh1bmlmb3JtVGV4dHVyZS50YXJnZXQsIHVuaWZvcm1UZXh0dXJlLnRleHR1cmUgfHwgdGhpcy5zaGFyZWRUZXh0dXJlc1t1bmlmb3JtVGV4dHVyZS5uYW1lXSB8fCB0aGlzLm91dHB1dFRleHR1cmVzW3VuaWZvcm1UZXh0dXJlLm5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZihwcm9ncmFtLmRyYXcpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvZ3JhbS5kcmF3KHRoaXMsIHByb2dyYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRleHR1cmVCdWZmZXIpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHByb2dyYW0udGV4dHVyZUxvY2F0aW9uKTtcbiAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0udGV4dHVyZUxvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKHByb2dyYW0uZHJhd1Byb3h5KSB7XG4gICAgICAgICAgY29uc3QgZHJhdyA9ICgoKSA9PiB0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUywgNiwgdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwgMCkpLmJpbmQodGhpcyk7XG4gICAgICAgICAgcHJvZ3JhbS5kcmF3UHJveHkodGhpcywgcHJvZ3JhbSwgZHJhdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHModGhpcy5nbC5UUklBTkdMRVMsIDYsIHRoaXMuZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9ncmFtLm91dHB1dCAmJiBwcm9ncmFtLm91dHB1dC5uYW1lICYmICFwcm9ncmFtLm91dHB1dC5yZWFkKSB7XG4gICAgICAgIG91dHB1dHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkocHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodCAqIDQpO1xuICAgICAgICB0aGlzLmdsLnJlYWRQaXhlbHMoMCwgMCwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0LCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuRkxPQVQsIG91dHB1dCk7XG4gICAgICAgIG91dHB1dHMucHVzaChvdXRwdXQuc3ViYXJyYXkoMCwgcHJvZ3JhbS5pbnB1dERhdGFTaXplICogNCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRzO1xuICB9XG5cbiAgX3NldFVwR0woKSB7XG4gICAgbGV0IGNhbnZhcztcblxuICAgIGlmIChzZWxmLmRvY3VtZW50KVxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgZWxzZSBpZiAoc2VsZi5PZmZzY3JlZW5DYW52YXMpXG4gICAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSBhIGNhbnZhcy4nKTtcblxuICAgIGNvbnN0IGF0dHIgPSB7IGFscGhhOiBmYWxzZSwgYW50aWFsaWFzOiBmYWxzZSB9O1xuICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBhdHRyKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbDJcIiwgYXR0cik7XG5cbiAgICBpZiAoIXRoaXMuZ2wpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBXZWJHTDIuIFlvdXIgYnJvd3NlciBtYXkgbm90IHN1cHBvcnQgaXQuXCIpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBXZWJHTCBleHRlbnNpb24gRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCBub3Qgc3VwcG9ydGVkLicpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIFdlYkdMIGV4dGVuc2lvbiBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgbm90IHN1cHBvcnRlZC4nKTtcblxuICAgIHRoaXMucG9zaXRpb25CdWZmZXIgPSB0aGlzLl9uZXdCdWZmZXIoWy0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyID0gdGhpcy5fbmV3QnVmZmVyKFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IHRoaXMuX25ld0J1ZmZlcihbMSwgMiwgMCwgMywgMCwgMl0sIFVpbnQxNkFycmF5LCB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKTtcbiAgfVxuXG4gIF9wcmVwYXJlUHJvZ3JhbShjb25maWcpIHtcbiAgICBjb25zdCBwcm9ncmFtID0geyBjb25maWcgfTtcblxuICAgIHByb2dyYW0uZHJhdyA9IGNvbmZpZy5kcmF3O1xuICAgIHByb2dyYW0uZHJhd1Byb3h5ID0gY29uZmlnLmRyYXdQcm94eTtcbiAgICBwcm9ncmFtLm1ldGEgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcubWV0YSk7XG5cbiAgICBpZiAoY29uZmlnLndpZHRoICYmIGNvbmZpZy5oZWlnaHQpIHtcbiAgICAgIHByb2dyYW0uaW5wdXRXaWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgIHByb2dyYW0uaW5wdXRIZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgcHJvZ3JhbS5pbnB1dERhdGFTaXplID0gY29uZmlnLndpZHRoICogY29uZmlnLmhlaWdodDtcbiAgICB9XG5cbiAgICBwcm9ncmFtLm91dHB1dCA9IGNvbmZpZy5vdXRwdXQ7XG5cbiAgICBjb25zdCBrZXJuZWwgPSBjb25maWcua2VybmVsO1xuXG4gICAgaWYgKHR5cGVvZihrZXJuZWwpICE9ICdzdHJpbmcnIHx8IGtlcm5lbC5sZW5ndGggPT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBjb2RlIGNhbm5vdCBiZSBlbXB0eS5cIik7XG5cbiAgICBjb25zdCBpbnB1dHMgPSBjb25maWcuaW5wdXRzIHx8IFtdO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gY29uZmlnLnVuaWZvcm1zIHx8IHt9O1xuXG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1JbnB1dHMocHJvZ3JhbSwgaW5wdXRzKTtcblxuICAgIGxldCBmcmFnbWVudFNoYWRlckNvbmZpZyA9IFwiXCI7XG4gICAgXG4gICAgZm9yIChjb25zdCBpbmRleCBpbiBpbnB1dHMpXG4gICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSBzYW1wbGVyMkQgX2lucHV0JHtpbmRleH07XFxuYDtcblxuICAgIGlmIChwcm9ncmFtLmlucHV0V2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcm9ncmFtLmlucHV0SGVpZ2h0ID09PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGtlcm5lbCBzaXplLiBZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBpbnB1dCBvciB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcGFyYW1ldGVycyBpbiB0aGUga2VybmVsIGNvbmZpZy5cIik7XG5cbiAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcyA9IHt9O1xuICAgIHByb2dyYW0udW5pZm9ybXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YodW5pZm9ybSkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICB9O1xuICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSBmbG9hdCAke3VuaWZvcm1OYW1lfTtcXG5gO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm0pKSB7XG4gICAgICAgIGlmICh1bmlmb3JtLmxlbmd0aCA8IDIgfHwgdW5pZm9ybS5sZW5ndGggPiA0KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXkgdW5pZm9ybXMgY2FuIG9ubHkgaGF2ZSBsZW5ndGhzIG9mIDIsIDMsIG9yIDQgZWxlbWVudHMgKGNvcnJlc3BvbmRpbmcgdG8gdmVjMiwgdmVjMywgYW5kIHZlYzQpLmApO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBbJ3ZlYzInLCAndmVjMycsICd2ZWM0J11bdW5pZm9ybS5sZW5ndGggLSAyXTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICB9O1xuICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSAke3R5cGV9ICR7dW5pZm9ybU5hbWV9O1xcbmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBkYXRhLCB2YWx1ZSwgbGVuZ3RoLCBuYW1lIH0gPSB1bmlmb3JtO1xuXG4gICAgICAgIGlmICh0eXBlID09ICd0ZXh0dXJlJyB8fCB0eXBlID09ICdvdXRwdXRUZXh0dXJlJyB8fCB0eXBlID09ICdzaGFyZWRUZXh0dXJlJykge1xuICAgICAgICAgIGxldCB0YXJnZXQsIHR5cGU7XG5cbiAgICAgICAgICBpZiAodW5pZm9ybS50ZXh0dXJlVHlwZSA9PSAnM0QnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmdsLlRFWFRVUkVfM0Q7XG4gICAgICAgICAgICB0eXBlID0gJ3NhbXBsZXIzRCc7XG4gICAgICAgICAgfSBlbHNlIGlmICh1bmlmb3JtLnRleHR1cmVUeXBlID09ICcyREFycmF5Jykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nbC5URVhUVVJFXzJEX0FSUkFZO1xuICAgICAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkRBcnJheSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZ2wuVEVYVFVSRV8yRDtcbiAgICAgICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSAndGV4dHVyZScpIHtcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXSA9IHsgdGFyZ2V0LCB0ZXh0dXJlOiBkYXRhID8gdGhpcy5fY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgdW5pZm9ybSkgOiBudWxsIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXSA9IHsgdGFyZ2V0LCB0ZXh0dXJlOiBudWxsLCBuYW1lOiBuYW1lIHx8IHVuaWZvcm1OYW1lIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm1OYW1lfTtcXG5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdID0geyB0eXBlLCB2YWx1ZSB9O1xuICAgICAgICAgIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtTmFtZX1bJHtsZW5ndGh9XTtcXG5gO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtTmFtZX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCBjb25maWcudmVydGV4U2hhZGVyIHx8IHZlcnRleFNoYWRlckNvZGUpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGQgbm90IGJ1aWxkIHZlcnRleCBzaGFkZXIgKGZhdGFsKS5cXG5cIiArIFwiXFxuXCIgK1xuICAgICAgICBcIi0tLSBDT0RFIERVTVAgLS0tXFxuXCIgKyAoY29uZmlnLnZlcnRleFNoYWRlciB8fCB2ZXJ0ZXhTaGFkZXJDb2RlKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIi0tLSBFUlJPUiBMT0cgLS0tXFxuXCIgKyB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnbWVudFNoYWRlck1haW4gPSBgXG52b2lkIG1haW4oKSB7XG4gIGtlcm5lbE91dCA9IHZlYzQoa2VybmVsKCR7Wy4uLkFycmF5KGlucHV0cy5sZW5ndGgpLmtleXMoKV0ubWFwKGkgPT4gYHRleHR1cmUoX2lucHV0JHtpfSwga2VybmVsUG9zaXRpb24pYCkuam9pbignLCAnKX0pKTtcbn1cbiAgICBgO1xuXG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlckhlYWRlciArIGZyYWdtZW50U2hhZGVyQ29uZmlnICsga2VybmVsICsgZnJhZ21lbnRTaGFkZXJNYWluO1xuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgICBsZXQgZGJnTXNnID0gXCJFUlJPUjogQ291bGQgbm90IGJ1aWxkIHNoYWRlciAoZmF0YWwpLlxcblxcbi0tLS0tLS0tLS0tLS0tLS0tLSBLRVJORUwgQ09ERSBEVU1QIC0tLS0tLS0tLS0tLS0tLS0tLVxcblwiXG5cbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgc291cmNlLmxlbmd0aDsgbCsrKVxuICAgICAgICBkYmdNc2cgKz0gYCR7bCArIDF9PiAke3NvdXJjZVtsXX1cXG5gO1xuXG4gICAgICBkYmdNc2cgKz0gXCJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVJST1IgIExPRyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArIHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcik7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihkYmdNc2cpO1xuICAgIH1cblxuICAgIHByb2dyYW0uZ2xQcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbS5nbFByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbS5nbFByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbS5nbFByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbGluayBHTFNMIHByb2dyYW0gY29kZS4nKTtcblxuICAgIGxldCB0ZXh0dXJlSW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBwcm9ncmFtLmlucHV0VGV4dHVyZXMpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sIGBfaW5wdXQke3RleHR1cmVJbmRleH1gKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlSW5kZXgpO1xuICAgICAgdGV4dHVyZUluZGV4Kys7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcykge1xuICAgICAgcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdLmluZGV4ID0gdGV4dHVyZUluZGV4O1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHRleHR1cmVJbmRleCk7XG4gICAgICB0ZXh0dXJlSW5kZXgrKztcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHByb2dyYW0udW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKHR5cGUsIGxvY2F0aW9uLCB2YWx1ZSk7XG5cbiAgICAgIGRlbGV0ZSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS52YWx1ZTtcbiAgICB9XG5cbiAgICBwcm9ncmFtLmtlcm5lbFNpemVMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAna2VybmVsU2l6ZScpO1xuICAgIHRoaXMuZ2wudW5pZm9ybTJpKHByb2dyYW0ua2VybmVsU2l6ZUxvY2F0aW9uLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuXG4gICAgcHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ3Bvc2l0aW9uJyk7XG4gICAgcHJvZ3JhbS50ZXh0dXJlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAndGV4dHVyZScpO1xuXG4gICAgcHJvZ3JhbS5mcmFtZUJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLl9wcmVwYXJlUHJvZ3JhbU91dHB1dChwcm9ncmFtKTtcblxuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgX3ByZXBhcmVQcm9ncmFtSW5wdXRzKHByb2dyYW0sIGlucHV0cykge1xuICAgIGlmIChwcm9ncmFtLmlucHV0VGV4dHVyZXMpXG4gICAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMuZm9yRWFjaCh0ID0+IHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0KSk7XG5cbiAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2luZGV4LCBkYXRhXSBvZiBpbnB1dHMuZW50cmllcygpKSB7XG4gICAgICBpZiAoZGF0YS5ncGdwdVNpemUgPT09IHVuZGVmaW5lZCB8fCBkYXRhLmdwZ3B1U3RyaWRlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR1BHUFUgaW5wdXRzIG11c3QgYmUgY3JlYXRlZCBieSB0aGUgYGFsbG9jYCBmdW5jdGlvbi4nKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguc3FydChkYXRhLmxlbmd0aCAvIGRhdGEuZ3BncHVTdHJpZGUpO1xuICAgICAgaWYgKHNpemUgPD0gMCB8fCBzaXplICUgMSAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dQR1BVIGlucHV0IHNpemUgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwZXJmZWN0IHNxdWFyZS4nKTtcblxuICAgICAgaWYgKHByb2dyYW0uaW5wdXRXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IHByb2dyYW0uaW5wdXRIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9ncmFtLmlucHV0V2lkdGggPSBzaXplO1xuICAgICAgICBwcm9ncmFtLmlucHV0SGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgcHJvZ3JhbS5pbnB1dERhdGFTaXplID0gZGF0YS5ncGdwdVNpemU7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgIT0gcHJvZ3JhbS5pbnB1dFdpZHRoIHx8IHNpemUgIT0gcHJvZ3JhbS5pbnB1dEhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbCBHUEdQVSBpbnB1dHMgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplLiBSZWNlaXZlZCAke2RhdGEuZ3BncHVTaXplfSAoaW50ZXJuYWwgJHtzaXplICogc2l6ZX0pIGJ1dCBleHBlY3RlZCAke3Byb2dyYW0uaW5wdXREYXRhU2l6ZX0gKGludGVybmFsICR7cHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodH0pLmApO1xuICAgICAgfVxuXG4gICAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMucHVzaCh0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHNpemUsIHNpemUsIGRhdGEuZ3BncHVTdHJpZGUpKTtcbiAgICB9XG4gIH1cblxuICBfcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSkge1xuICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHByb2dyYW0uZnJhbWVCdWZmZXIpO1xuXG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUobnVsbCwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0LCA0LCBwcm9ncmFtLm91dHB1dCk7XG5cbiAgICBpZiAocHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5vdXRwdXQudGV4dHVyZVR5cGUgIT09ICczRCcgJiYgcHJvZ3JhbS5vdXRwdXQudGV4dHVyZVR5cGUgIT09ICcyREFycmF5Jykge1xuICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLmdsLlRFWFRVUkVfMkQsIG91dHB1dFRleHR1cmUsIDApO1xuICAgICAgY29uc3QgZnJhbWVCdWZmZXJTdGF0dXMgPSAodGhpcy5nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHRoaXMuZ2wuRlJBTUVCVUZGRVIpID09IHRoaXMuZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xuICAgICAgaWYgKCFmcmFtZUJ1ZmZlclN0YXR1cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhdHRhY2hpbmcgZmxvYXQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlci4gWW91ciBkZXZpY2UgaXMgcHJvYmFibHkgaW5jb21wYXRpYmxlLicpO1xuICAgIH1cblxuICAgIGlmIChwcm9ncmFtLm91dHB1dFRleHR1cmUgIT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZShwcm9ncmFtLm91dHB1dFRleHR1cmUpO1xuICAgIHByb2dyYW0ub3V0cHV0VGV4dHVyZSA9IG91dHB1dFRleHR1cmU7XG5cbiAgICBpZiAocHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5vdXRwdXQubmFtZSlcbiAgICAgIHRoaXMub3V0cHV0VGV4dHVyZXNbcHJvZ3JhbS5vdXRwdXQubmFtZV0gPSBvdXRwdXRUZXh0dXJlO1xuICB9XG5cbiAgX3NldFVuaWZvcm0odHlwZSwgbG9jYXRpb24sIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdpbnQnOiB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGNhc2UgJ2Zsb2F0JzogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB0aGlzLmdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKSA6IHRoaXMuZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgY2FzZSAndmVjMic6IHRoaXMuZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGNhc2UgJ3ZlYzMnOiB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICBjYXNlICd2ZWM0JzogdGhpcy5nbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgY2FzZSAnbWF0Myc6IHRoaXMuZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biB1bmlmb3JtIHR5cGUgJHt0eXBlfS5gKTtcbiAgICB9XG4gIH1cblxuICBfbmV3QnVmZmVyKGRhdGEsIGtsYXNzLCB0YXJnZXQpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKCh0YXJnZXQgfHwgdGhpcy5nbC5BUlJBWV9CVUZGRVIpLCBidWYpO1xuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSgodGFyZ2V0IHx8IHRoaXMuZ2wuQVJSQVlfQlVGRkVSKSwgbmV3IChrbGFzcyB8fCBGbG9hdDMyQXJyYXkpKGRhdGEpLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBfY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgbGV0IGludGVybmFsRm9ybWF0LCBmb3JtYXQ7XG5cbiAgICBzd2l0Y2ggKGNoYW5uZWxzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SMzJGO1xuICAgICAgICBmb3JtYXQgPSB0aGlzLmdsLlJFRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SRzMyRjtcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5nbC5SRztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SR0IzMkY7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZ2wuUkdCO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLmdsLlJHQkEzMkY7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZ2wuUkdCQTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyhcIlRleHR1cmUgY2hhbm5lbHMgbXVzdCBiZXR3ZWVuIDEgYW5kIDQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzNEJyA/IHRoaXMuZ2wuVEVYVFVSRV8zRCA6IG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzJEQXJyYXknID8gdGhpcy5nbC5URVhUVVJFXzJEX0FSUkFZIDogdGhpcy5nbC5URVhUVVJFXzJEO1xuXG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9SLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBvcHRpb25zLmZpbHRlciA9PSAnbGluZWFyJyA/IHRoaXMuZ2wuTElORUFSIDogdGhpcy5nbC5ORUFSRVNUKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgb3B0aW9ucy5maWx0ZXIgPT0gJ2xpbmVhcicgPyB0aGlzLmdsLkxJTkVBUiA6IHRoaXMuZ2wuTkVBUkVTVCk7XG5cbiAgICBpZiAob3B0aW9ucy50ZXh0dXJlVHlwZSA9PSAnM0QnIHx8IG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzJEQXJyYXknKSB7XG4gICAgICB0aGlzLmdsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucy5kZXB0aCwgMCwgZm9ybWF0LCB0aGlzLmdsLkZMT0FULCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdGhpcy5nbC5GTE9BVCwgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0YXJnZXQsIG51bGwpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return DynamicObstacle; });\\n// Half width and half height\\nconst VEHICLE_SIZE = { w: 2.5, h: 1 };\\nconst CYCLIST_SIZE = { w: 1.2, h: 0.6 };\\nconst PEDESTRIAN_SIZE = { w: 0.6, h: 0.6 };\\n\\nclass DynamicObstacle {\\n  static hydrate(obj) {\\n    Object.setPrototypeOf(obj, DynamicObstacle.prototype);\\n    Object.setPrototypeOf(obj.startPos, THREE.Vector2.prototype);\\n    Object.setPrototypeOf(obj.velocity, THREE.Vector2.prototype);\\n  }\\n\\n  constructor(type, startPos, velocity, parallel) {\\n    this.type = type;\\n    this.startPos = startPos;\\n    this.velocity = velocity;\\n    this.parallel = parallel;\\n\\n    switch (type) {\\n        case 'cyclist':\\n          this.size = Object.assign({}, CYCLIST_SIZE);\\n          break;\\n\\n        case 'pedestrian':\\n          this.size = Object.assign({}, PEDESTRIAN_SIZE);\\n          break;\\n\\n        default:\\n          this.size = Object.assign({}, VEHICLE_SIZE);\\n    }\\n\\n    if (!parallel)\\n      [this.size.w, this.size.h] = [this.size.h, this.size.w];\\n  }\\n\\n  positionAtTime(time) {\\n    return this.velocity.clone().multiplyScalar(time).add(this.startPos);\\n  }\\n\\n  positionsInTimeRange(startTime, endTime, numFrames) {\\n    const dt = (endTime - startTime) / numFrames;\\n    const positions = [];\\n    let time = startTime;\\n\\n    for (let i = 0; i <= numFrames; i++) {\\n      positions.push(this.positionAtTime(time));\\n      time += dt;\\n    }\\n\\n    return positions;\\n  }\\n\\n  verticesInTimeRange(startTime, endTime, config) {\\n    const positions = this.positionsInTimeRange(startTime, endTime, config.numDynamicSubframes);\\n    const vertices = [];\\n\\n    // Hazard dilation (drawn behind, z = 0.75)\\n    const hazardHalfWidth = this.size.w + config.dynamicHazardDilationS + config.collisionDilationS;\\n    const hazardHalfHeight = this.size.h + config.dynamicHazardDilationL + config.collisionDilationL;\\n\\n    positions.forEach(p => {\\n      const v1 = [-hazardHalfWidth + p.x, hazardHalfHeight + p.y];\\n      const v2 = [hazardHalfWidth + p.x, hazardHalfHeight + p.y];\\n      const v3 = [hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\\n      const v4 = [-hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\\n\\n      vertices.push(\\n        v1[0], v1[1], 0.75,\\n        v2[0], v2[1], 0.75,\\n        v3[0], v3[1], 0.75,\\n        v3[0], v3[1], 0.75,\\n        v4[0], v4[1], 0.75,\\n        v1[0], v1[1], 0.75\\n      );\\n    });\\n    \\n    // Collision dilation (drawn in front, z = 0.25)\\n    const collisionHalfWidth = this.size.w + config.collisionDilationS;\\n    const collisionHalfHeight = this.size.h + config.collisionDilationL;\\n\\n    positions.forEach(p => {\\n      const v1 = [-collisionHalfWidth + p.x, collisionHalfHeight + p.y];\\n      const v2 = [collisionHalfWidth + p.x, collisionHalfHeight + p.y];\\n      const v3 = [collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\\n      const v4 = [-collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\\n\\n      vertices.push(\\n        v1[0], v1[1], 0.25,\\n        v2[0], v2[1], 0.25,\\n        v3[0], v3[1], 0.25,\\n        v3[0], v3[1], 0.25,\\n        v4[0], v4[1], 0.25,\\n        v1[0], v1[1], 0.25\\n      );\\n    });\\n\\n    return vertices;\\n  }\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9EeW5hbWljT2JzdGFjbGUuanM/MmU3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7O0FBRVY7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSGFsZiB3aWR0aCBhbmQgaGFsZiBoZWlnaHRcbmNvbnN0IFZFSElDTEVfU0laRSA9IHsgdzogMi41LCBoOiAxIH07XG5jb25zdCBDWUNMSVNUX1NJWkUgPSB7IHc6IDEuMiwgaDogMC42IH07XG5jb25zdCBQRURFU1RSSUFOX1NJWkUgPSB7IHc6IDAuNiwgaDogMC42IH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNPYnN0YWNsZSB7XG4gIHN0YXRpYyBoeWRyYXRlKG9iaikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmosIER5bmFtaWNPYnN0YWNsZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmouc3RhcnRQb3MsIFRIUkVFLlZlY3RvcjIucHJvdG90eXBlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLnZlbG9jaXR5LCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih0eXBlLCBzdGFydFBvcywgdmVsb2NpdHksIHBhcmFsbGVsKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0YXJ0UG9zID0gc3RhcnRQb3M7XG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIHRoaXMucGFyYWxsZWwgPSBwYXJhbGxlbDtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjeWNsaXN0JzpcbiAgICAgICAgICB0aGlzLnNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBDWUNMSVNUX1NJWkUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BlZGVzdHJpYW4nOlxuICAgICAgICAgIHRoaXMuc2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIFBFREVTVFJJQU5fU0laRSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBWRUhJQ0xFX1NJWkUpO1xuICAgIH1cblxuICAgIGlmICghcGFyYWxsZWwpXG4gICAgICBbdGhpcy5zaXplLncsIHRoaXMuc2l6ZS5oXSA9IFt0aGlzLnNpemUuaCwgdGhpcy5zaXplLnddO1xuICB9XG5cbiAgcG9zaXRpb25BdFRpbWUodGltZSkge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGltZSkuYWRkKHRoaXMuc3RhcnRQb3MpO1xuICB9XG5cbiAgcG9zaXRpb25zSW5UaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBudW1GcmFtZXMpIHtcbiAgICBjb25zdCBkdCA9IChlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIG51bUZyYW1lcztcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgdGltZSA9IHN0YXJ0VGltZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bUZyYW1lczsgaSsrKSB7XG4gICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvc2l0aW9uQXRUaW1lKHRpbWUpKTtcbiAgICAgIHRpbWUgKz0gZHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIHZlcnRpY2VzSW5UaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBjb25maWcpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9uc0luVGltZVJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSwgY29uZmlnLm51bUR5bmFtaWNTdWJmcmFtZXMpO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG5cbiAgICAvLyBIYXphcmQgZGlsYXRpb24gKGRyYXduIGJlaGluZCwgeiA9IDAuNzUpXG4gICAgY29uc3QgaGF6YXJkSGFsZldpZHRoID0gdGhpcy5zaXplLncgKyBjb25maWcuZHluYW1pY0hhemFyZERpbGF0aW9uUyArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblM7XG4gICAgY29uc3QgaGF6YXJkSGFsZkhlaWdodCA9IHRoaXMuc2l6ZS5oICsgY29uZmlnLmR5bmFtaWNIYXphcmREaWxhdGlvbkwgKyBjb25maWcuY29sbGlzaW9uRGlsYXRpb25MO1xuXG4gICAgcG9zaXRpb25zLmZvckVhY2gocCA9PiB7XG4gICAgICBjb25zdCB2MSA9IFstaGF6YXJkSGFsZldpZHRoICsgcC54LCBoYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcbiAgICAgIGNvbnN0IHYyID0gW2hhemFyZEhhbGZXaWR0aCArIHAueCwgaGF6YXJkSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2MyA9IFtoYXphcmRIYWxmV2lkdGggKyBwLngsIC1oYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcbiAgICAgIGNvbnN0IHY0ID0gWy1oYXphcmRIYWxmV2lkdGggKyBwLngsIC1oYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcblxuICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgdjFbMF0sIHYxWzFdLCAwLjc1LFxuICAgICAgICB2MlswXSwgdjJbMV0sIDAuNzUsXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC43NSxcbiAgICAgICAgdjNbMF0sIHYzWzFdLCAwLjc1LFxuICAgICAgICB2NFswXSwgdjRbMV0sIDAuNzUsXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC43NVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBDb2xsaXNpb24gZGlsYXRpb24gKGRyYXduIGluIGZyb250LCB6ID0gMC4yNSlcbiAgICBjb25zdCBjb2xsaXNpb25IYWxmV2lkdGggPSB0aGlzLnNpemUudyArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblM7XG4gICAgY29uc3QgY29sbGlzaW9uSGFsZkhlaWdodCA9IHRoaXMuc2l6ZS5oICsgY29uZmlnLmNvbGxpc2lvbkRpbGF0aW9uTDtcblxuICAgIHBvc2l0aW9ucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgY29uc3QgdjEgPSBbLWNvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2MiA9IFtjb2xsaXNpb25IYWxmV2lkdGggKyBwLngsIGNvbGxpc2lvbkhhbGZIZWlnaHQgKyBwLnldO1xuICAgICAgY29uc3QgdjMgPSBbY29sbGlzaW9uSGFsZldpZHRoICsgcC54LCAtY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2NCA9IFstY29sbGlzaW9uSGFsZldpZHRoICsgcC54LCAtY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XG5cbiAgICAgIHZlcnRpY2VzLnB1c2goXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC4yNSxcbiAgICAgICAgdjJbMF0sIHYyWzFdLCAwLjI1LFxuICAgICAgICB2M1swXSwgdjNbMV0sIDAuMjUsXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC4yNSxcbiAgICAgICAgdjRbMF0sIHY0WzFdLCAwLjI1LFxuICAgICAgICB2MVswXSwgdjFbMV0sIDAuMjVcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmVydGljZXM7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///5\\n\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"\\n// EXPORTS\\n__webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return /* binding */ PathPlanner_PathPlanner; });\\n\\n// EXTERNAL MODULE: ./js/GPGPU.js\\nvar GPGPU = __webpack_require__(4);\\n\\n// EXTERNAL MODULE: ./js/physics/Car.js\\nvar Car = __webpack_require__(0);\\n\\n// EXTERNAL MODULE: ./js/autonomy/path-planning/CubicPath.js\\nvar CubicPath = __webpack_require__(2);\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/QuinticPath.js\\nclass QuinticPath {\\n  constructor(start, end, params) {\\n    this.start = Object.assign({}, start);\\n    this.end = Object.assign({}, end);\\n\\n    if (start.pos) {\\n      this.start.x = start.pos.x;\\n      this.start.y = start.pos.y\\n    }\\n\\n    if (end.pos) {\\n      this.end.x = end.pos.x;\\n      this.end.y = end.pos.y\\n    }\\n\\n    const diffX = this.end.x - this.start.x;\\n    const diffY = this.end.y - this.start.y;\\n    const sinRot = Math.sin(this.start.rot);\\n    const cosRot = Math.cos(this.start.rot);\\n\\n    this.goal = {\\n      x: cosRot * diffX + sinRot * diffY,\\n      y: -sinRot * diffX + cosRot * diffY,\\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\\n      curv: this.end.curv\\n    };\\n\\n    this.params = Object.assign({}, params, { p0: this.start.curv, p1: this.start.dCurv || 0, p2: this.start.ddCurv || 0, p5: this.end.curv });\\n  }\\n\\n  buildPath(num) {\\n    const { p0, p1, p2, p3, p4, p5, sG } = this.params;\\n\\n    const sG_2 = sG * sG;\\n    const sG_3 = sG_2 * sG;\\n\\n    const a = p0;\\n    const b = p1;\\n    const c = p2 / 2.0;\\n    const d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    const e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    const f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\\n    const ds = sG / (num - 1);\\n    let s = ds;\\n    let dx = 0;\\n    let dy = 0;\\n    let prevCosRot = Math.cos(path[0].rot);\\n    let prevSinRot = Math.sin(path[0].rot);\\n\\n    for (let i = 1; i < num - 1; i++) {\\n      const rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + this.start.rot;\\n      const curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n      const cosRot = Math.cos(rot);\\n      const sinRot = Math.sin(rot);\\n\\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\\n\\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\\n\\n      s += ds;\\n      prevCosRot = cosRot;\\n      prevSinRot = sinRot;\\n    }\\n\\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\\n\\n    return path;\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js\\nconst OBSTACLE_VERTEX_SHADER = `#version 300 es\\nuniform mat3 xform;\\nin vec2 position;\\n\\nvoid main(void) {\\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\\n}\\n`;\\n\\nconst OBSTACLE_KERNEL = `\\n  vec4 kernel() {\\n    return vec4(1, 0, 0, 1);\\n  }\\n`;\\n\\nlet obstacleVertices;\\nlet obstacleXform;\\n\\n// Draw obstacle triangles to XY-space obstacle grid\\n/* harmony default export */ var xyObstacleGrid = ({\\n  setUp() {\\n    return {\\n      kernel: OBSTACLE_KERNEL,\\n      vertexShader: OBSTACLE_VERTEX_SHADER,\\n      output: { name: 'xyObstacleGrid' },\\n      draw: (gpgpu, program) => {\\n        const gl = gpgpu.gl;\\n\\n        gl.clearColor(0, 0, 0, 0);\\n        gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n        if (obstacleVertices.length > 0) {\\n          const buf = gl.createBuffer();\\n\\n          gl.bindBuffer(gl.ARRAY_BUFFER, buf);\\n          gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices, gl.STATIC_DRAW);\\n          gl.enableVertexAttribArray(program.positionLocation);\\n          gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);\\n\\n          const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\\n          gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\\n\\n          gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices.length / 2);\\n\\n          gl.deleteBuffer(buf);\\n        }\\n      }\\n    };\\n  },\\n\\n  update(config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles) {\\n    obstacleVertices = new Float32Array(Array.prototype.concat.apply([], obstacles.map(o => o.vertices)));\\n\\n    const translate = new THREE.Matrix3();\\n    translate.set(\\n      1, 0, -xyCenterPoint.x,\\n      0, 1, -xyCenterPoint.y,\\n      0, 0, 1\\n    );\\n\\n    const scale = new THREE.Matrix3();\\n    scale.set(\\n      2 / (xyWidth * config.xyGridCellSize), 0, 0,\\n      0, 2 / (xyHeight * config.xyGridCellSize), 0,\\n      0, 0, 1\\n    );\\n\\n    obstacleXform = scale.multiply(translate).multiply(vehicleXform);\\n\\n    return {\\n      width: xyWidth,\\n      height: xyHeight\\n    }\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js\\nconst SL_OBSTACLE_KERNEL = `\\n\\nvec4 kernel() {\\n  float centerlineWidth = float(textureSize(centerline, 0).x);\\n\\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\\n\\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\\n  float perpindicular = centerlineSample.z + radians(90.0);\\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\\n\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\\n  return texture(xyObstacleGrid, xyTexCoords);\\n}\\n\\n`;\\n\\n// Convert XY-space obstacle grid to SL-space obstacle grid\\n/* harmony default export */ var slObstacleGrid = ({\\n  setUp() {\\n    return {\\n      kernel: SL_OBSTACLE_KERNEL,\\n      output: { name: 'slObstacleGrid' },\\n      uniforms: {\\n        xyObstacleGrid: { type: 'outputTexture' },\\n        slGridCellSize: { type: 'float' },\\n        xyGridCellSize: { type: 'float' },\\n        slCenterPoint: { type: 'vec2' },\\n        xyCenterPoint: { type: 'vec2' },\\n        centerlineStationInterval: { type: 'float' },\\n        centerline: { type: 'sharedTexture' }\\n      }\\n    }\\n  },\\n\\n  update(config, slWidth, slHeight, slCenterPoint, xyCenterPoint) {\\n    return {\\n      width: slWidth,\\n      height: slHeight,\\n      uniforms: {\\n        slGridCellSize: config.slGridCellSize,\\n        xyGridCellSize: config.xyGridCellSize,\\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n        centerlineStationInterval: config.centerlineStationInterval\\n      }\\n    }\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js\\nconst SL_OBSTACLE_DILATION_KERNEL = `\\n\\n// TODO: test performance of returning early if non-zero pixel found\\nvec4 kernel() {\\n  float val = 0.0;\\n\\n  for (int d = 0; d <= collisionDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\\n  }\\n\\n  for (int d = collisionDilation + 1; d <= collisionDilation + hazardDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\\n  }\\n\\n  val = max(val, step(0.1, val) * 0.5);\\n\\n  return vec4(val, 0, 0, 1);\\n}\\n\\n`;\\n\\n/* harmony default export */ var slObstacleGridDilation = ({\\n  setUp() {\\n    return [\\n      { // SL-space obstacle grid S dilation\\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\\n        output: { name: 'slObstacleGridStationDilated' },\\n        uniforms: {\\n          slObstacleGrid: { type: 'outputTexture' },\\n          delta: { type: 'vec2' },\\n          collisionDilation: { type: 'int' },\\n          hazardDilation: { type: 'int' }\\n        }\\n      },\\n      { // SL-space obstacle grid L dilation\\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\\n        output: { name: 'slObstacleGridDilated' },\\n        uniforms: {\\n          slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridStationDilated' },\\n          delta: { type: 'vec2' },\\n          collisionDilation: { type: 'int' },\\n          hazardDilation: { type: 'int' }\\n        }\\n      }\\n    ];\\n  },\\n\\n  update(config, slWidth, slHeight) {\\n    return [\\n      { // SL-space obstacle grid S dilation\\n        width: slWidth,\\n        height: slHeight,\\n        uniforms: {\\n          delta: [1 / slWidth, 0],\\n          collisionDilation: Math.ceil(config.collisionDilationS / config.slGridCellSize),\\n          hazardDilation: Math.ceil(config.hazardDilationS / config.slGridCellSize)\\n        }\\n      },\\n      { // SL-space obstacle grid L dilation\\n        width: slWidth,\\n        height: slHeight,\\n        uniforms: {\\n          delta: [0, 1 / slHeight],\\n          collisionDilation: Math.ceil(config.collisionDilationL / config.slGridCellSize),\\n          hazardDilation: Math.ceil(config.hazardDilationL / config.slGridCellSize)\\n        }\\n      }\\n    ];\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js\\nconst DYNAMIC_OBSTACLE_VERTEX_SHADER = `#version 300 es\\nuniform mat3 xform;\\nin vec3 position;\\nout float color;\\n\\nvoid main(void) {\\n  gl_Position = vec4((xform * vec3(position.xy, 1)).xy, position.z, 1);\\n\\n  // The z coordinate is 0.25 for collision zone and 0.75 for hazard zone,\\n  // so that the collision zone is drawn on top.\\n  // Convert this to 1.0 for collision zone, 0.5 for hazard zone\\n  color = (1.0 - step(0.5, position.z)) * 0.5 + 0.5;\\n}\\n`;\\n\\nconst DYNAMIC_OBSTACLE_KERNEL = `\\n  in float color;\\n\\n  vec4 kernel() {\\n    return vec4(color, 0, 0, 1);\\n  }\\n`;\\n\\nlet slDynamicObstacleGrid_obstacleVertices;\\nlet slDynamicObstacleGrid_obstacleXform;\\nconst numDynamicFrames = 20;\\n\\n// Draw dynamic obstacle triangles to SL-space obstacle grid\\n/* harmony default export */ var slDynamicObstacleGrid = ({\\n  setUp() {\\n    return {\\n      kernel: DYNAMIC_OBSTACLE_KERNEL,\\n      vertexShader: DYNAMIC_OBSTACLE_VERTEX_SHADER,\\n      output: { name: 'slDynamicObstacleGrid', textureType: '2DArray', depth: numDynamicFrames },\\n      draw: (gpgpu, program) => {\\n        const gl = gpgpu.gl;\\n\\n        gl.enable(gl.DEPTH_TEST);\\n\\n        const renderbuffer = gl.createRenderbuffer();\\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, program.inputWidth, program.inputHeight);\\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\\n\\n        for (let frame = 0; frame < numDynamicFrames; frame++) {\\n          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, program.outputTexture, 0, frame);\\n          const frameBufferStatus = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);\\n          if (!frameBufferStatus)\\n            throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\\n\\n          gl.clearColor(0, 0, 0, 0);\\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\n\\n          if (slDynamicObstacleGrid_obstacleVertices[frame].length > 0) {\\n            const buf = gl.createBuffer();\\n\\n            gl.bindBuffer(gl.ARRAY_BUFFER, buf);\\n            gl.bufferData(gl.ARRAY_BUFFER, slDynamicObstacleGrid_obstacleVertices[frame], gl.STATIC_DRAW);\\n            gl.enableVertexAttribArray(program.positionLocation);\\n            gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 0, 0);\\n\\n            const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\\n            gl.uniformMatrix3fv(xformLocation, false, slDynamicObstacleGrid_obstacleXform.elements);\\n\\n            gl.drawArrays(gl.TRIANGLES, 0, slDynamicObstacleGrid_obstacleVertices[frame].length / 3);\\n\\n            if (frame == 0) {\\n              const obstacleGrid = new Float32Array(program.inputWidth * program.inputHeight * 4);\\n              gl.readPixels(0, 0, program.inputWidth, program.inputHeight, gl.RGBA, gl.FLOAT, obstacleGrid);\\n              gpgpu._dynamicObstacleGrid = obstacleGrid;\\n            }\\n\\n            gl.deleteBuffer(buf);\\n          }\\n        }\\n\\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\\n        gl.deleteRenderbuffer(renderbuffer);\\n        gl.disable(gl.DEPTH_TEST);\\n      }\\n    };\\n  },\\n\\n  update(config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles) {\\n    slDynamicObstacleGrid_obstacleVertices = [];\\n\\n    let time = startTime;\\n    for (let frame = 0; frame < numDynamicFrames; frame++) {\\n      const vertices = Array.prototype.concat.apply([], dynamicObstacles.map(o => o.verticesInTimeRange(time, time + dynamicFrameTime, config)));\\n      slDynamicObstacleGrid_obstacleVertices.push(new Float32Array(vertices));\\n      time += dynamicFrameTime;\\n    }\\n\\n    const translate = new THREE.Matrix3();\\n    translate.set(\\n      1, 0, -slCenterPoint.x - vehicleStation,\\n      0, 1, -slCenterPoint.y,\\n      0, 0, 1\\n    );\\n\\n    const scale = new THREE.Matrix3();\\n    scale.set(\\n      2 / (slWidth * config.slGridCellSize), 0, 0,\\n      0, 2 / (slHeight * config.slGridCellSize), 0,\\n      0, 0, 1\\n    );\\n\\n    slDynamicObstacleGrid_obstacleXform = scale.multiply(translate);\\n\\n    return {\\n      width: slWidth,\\n      height: slHeight\\n    }\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyslMap.js\\nconst XYSL_MAP_KERNEL = `\\n\\nvec4 kernel() {\\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\\n\\n  int numSamples = textureSize(centerline, 0).x;\\n  int closest = 0;\\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\\n  for (int i = 1; i < numSamples; i++) {\\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\\n    if (dist < closestDist) {\\n      closestDist = dist;\\n      closest = i;\\n    }\\n  }\\n\\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\\n  vec2 prev, next;\\n  int prevIndex, nextIndex;\\n\\n  if (closest == 0) {\\n    prevIndex = 0;\\n    nextIndex = 1;\\n    prev = closestPos;\\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\\n  } else if (closest == numSamples - 1) {\\n    prevIndex = closest - 1;\\n    nextIndex = closest;\\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\\n    next = closestPos;\\n  } else {\\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\\n\\n    if (distance(before, xy) < distance(after, xy)) {\\n      prevIndex = closest - 1;\\n      nextIndex = closest;\\n      prev = before;\\n      next = closestPos;\\n    } else {\\n      prevIndex = closest;\\n      nextIndex = closest + 1;\\n      prev = closestPos;\\n      next = after;\\n    }\\n  }\\n\\n  float dist = distance(prev, next);\\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\\n\\n  return vec4(\\n    (float(prevIndex) + progress) * centerlineStationInterval,\\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\\n    0,\\n    0\\n  );\\n}\\n\\n`;\\n\\n// Build XY-SL map\\n/* harmony default export */ var xyslMap = ({\\n  setUp() {\\n    return {\\n      kernel: XYSL_MAP_KERNEL,\\n      output: { name: 'xyslMap', filter: 'linear' },\\n      uniforms: {\\n        centerline: { type: 'sharedTexture' },\\n        xyCenterPoint: { type: 'vec2' },\\n        xyGridCellSize: { type: 'float'},\\n        centerlineStationInterval: { type: 'float'}\\n      }\\n    };\\n  },\\n\\n  update(config, xyWidth, xyHeight, xyCenterPoint) {\\n    return {\\n      width: xyWidth,\\n      height: xyHeight,\\n      uniforms: {\\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n        xyGridCellSize: config.xyGridCellSize,\\n        centerlineStationInterval: config.centerlineStationInterval\\n      }\\n    };\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js\\n// Config:\\n// num stations\\n// num latitudes\\n// station connectivity\\n// latitude connectivity\\n//\\n// Shared:\\n// lattice\\n\\nconst OPTIMIZE_CUBIC_SHARED = `\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n`;\\n\\nconst OPTIMIZE_CUBIC_KERNEL = OPTIMIZE_CUBIC_SHARED + `\\n\\n// width: station * latitude index\\n// height: station_conn * lattice_conn\\n//\\n// lattice:\\n// width: latitudes\\n// height: stations\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int endStation = indexes.x / numLatitudes;\\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\\n\\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\\n\\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\\n    return vec4(0.0);\\n\\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\\n\\n  return optimize(start, end);\\n}\\n\\n`;\\n\\nconst OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL = OPTIMIZE_CUBIC_SHARED + `\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, indexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n`;\\n\\n/* harmony default export */ var optimizeCubicPaths = ({\\n  setUp() {\\n    return [\\n      { // Cubic paths between lattice nodes\\n        kernel: OPTIMIZE_CUBIC_KERNEL,\\n        output: { name: 'cubicPaths', read: true },\\n        uniforms: {\\n          lattice: { type: 'sharedTexture' },\\n          numStations: { type: 'int' },\\n          numLatitudes: { type: 'int' },\\n          stationConnectivity: { type: 'int' },\\n          latitudeConnectivity: { type: 'int' }\\n        }\\n      },\\n      { // Cubic paths from vehicle to lattice nodes\\n        kernel: OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL,\\n        output: { name: 'cubicPathsFromVehicle', read: true },\\n        uniforms: {\\n          lattice: { type: 'sharedTexture' },\\n          curvVehicle: { type: 'float' }\\n        }\\n      }\\n    ]\\n  },\\n\\n  update(config, pose) {\\n    return [\\n      { // Cubic paths between lattice nodes\\n        width: config.lattice.numStations * config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity * config.lattice.latitudeConnectivity,\\n        uniforms: {\\n          numStations: config.lattice.numStations,\\n          numLatitudes: config.lattice.numLatitudes,\\n          stationConnectivity: config.lattice.stationConnectivity,\\n          latitudeConnectivity: config.lattice.latitudeConnectivity,\\n        }\\n      },\\n      { // Cubic paths from vehicle to lattice nodes\\n        width: config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity,\\n        uniforms: {\\n          curvVehicle: pose.curv\\n        }\\n      }\\n    ];\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js\\nconst OPTIMIZE_KERNEL = `\\n\\nconst int NEWTON_ITERATIONS = 32;\\nconst int RELAXATION_ITERATIONS = 32;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = p1;\\n    float c = p2 / 2.0;\\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_2 = s * s;\\n    float s_sG = s / sG;\\n    float s_sG_2 = s_sG * s_sG;\\n    float s_sG_3 = s_sG_2 * s_sG;\\n    float s_sG_4 = s_sG_3 * s_sG;\\n    float s_sG_5 = s_sG_4 * s_sG;\\n\\n    dT_p = vec3(\\n      // p3\\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\\n\\n      // p4\\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\\n\\n      // sG\\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p3, p4, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p3, p4, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float p4 = 0.0;\\n  float p5 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += d_K0;\\n    p1 += d_dK0;\\n    p2 += d_ddK0;\\n    p5 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p3, p4, sG, 0.0);\\n}\\n\\nvec4 kernel() {\\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n`;\\n\\n// Quintic spiral path optimizer\\n//   * Start of paths is the vehicle pose\\n//     * x-pos, y-pos, and rotation aren't needed, since the lattice origin is the vehicle pose\\n//     * So assume position and rotation are 0\\n//   * Ends of paths are all latitudes within the first (stationConnectivity) stations\\n/* harmony default export */ var optimizeQuinticPaths = ({\\n  setUp() {\\n    return {\\n      kernel: OPTIMIZE_KERNEL,\\n      output: { name: 'quinticPathsFromVehicle', read: true },\\n      uniforms: {\\n        lattice: { type: 'sharedTexture' },\\n        curvVehicle: { type: 'float' },\\n        dCurvVehicle: { type: 'float' },\\n        ddCurvVehicle: { type: 'float' }\\n      }\\n    };\\n  },\\n\\n  update(config, pose) {\\n    return {\\n      width: config.lattice.numLatitudes,\\n      height: config.lattice.stationConnectivity,\\n      uniforms: {\\n        curvVehicle: pose.curv,\\n        dCurvVehicle: pose.dCurv,\\n        ddCurvVehicle: pose.ddCurv\\n      }\\n    };\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\\nconst SHARED_SHADER = `\\n\\nconst float smallV = 0.01;\\nvec4 pathSamples[128];\\nfloat pathSampleCurvRates[128];\\n\\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\\n  if (index <= 4) {\\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\\n    return accelerationProfiles[index];\\n  } else {\\n    float finalVelocity = finalVelocityProfiles[index - 5];\\n    if (distance < 0.001) return 0.0;\\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\\n  }\\n}\\n\\nvec2 xy2sl(vec4 xytk) {\\n  vec2 xy = xytk.xy + rearAxleToCenter * vec2(cos(xytk.z), sin(xytk.z));\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\\n  return texture(xyslMap, xyTexCoords).xy;\\n}\\n\\nfloat sampleStaticCost(vec4 xytk) {\\n  vec2 sl = xy2sl(xytk);\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\\n\\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\\n\\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\\n\\n  float absLatitude = abs(sl.y);\\n  if (absLatitude >= laneShoulderLatitude) return -1.0;\\n\\n  float laneCost = abs(absLatitude - laneCenterLatitude) * laneCostSlope + step(0.0, -sl.y * sign(lanePreference)) * lanePreferenceDiscount;\\n\\n  return obstacleCost + laneCost;\\n}\\n\\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\\n  vec2 sl = xy2sl(xytk);\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slDynamicObstacleGrid, 0).xy) / vec2(slGridCellSize) + 0.5;\\n  float dynamicFrame = floor(time / dynamicFrameTime);\\n\\n  float obstacleCost = texture(slDynamicObstacleGrid, vec3(slTexCoords, dynamicFrame)).r;\\n\\n  if (obstacleCost > 0.75) return -1.0; // Infinite cost\\n\\n  return step(0.25, obstacleCost) * obstacleHazardCost;\\n}\\n\\nfloat calculateAverageStaticCost(int numSamples) {\\n  float averageStaticCost = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    float cost = sampleStaticCost(pathSamples[i]);\\n\\n    if (cost < 0.0) return cost;\\n\\n    averageStaticCost += cost;\\n  }\\n\\n  averageStaticCost /= float(numSamples);\\n\\n  return averageStaticCost;\\n}\\n\\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialTime, float initialVelocity, float acceleration, float abandonThreshold) {\\n  float s = 0.0;\\n  float ds = pathLength / float(numSamples - 1);\\n  float averageDynamicCost = 0.0;\\n  float maxVelocity = 0.0;\\n  float maxLateralAcceleration = 0.0;\\n  float numSamples_f = float(numSamples);\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\\n\\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\\n    maxVelocity = max(maxVelocity, velocity);\\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\\n\\n    float time = 2.0 * s / (initialVelocity + velocity) + initialTime;\\n\\n    float dCurv = pathSampleCurvRates[i] * velocity;\\n    if (dCurv > dCurvatureMax) return -1.0;\\n\\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\\n    if (cost < 0.0) return cost;\\n\\n    averageDynamicCost += cost;\\n    if (averageDynamicCost / numSamples_f >= abandonThreshold) return -1.0;\\n\\n    s += ds;\\n  }\\n\\n  averageDynamicCost /= numSamples_f;\\n\\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\\n\\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\\n\\n  // Penalize lateral acceleration\\n  averageDynamicCost += step(softLateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\\n\\n  return averageDynamicCost;\\n}\\n\\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\\n  float initialVelocitySq = initialVelocity * initialVelocity;\\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\\n\\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\\n\\n  float finalTime = initialTime;\\n\\n  if (acceleration == 0.0) {\\n    finalTime += pathLength / finalVelocity;\\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\\n  } else {\\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\\n  }\\n\\n  return vec3(acceleration, finalVelocity, finalTime);\\n}\\n\\n`;\\n\\nconst SAMPLE_CUBIC_PATH_FN = `\\n\\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\\n  float p0 = start.w;\\n  float p1 = cubicPathParams.x;\\n  float p2 = cubicPathParams.y;\\n  float p3 = end.w;\\n  float sG = cubicPathParams.z;\\n\\n  if (sG <= 0.0) return 0;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((d * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n`;\\n\\nconst SAMPLE_QUINTIC_PATH_FN = `\\n\\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\\n  float p0 = start.w;\\n  float p1 = dCurvVehicle;\\n  float p2 = ddCurvVehicle;\\n  float p3 = quinticPathParams.x;\\n  float p4 = quinticPathParams.y;\\n  float p5 = end.w;\\n  float sG = quinticPathParams.z;\\n\\n  if (sG <= 0.0) return 0;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = p1;\\n  float c = p2 / 2.0;\\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n`;\\n\\nconst NUM_ACCELERATION_PROFILES = 8;\\nconst NUM_VELOCITY_RANGES = 4;\\nconst NUM_TIME_RANGES = 2;\\n\\nconst SHARED_UNIFORMS = {\\n  xyslMap: { type: 'outputTexture' },\\n  slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\\n  slDynamicObstacleGrid: { type: 'outputTexture', name: 'slDynamicObstacleGrid', textureType: '2DArray' },\\n  accelerationProfiles: { type: 'float', length: 5 },\\n  finalVelocityProfiles: { type: 'float', length: 3 },\\n  xyCenterPoint: { type: 'vec2' },\\n  xyGridCellSize: { type: 'float' },\\n  slCenterPoint: { type: 'vec2' },\\n  slGridCellSize: { type: 'float'},\\n  laneCenterLatitude: { type: 'float'},\\n  laneShoulderLatitude: { type: 'float'},\\n  laneCostSlope: { type: 'float'},\\n  lanePreference: { type: 'float' },\\n  lanePreferenceDiscount: { type: 'float' },\\n  obstacleHazardCost: { type: 'float' },\\n  speedLimit: { type: 'float' },\\n  speedLimitPenalty: { type: 'float' },\\n  hardAccelerationPenalty: { type: 'float' },\\n  hardDecelerationPenalty: { type: 'float' },\\n  softLateralAccelerationLimit: { type: 'float' },\\n  softLateralAccelerationPenalty: { type: 'float' },\\n  linearLateralAccelerationPenalty: { type: 'float' },\\n  dCurvatureMax: { type: 'float' },\\n  pathSamplingStep: { type: 'float' },\\n  rearAxleToCenter: { type: 'float' },\\n  dynamicFrameTime: { type: 'float' }\\n};\\n\\nfunction buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime) {\\n  return {\\n    accelerationProfiles: [3.5, -6.5, 2.0, -3.0, 0],\\n    finalVelocityProfiles: [0.999 * config.speedLimit, 1.0, 0.01],\\n    xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n    xyGridCellSize: config.xyGridCellSize,\\n    slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\\n    slGridCellSize: config.slGridCellSize,\\n    laneCenterLatitude: config.laneCenterLatitude,\\n    laneShoulderLatitude: config.laneShoulderLatitude,\\n    laneCostSlope: config.laneCostSlope,\\n    lanePreference: config.lanePreference,\\n    lanePreferenceDiscount: config.lanePreferenceDiscount,\\n    obstacleHazardCost: config.obstacleHazardCost,\\n    speedLimit: config.speedLimit,\\n    speedLimitPenalty: config.speedLimitPenalty,\\n    hardAccelerationPenalty: config.hardAccelerationPenalty,\\n    hardDecelerationPenalty: config.hardDecelerationPenalty,\\n    softLateralAccelerationLimit: config.softLateralAccelerationLimit,\\n    softLateralAccelerationPenalty: config.softLateralAccelerationPenalty,\\n    linearLateralAccelerationPenalty: config.linearLateralAccelerationPenalty,\\n    dCurvatureMax: config.dCurvatureMax,\\n    pathSamplingStep: config.pathSamplingStep,\\n    rearAxleToCenter: config.rearAxleToCenter,\\n    dynamicFrameTime: dynamicFrameTime\\n  };\\n}\\n\\n\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js\\n\\n\\nfunction fromVehiclePathCostsKernel(pathType) {\\n  return SHARED_SHADER + (pathType == 'cubic' ? SAMPLE_CUBIC_PATH_FN : SAMPLE_QUINTIC_PATH_FN) +\\n\\n`\\n\\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\\n *   width: numLatitudes\\n *   height: station * numAccelerations\\n */\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.x;\\n  int station = indexes.y / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\\n\\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\\n\\n  // If the path didn't converge\\n  if (pathParams.w == 0.0) return vec4(-1);\\n\\n  int numSamples = ${pathType == 'cubic' ? 'sampleCubicPath' : 'sampleQuinticPath'}(pathStart, pathEnd, pathParams);\\n  float pathLength = pathParams.z;\\n\\n  if (numSamples < 2) return vec4(-1);\\n\\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\\n  if (averageStaticCost < 0.0) return vec4(-1);\\n\\n  int slIndex = station * kernelSize.x + latitude;\\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\\n  averageStaticCost += hysteresisAdjustment;\\n\\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\\n  float acceleration = avt.x;\\n  float finalVelocity = avt.y;\\n  float finalTime = avt.z;\\n\\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, 0.0, velocityVehicle, acceleration, 1.0 / 0.0);\\n  if (averageDynamicCost < 0.0) return vec4(-1);\\n\\n  averageDynamicCost += accelerationChangePenalty;\\n\\n  // The cost of a trajectory is the average sample cost scaled by the path length\\n  float totalCost = (averageStaticCost + averageDynamicCost + ${pathType == 'cubic' ? '(cubicPathPenalty * velocityVehicle * velocityVehicle)' : '0.0'}) * pathLength;\\n  ${pathType != 'cubic' ? 'totalCost = -1.0;' : ''}\\n\\n  return vec4(totalCost, finalVelocity, finalTime, ${pathType == 'cubic' ? '-2' : '-1'});\\n}\\n\\n`;\\n}\\n\\n/* harmony default export */ var pathFromVehicleCosts = ({\\n  setUp() {\\n    return [\\n      {\\n        kernel: fromVehiclePathCostsKernel('cubic'),\\n        output: { name: 'cubicPathFromVehicleCosts' },\\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\\n          lattice: { type: 'sharedTexture' },\\n          pathsFromVehicle: { type: 'outputTexture', name: 'cubicPathsFromVehicle' },\\n          firstLatticePoint: { type: 'int' },\\n          secondLatticePoint: { type: 'int' },\\n          velocityVehicle: { type: 'float' },\\n          curvVehicle: { type: 'float' },\\n          numAccelerations: { type: 'int' },\\n          cubicPathPenalty: { type: 'float' },\\n          hysteresisDiscount: { type: 'float' },\\n          accelerationChangePenalty: { type: 'float' }\\n        })\\n      },\\n      {\\n        kernel: fromVehiclePathCostsKernel('quintic'),\\n        output: { name: 'quinticPathFromVehicleCosts' },\\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\\n          lattice: { type: 'sharedTexture' },\\n          pathsFromVehicle: { type: 'outputTexture', name: 'quinticPathsFromVehicle' },\\n          firstLatticePoint: { type: 'int' },\\n          secondLatticePoint: { type: 'int' },\\n          velocityVehicle: { type: 'float' },\\n          curvVehicle: { type: 'float' },\\n          dCurvVehicle: { type: 'float' },\\n          ddCurvVehicle: { type: 'float' },\\n          numAccelerations: { type: 'int' },\\n          hysteresisDiscount: { type: 'float' },\\n          accelerationChangePenalty: { type: 'float' }\\n        })\\n      }\\n    ];\\n  },\\n\\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\\n    return [\\n      {\\n        width: config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\\n          firstLatticePoint: firstLatticePoint,\\n          secondLatticePoint: secondLatticePoint,\\n          velocityVehicle: pose.velocity,\\n          curvVehicle: pose.curv,\\n          numAccelerations: NUM_ACCELERATION_PROFILES,\\n          cubicPathPenalty: config.cubicPathPenalty,\\n          hysteresisDiscount: config.hysteresisDiscount,\\n          accelerationChangePenalty: config.accelerationChangePenalty\\n        })\\n      },\\n      {\\n        width: config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\\n          firstLatticePoint: firstLatticePoint,\\n          secondLatticePoint: secondLatticePoint,\\n          velocityVehicle: pose.velocity,\\n          curvVehicle: pose.curv,\\n          dCurvVehicle: pose.dCurv,\\n          ddCurvVehicle: pose.ddCurv,\\n          numAccelerations: NUM_ACCELERATION_PROFILES,\\n          hysteresisDiscount: config.hysteresisDiscount,\\n          accelerationChangePenalty: config.accelerationChangePenalty\\n        })\\n      }\\n    ];\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/graphSearch.js\\n/* State Lattice Cost Map\\n * \\n * 5-dimensional node: station, latitude, acceleration profile, velocity, time\\n *\\n * A draw call per station s\\n *   * Input to kernel: latitude l, acceleration profile a, velocity range v, time range t\\n *   * Find all SL vertices that can connect to this node\\n *   * For each of those vertices, check if any terminate in this specific velocity and time range\\n *     * Based on initial velocity, initial time, and acceleration\\n *     * Each connected SL vertex should have a * v * t nodes that could possibly terminate at this node\\n *   * For all valid edges, find the one with the lowest cost\\n *\\n * Input:\\n *   * 2D texture array cost map\\n *     * Height: num of latitudes (~20)\\n *     * Width: num of acceleration profiles * num of time ranges * num of velocity ranges (8 * 2 * 4 = ~64)\\n *       * A flattened 3D array:\\n *         d1: acceleration\\n *         d2: velocity\\n *         d3: time\\n *     * Layer: num of stations (~10)\\n *   \\n * Output:\\n *   * 2D texture slice of the next station in the input 2D texture array cost map\\n *\\n * Cost Map Elements:\\n *   * Traversal cost so far\\n *   * Ending velocity\\n *   * Ending time\\n *   * Index of parent node\\n *\\n * Since one cubic path can be shared between multiple trajectories, they need to be pre-optimized.\\n *\\n * Quintic Paths:\\n *   Stations 0 through (numStations - 1) correspond to the stations on the lattice; however,\\n *   a new station (station -1) will be used to signifiy the single vehicle pose node. Either\\n *   a cubic path or quintic path can be used to connect this single node to the lattice\\n *   (depending on vehicle velocity). At station -1, latitude 0 will correspond to a cubic path,\\n *   and latitude 1 will correspond to a quintic path. All other latitudes will be skipped.\\n */\\n\\n\\n\\nconst SOLVE_STATION_KERNEL =\\n  SHARED_SHADER +\\n  SAMPLE_CUBIC_PATH_FN +\\n  SAMPLE_QUINTIC_PATH_FN +\\n\\n`\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.y;\\n\\n  int numPerTime = numAccelerations * numVelocities;\\n  int timeIndex = indexes.x / numPerTime;\\n  indexes.x -= timeIndex * numPerTime;\\n  int velocityIndex = indexes.x / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\\n\\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\\n\\n  int slIndex = station * numLatitudes + latitude;\\n\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  float minVelocity = velocityRanges[velocityIndex];\\n  float maxVelocity = velocityRanges[velocityIndex + 1];\\n\\n  float minTime = timeRanges[timeIndex];\\n  float maxTime = timeRanges[timeIndex + 1];\\n\\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\\n  float bestTerminalCost = 1.0 / 0.0;\\n\\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\\n\\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\\n\\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\\n\\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\\n\\n      // If the path didn't converge\\n      if (cubicPathParams.w == 0.0) continue;\\n\\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\\n      float pathLength = cubicPathParams.z;\\n\\n      if (numSamples < 2) continue;\\n\\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\\n      if (averageStaticCost < 0.0) continue;\\n\\n      averageStaticCost += hysteresisAdjustment;\\n\\n      if (averageStaticCost * pathLength >= bestTerminalCost) continue;\\n\\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\\n\\n            // Cost table entry:\\n            //   x: cost so far\\n            //   y: end velocity\\n            //   z: end time\\n            //   w: parent index\\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\\n\\n            // If cost entry is infinity\\n            if (costTableEntry.x < 0.0 || averageStaticCost * pathLength + costTableEntry.x >= bestTerminalCost) continue;\\n\\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\\n            float acceleration = avt.x;\\n            float finalVelocity = avt.y;\\n            float finalTime = avt.z;\\n\\n            if (averageStaticCost * pathLength + costTableEntry.x + extraTimePenalty * finalTime >= bestTerminalCost) continue;\\n\\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\\n\\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\\n            if (finalTime < minTime || finalTime >= maxTime) continue;\\n\\n            float abandonThreshold = (bestTerminalCost - extraTimePenalty * finalTime - costTableEntry.x) / pathLength - averageStaticCost;\\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.z, costTableEntry.y, acceleration, abandonThreshold);\\n            if (averageDynamicCost < 0.0) continue;\\n\\n            if (accelerationIndex != prevAccel)\\n              averageDynamicCost += accelerationChangePenalty;\\n\\n            // The cost of a trajectory is the average sample cost scaled by the path length\\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\\n\\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\\n            if (terminalCost >= bestTerminalCost) continue;\\n            bestTerminalCost = terminalCost;\\n\\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  if (station < stationConnectivity) {\\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\\n\\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\\n    float terminalCost;\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestTerminalCost) {\\n        bestTerminalCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n\\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestTerminalCost) {\\n        bestTerminalCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n  }\\n\\n  return bestTrajectory;\\n}\\n\\n`;\\n\\n/* harmony default export */ var graphSearch = ({\\n  setUp() {\\n    return {\\n      kernel: SOLVE_STATION_KERNEL,\\n      output: { name: 'graphSearch' },\\n      uniforms: Object.assign({}, SHARED_UNIFORMS, {\\n        lattice: { type: 'sharedTexture' },\\n        costTable: { type: 'sharedTexture', textureType: '2DArray' },\\n        cubicPaths: { type: 'outputTexture' },\\n        cubicPathFromVehicleCosts: { type: 'outputTexture' },\\n        quinticPathFromVehicleCosts: { type: 'outputTexture' },\\n        firstLatticePoint: { type: 'int' },\\n        secondLatticePoint: { type: 'int' },\\n        velocityVehicle: { type: 'float' },\\n        curvVehicle: { type: 'float' },\\n        dCurvVehicle: { type: 'float' },\\n        ddCurvVehicle: { type: 'float' },\\n        extraTimePenalty: { type: 'float' },\\n        hysteresisDiscount: { type: 'float' },\\n        accelerationChangePenalty: { type: 'float' },\\n        numStations: { type: 'int' },\\n        numLatitudes: { type: 'int' },\\n        numAccelerations: { type: 'int' },\\n        numVelocities: { type: 'int' },\\n        numTimes: { type: 'int' },\\n        stationConnectivity: { type: 'int' },\\n        latitudeConnectivity: { type: 'int' },\\n        velocityRanges: { type: 'float', length: NUM_VELOCITY_RANGES + 1 },\\n        timeRanges: { type: 'float', length: NUM_TIME_RANGES + 1 },\\n        station: { type: 'int' } // Updated in `drawProxy`\\n      }),\\n      drawProxy: (gpgpu, program, draw) => {\\n        const width = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES;\\n        const height = program.meta.lattice.numLatitudes;\\n        const costTable = new Float32Array(width * height * program.meta.lattice.numStations * 4);\\n\\n        for (let s = 0; s < program.meta.lattice.numStations; s++) {\\n          gpgpu.updateProgramUniforms(program, { station: s });\\n          draw();\\n\\n          gpgpu.gl.readPixels(0, 0, width, height, gpgpu.gl.RGBA, gpgpu.gl.FLOAT, costTable, s * width * height * 4);\\n\\n          gpgpu.gl.bindTexture(gpgpu.gl.TEXTURE_2D_ARRAY, gpgpu.sharedTextures.costTable);\\n          gpgpu.gl.copyTexSubImage3D(gpgpu.gl.TEXTURE_2D_ARRAY, 0, 0, 0, s, 0, 0, width, height);\\n        }\\n\\n        gpgpu._graphSearchCostTable = costTable;\\n      }\\n    };\\n  },\\n\\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\\n    return {\\n      width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\\n      height: config.lattice.numLatitudes,\\n      meta: {\\n        lattice: config.lattice\\n      },\\n      uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\\n        firstLatticePoint: firstLatticePoint,\\n        secondLatticePoint: secondLatticePoint,\\n        velocityVehicle: pose.velocity,\\n        curvVehicle: pose.curv,\\n        dCurvVehicle: pose.dCurv,\\n        ddCurvVehicle: pose.ddCurv,\\n        extraTimePenalty: config.extraTimePenalty,\\n        hysteresisDiscount: config.hysteresisDiscount,\\n        accelerationChangePenalty: config.accelerationChangePenalty,\\n        numStations: config.lattice.numStations,\\n        numLatitudes: config.lattice.numLatitudes,\\n        numAccelerations: NUM_ACCELERATION_PROFILES,\\n        numVelocities: NUM_VELOCITY_RANGES,\\n        numTimes: NUM_TIME_RANGES,\\n        stationConnectivity: config.lattice.stationConnectivity,\\n        latitudeConnectivity: config.lattice.latitudeConnectivity,\\n        velocityRanges: [0, config.speedLimit / 3, config.speedLimit * 2 / 3, config.speedLimit, 1000000],\\n        timeRanges: [0, 10, 1000000]\\n      })\\n    };\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js\\nconst XY_OBSTACLE_COST_KERNEL = `\\n\\nvec4 kernel() {\\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\\n\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\\n\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\\n  return texture(slObstacleGrid, slTexCoords);\\n}\\n\\n`;\\n\\n// Build XY obstacle costs using XYSL map\\n/* harmony default export */ var xyObstacleCostGrid = ({\\n  setUp() {\\n    return {\\n      kernel: XY_OBSTACLE_COST_KERNEL,\\n      output: { name: 'xyObstacleCostGrid', read: true },\\n      uniforms: {\\n        xyslMap: { type: 'outputTexture' },\\n        slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\\n        xyCenterPoint: { type: 'vec2' },\\n        xyGridCellSize: { type: 'float'},\\n        slCenterPoint: { type: 'vec2' },\\n        slGridCellSize: { type: 'float'}\\n      }\\n    };\\n  },\\n\\n  update(config, xyWidth, xyHeight, xyCenterPoint, slCenterPoint) {\\n    return {\\n      width: xyWidth,\\n      height: xyHeight,\\n      uniforms: {\\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n        xyGridCellSize: config.xyGridCellSize,\\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\\n        slGridCellSize: config.slGridCellSize\\n      }\\n    };\\n  }\\n});\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/PathPlanner.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst PathPlanner_NUM_ACCELERATION_PROFILES = 8;\\nconst PathPlanner_NUM_VELOCITY_RANGES = 4;\\nconst PathPlanner_NUM_TIME_RANGES = 2;\\n\\n/* Obstacle cost map:\\n *\\n * 1. Rasterize triangles from polygonal obstacles into XY-space occupancy grid\\n * 2. Convert occupancy grid to SL-space\\n *    * Width is spatial horizon of the state lattice\\n *    * Height is lane width\\n *    * Resolution should be higher than XY-grid\\n *    * Get XY position from centerline texture\\n *    * Lookup XY in XY occupancy grid (nearest)\\n * 3. Dilate SL-space grid using two passes (along station, then along latitude)\\n *    * collision area: half car size + 0.3m\\n *    * high cost area: 1 meter\\n * 4. Convert back to XY-space using XYSL map\\n */\\n\\nclass PathPlanner_PathPlanner {\\n  constructor() {\\n    this.previousStartStation = null;\\n    this.previousFirstLatticePoint = -1;\\n    this.previousSecondLatticePoint = -1;\\n    this.previousFirstAcceleration = -1;\\n    this.previousSecondLatticePoint = -1;\\n\\n    let start = performance.now();\\n    const programs = [\\n      xyObstacleGrid.setUp(),\\n      slObstacleGrid.setUp(),\\n      ...slObstacleGridDilation.setUp(),\\n      slDynamicObstacleGrid.setUp(),\\n      xyslMap.setUp(),\\n      ...optimizeCubicPaths.setUp(),\\n      optimizeQuinticPaths.setUp(),\\n      ...pathFromVehicleCosts.setUp(),\\n      graphSearch.setUp(),\\n    ].map(p => Object.assign({}, p, { width: 1, height: 1 }));\\n\\n    this.gpgpu = new GPGPU[\\\"a\\\" /* default */](programs);\\n  }\\n\\n  reset() {\\n    this.previousStartStation = null;\\n    this.previousFirstLatticePoint = -1;\\n    this.previousSecondLatticePoint = -1;\\n    this.previousFirstAcceleration = -1;\\n    this.previousSecondLatticePoint = -1;\\n  }\\n\\n  plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles) {\\n    const latticeStationInterval = this._latticeStationInterval();\\n\\n    const centerlineRaw = lanePath.sampleStations(vehicleStation, Math.ceil((this.config.spatialHorizon + latticeStationInterval) / this.config.centerlineStationInterval) + 1, this.config.centerlineStationInterval);\\n\\n    // Transform all centerline points into vehicle frame\\n    const vehicleXform = vehicleTransform(vehiclePose);\\n    const centerline = centerlineRaw.map(c => { return { pos: c.pos.clone().applyMatrix3(vehicleXform), rot: c.rot - vehiclePose.rot, curv: c.curv } });\\n\\n    const centerlineData = new Float32Array(centerline.length * 3);\\n    const maxPoint = new THREE.Vector2(0, 0);\\n    const minPoint = new THREE.Vector2(0, 0);\\n\\n    for (let i = 0; i < centerline.length; i++) {\\n      const sample = centerline[i];\\n      const pos = sample.pos;\\n      centerlineData[i * 3 + 0] = pos.x;\\n      centerlineData[i * 3 + 1] = pos.y;\\n      centerlineData[i * 3 + 2] = sample.rot;\\n\\n      maxPoint.max(pos);\\n      minPoint.min(pos);\\n    }\\n\\n    const diff = maxPoint.clone().sub(minPoint);\\n    const xyCenterPoint = minPoint.clone().add(maxPoint).divideScalar(2);\\n\\n    // Sizes of the xy grids (in pixels, not meters)\\n    const xyWidth = Math.ceil((diff.x + this.config.gridMargin * 2) / this.config.xyGridCellSize);\\n    const xyHeight = Math.ceil((diff.y + this.config.gridMargin * 2) / this.config.xyGridCellSize);\\n\\n    const stationWidth = this.config.spatialHorizon + latticeStationInterval * 2;\\n    const slCenterPoint = new THREE.Vector2(this.config.spatialHorizon / 2, 0);\\n\\n    // Sizes of the sl grids (in pixels, not meters)\\n    const slWidth = Math.ceil(stationWidth / this.config.slGridCellSize);\\n    const slHeight = Math.ceil((this.config.roadWidth + this.config.gridMargin * 2) / this.config.slGridCellSize);\\n\\n    let startStation;\\n\\n    if (this.previousStartStation === null || vehicleStation + latticeStationInterval / 2 > this.previousStartStation) {\\n      startStation = (this.previousStartStation === null ? vehicleStation : this.previousStartStation) + latticeStationInterval;\\n      this.previousStartStation = startStation;\\n      this.previousFirstLatticePoint -= this.config.lattice.numLatitudes;\\n      this.previousSecondLatticePoint -= this.config.lattice.numLatitudes;\\n    } else {\\n      startStation = this.previousStartStation;\\n    }\\n\\n    const lattice = this._buildLattice(lanePath, startStation, vehiclePose.rot, vehicleXform);\\n\\n    const temporalHorizon = this.config.spatialHorizon / this.config.speedLimit;\\n    const dynamicFrameTime = temporalHorizon / this.config.numDynamicFrames;\\n\\n    for (const [i, p] of [\\n      xyObstacleGrid.update(this.config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, staticObstacles),\\n      slObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, xyCenterPoint),\\n      ...slObstacleGridDilation.update(this.config, slWidth, slHeight),\\n      slDynamicObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles),\\n      xyslMap.update(this.config, xyWidth, xyHeight, xyCenterPoint),\\n      ...optimizeCubicPaths.update(this.config, vehiclePose),\\n      optimizeQuinticPaths.update(this.config, vehiclePose),\\n      ...pathFromVehicleCosts.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime),\\n      graphSearch.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime)\\n    ].entries()) {\\n      this.gpgpu.updateProgram(i, p);\\n    }\\n\\n    this.gpgpu.updateSharedTextures({\\n      centerline: {\\n        width: centerline.length,\\n        height: 1,\\n        channels: 3,\\n        filter: 'linear',\\n        data: centerlineData\\n      },\\n      costTable: {\\n        width: PathPlanner_NUM_ACCELERATION_PROFILES * PathPlanner_NUM_VELOCITY_RANGES * PathPlanner_NUM_TIME_RANGES,\\n        height: this.config.lattice.numLatitudes,\\n        depth: this.config.lattice.numStations,\\n        channels: 4,\\n        textureType: '2DArray'\\n      },\\n      lattice: {\\n        width: this.config.lattice.numLatitudes,\\n        height: this.config.lattice.numStations,\\n        channels: 4,\\n        data: lattice\\n      }\\n    });\\n\\n    this.gpgpu._graphSearchCostTable = null;\\n    this.gpgpu._dynamicObstacleGrid = null;\\n\\n    let start = performance.now();\\n    const outputs = this.gpgpu.run();\\n    const costTable = this.gpgpu._graphSearchCostTable;\\n    const cubicPathParams = outputs[6];\\n    const cubicPathFromVehicleParams = outputs[7];\\n    const quinticPathFromVehicleParams = outputs[8];\\n\\n    let bestEntry = [Number.POSITIVE_INFINITY];\\n    let bestEntryIndex;\\n    const numEntries = costTable.length / 4;\\n\\n    for (let i = 0; i < numEntries; i++) {\\n      const entryUnpacked = this._unpackCostTableIndex(i);\\n      const entry = [\\n        costTable[i * 4],\\n        costTable[i * 4 + 1],\\n        costTable[i * 4 + 2],\\n        costTable[i * 4 + 3]\\n      ];\\n\\n      if (entry[0] < 0) continue;\\n\\n      entry[0] += this._terminalCost(entryUnpacked, entry);\\n\\n      if (entry[0] < bestEntry[0]) {\\n        bestEntryIndex = i;\\n        bestEntry = entry;\\n      }\\n    }\\n\\n    const inverseVehicleXform = (new THREE.Matrix3()).getInverse(vehicleXform);\\n    let bestTrajectory = null;\\n    let fromVehicleSegment = null;\\n    let fromVehicleParams = null;\\n    let firstLatticePoint = -1;\\n    let firstAcceleration = -1;\\n    let secondLatticePoint = -1;\\n    let secondAcceleration = -1;\\n\\n    if (isFinite(bestEntry[0])) {\\n      [bestTrajectory, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration] = this._reconstructTrajectory(\\n        bestEntryIndex,\\n        costTable,\\n        cubicPathParams,\\n        cubicPathFromVehicleParams,\\n        quinticPathFromVehicleParams,\\n        vehiclePose,\\n        lattice\\n      );\\n\\n      fromVehicleSegment.forEach(p => {\\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\\n        p.rot += vehiclePose.rot;\\n      });\\n\\n      bestTrajectory.forEach(p => {\\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\\n        p.rot += vehiclePose.rot;\\n      });\\n    }\\n\\n    this.previousFirstLatticePoint = firstLatticePoint;\\n    this.previousFirstAcceleration = firstAcceleration;\\n    this.previousSecondLatticePoint = secondLatticePoint;\\n    this.previousSecondAcceleration = secondAcceleration;\\n\\n    return {\\n      path: bestTrajectory,\\n      fromVehicleSegment: fromVehicleSegment,\\n      fromVehicleParams: fromVehicleParams,\\n      latticeStartStation: this.previousStartStation,\\n      dynamicObstacleGrid: { data: this.gpgpu._dynamicObstacleGrid, width: slWidth, height: slHeight }\\n    };\\n  }\\n\\n  _buildLattice(lanePath, startStation, vehicleRot, vehicleXform) {\\n    const centerline = lanePath.sampleStations(startStation, this.config.lattice.numStations, this._latticeStationInterval());\\n    const offset = Math.floor(this.config.lattice.numLatitudes / 2);\\n    const lattice = new Float32Array(this.config.lattice.numStations * this.config.lattice.numLatitudes * 4);\\n    let index = 0;\\n\\n    for (let s = 0; s < centerline.length; s++) {\\n      const sample = centerline[s];\\n\\n      for (let l = 0; l < this.config.lattice.numLatitudes; l++) {\\n        const latitude = (l - offset) / offset * this.config.roadWidth / 2;\\n        const rot = sample.rot - vehicleRot;\\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos.clone().applyMatrix3(vehicleXform));\\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\\n\\n        lattice[index++] = pos.x;\\n        lattice[index++] = pos.y;\\n        lattice[index++] = rot;\\n        lattice[index++] = curv;\\n      }\\n    }\\n\\n    return lattice;\\n  }\\n\\n  _latticeStationInterval() {\\n    return this.config.spatialHorizon / this.config.lattice.numStations;\\n  }\\n\\n  _terminalCost([stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex], [cost, finalVelocity, finalTime, incomingIndex]) {\\n    // Only consider vertices that reach the end of the spatial or temporal horizon\\n    if (stationIndex != this.config.lattice.numStations - 1 && finalVelocity > 0.05)\\n      return Number.POSITIVE_INFINITY;\\n\\n    const station = (this.config.spatialHorizon / this.config.lattice.numStations) * (stationIndex + 1);\\n\\n    return station * -this.config.stationReachDiscount + finalTime * this.config.extraTimePenalty;\\n  }\\n\\n  _unpackCostTableIndex(index) {\\n    if (index < 0) return [-1, index + 2, null, null, null];\\n\\n    const numPerTime = PathPlanner_NUM_ACCELERATION_PROFILES * PathPlanner_NUM_VELOCITY_RANGES;\\n    const numPerLatitude = numPerTime * PathPlanner_NUM_TIME_RANGES;\\n    const numPerStation = this.config.lattice.numLatitudes * numPerLatitude;\\n\\n    const stationIndex = Math.floor(index / numPerStation);\\n    index -= stationIndex * numPerStation;\\n\\n    const latitudeIndex = Math.floor(index / numPerLatitude);\\n    index -= latitudeIndex * numPerLatitude;\\n\\n    const timeIndex = Math.floor(index / numPerTime);\\n    index -= timeIndex * numPerTime;\\n\\n    const velocityIndex = Math.floor(index / PathPlanner_NUM_ACCELERATION_PROFILES);\\n    const accelerationIndex = index % PathPlanner_NUM_ACCELERATION_PROFILES;\\n\\n    return [stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex];\\n  }\\n\\n  _reconstructTrajectory(index, costTable, cubicPathParams, cubicPathFromVehicleParams, quinticPathFromVehicleParams, vehiclePose, lattice) {\\n    let unpacked = this._unpackCostTableIndex(index);\\n    unpacked.push(costTable[index * 4 + 1]);\\n    const nodes = [unpacked];\\n\\n    let count = 0;\\n    while (unpacked[0] >= 0 && count++ < 100) {\\n      index = costTable[index * 4 + 3];\\n      unpacked = this._unpackCostTableIndex(index);\\n\\n      const finalVelocity = unpacked[0] >= 0 ? costTable[index * 4 + 1] : vehiclePose.velocity;\\n      unpacked.push(finalVelocity);\\n\\n      nodes.unshift(unpacked);\\n    }\\n    if (count >= 100) throw new Error('Infinite loop encountered while reconstructing trajectory.');\\n\\n    const points = [];\\n    let fromVehicleSegment = [];\\n    let fromVehicleParams = null;\\n\\n    for (let i = 0; i < nodes.length - 1; i++) {\\n      const [prevStation, prevLatitude, _pt, _pv, _pa, prevVelocity] = nodes[i];\\n      const [station, latitude, _t, _v, _a, velocity] = nodes[i + 1];\\n\\n      let length;\\n      let pathBuilder;\\n\\n      if (prevStation < 0) {\\n        const start = {\\n          pos: new THREE.Vector2(0, 0),\\n          rot: 0,\\n          curv: vehiclePose.curv\\n        };\\n\\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\\n        const end = {\\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\\n          rot: lattice[endIndex + 2],\\n          curv: lattice[endIndex + 3]\\n        };\\n\\n        if (prevLatitude == 0) { // Cubic path from vehicle to lattice node\\n          length = cubicPathFromVehicleParams[endIndex + 2];\\n\\n          const params = {\\n            p1: cubicPathFromVehicleParams[endIndex],\\n            p2: cubicPathFromVehicleParams[endIndex + 1],\\n            sG: length\\n          };\\n\\n          pathBuilder = new CubicPath[\\\"a\\\" /* default */](start, end, params);\\n\\n          fromVehicleParams = { type: 'cubic', params: params };\\n        } else { // Quintic path from vehicle to lattice node\\n          length = quinticPathFromVehicleParams[endIndex + 2];\\n\\n          const params = {\\n            p3: quinticPathFromVehicleParams[endIndex],\\n            p4: quinticPathFromVehicleParams[endIndex + 1],\\n            sG: length\\n          };\\n\\n          pathBuilder = new QuinticPath(start, end, params);\\n\\n          fromVehicleParams = { type: 'quintic', params: params };\\n        }\\n      } else {\\n        const startIndex = (prevStation * this.config.lattice.numLatitudes + prevLatitude) * 4;\\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\\n\\n        const start = {\\n          pos: new THREE.Vector2(lattice[startIndex], lattice[startIndex + 1]),\\n          rot: lattice[startIndex + 2],\\n          curv: lattice[startIndex + 3]\\n        };\\n\\n        const end = {\\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\\n          rot: lattice[endIndex + 2],\\n          curv: lattice[endIndex + 3]\\n        };\\n\\n        const slIndex = station * this.config.lattice.numLatitudes + latitude;\\n        const connectivityIndex = (prevStation - station + this.config.lattice.stationConnectivity) * this.config.lattice.latitudeConnectivity + prevLatitude - latitude + Math.floor(this.config.lattice.latitudeConnectivity / 2);\\n        const cubicPathIndex = (connectivityIndex * this.config.lattice.numStations * this.config.lattice.numLatitudes + slIndex) * 4;\\n\\n        length = cubicPathParams[cubicPathIndex + 2];\\n\\n        pathBuilder = new CubicPath[\\\"a\\\" /* default */](start, end, {\\n          p1: cubicPathParams[cubicPathIndex],\\n          p2: cubicPathParams[cubicPathIndex + 1],\\n          sG: length\\n        });\\n      }\\n\\n      const path = pathBuilder.buildPath(Math.ceil(length / 0.25));\\n\\n      const prevVelocitySq = prevVelocity * prevVelocity;\\n      const accel = (velocity * velocity - prevVelocitySq) / 2 / length;\\n      const ds = length / (path.length - 1);\\n      let s = 0;\\n\\n      for (let p = 0; p < path.length; p++) {\\n        path[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\\n        path[p].acceleration = accel;\\n        s += ds;\\n      }\\n\\n      if (prevStation < 0) {\\n        fromVehicleSegment = path;\\n      } else {\\n        if (i > 0) path.shift();\\n        points.push(...path);\\n      }\\n    }\\n\\n    let firstLatticePoint = null\\n    let firstAcceleration = null;\\n    let secondLatticePoint = null;\\n    let secondAcceleration = null;\\n\\n    if (nodes.length >= 2) {\\n      firstLatticePoint = nodes[1][0] * this.config.lattice.numLatitudes + nodes[1][1];\\n      firstAcceleration = nodes[1][4];\\n    }\\n\\n    if (nodes.length >= 3) {\\n      secondLatticePoint = nodes[2][0] * this.config.lattice.numLatitudes + nodes[2][1];\\n      secondAcceleration = nodes[2][4];\\n    }\\n\\n    return [points, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration];\\n  }\\n}\\n\\nfunction vehicleTransform({ pos, rot }) {\\n  const translate = new THREE.Matrix3();\\n  translate.set(\\n    1, 0, -pos.x,\\n    0, 1, -pos.y,\\n    0, 0, 1\\n  );\\n\\n  const cosRot = Math.cos(rot);\\n  const sinRot = Math.sin(rot);\\n\\n  const rotate = new THREE.Matrix3();\\n  rotate.set(\\n    cosRot, sinRot, 0,\\n    -sinRot, cosRot, 0,\\n    0, 0, 1\\n  );\\n\\n  return rotate.multiply(translate);\\n}\\n\\nfunction obstacleTransform(vehicleXform, xyCenterPoint, width, height) {\\n  const translate = new THREE.Matrix3();\\n  translate.set(\\n    1, 0, -xyCenterPoint.x,\\n    0, 1, -xyCenterPoint.y,\\n    0, 0, 1\\n  );\\n\\n  const scale = new THREE.Matrix3();\\n  scale.set(\\n    2 / width, 0, 0,\\n    0, 2 / height, 0,\\n    0, 0, 1\\n  );\\n\\n  return scale.multiply(translate).multiply(vehicleXform);\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1F1aW50aWNQYXRoLmpzPzhjNjUiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlR3JpZC5qcz9kNzhjIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWQuanM/ZTU0YiIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkRGlsYXRpb24uanM/MTc0OSIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsRHluYW1pY09ic3RhY2xlR3JpZC5qcz82YzBlIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlzbE1hcC5qcz81YmE5Iiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvb3B0aW1pemVDdWJpY1BhdGhzLmpzPzE1M2QiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZVF1aW50aWNQYXRocy5qcz9jMDVkIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvZ3JhcGhTZWFyY2hTaGFyZWQuanM/MjA1MiIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3BhdGhGcm9tVmVoaWNsZUNvc3RzLmpzP2U1MGMiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9ncmFwaFNlYXJjaC5qcz80Yzg4Iiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlPYnN0YWNsZUNvc3RHcmlkLmpzP2M5NzQiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9QYXRoUGxhbm5lci5qcz9kMzI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWU7QUFDZjtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsV0FBVyxnR0FBZ0c7QUFDN0k7O0FBRUE7QUFDQSxXQUFXLDZCQUE2Qjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlHQUFpRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsNkZBQTZGOztBQUU5RztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHlGQUF5Rjs7QUFFeEc7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVpbnRpY1BhdGgge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBwYXJhbXMpIHtcbiAgICB0aGlzLnN0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhcnQpO1xuICAgIHRoaXMuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZW5kKTtcblxuICAgIGlmIChzdGFydC5wb3MpIHtcbiAgICAgIHRoaXMuc3RhcnQueCA9IHN0YXJ0LnBvcy54O1xuICAgICAgdGhpcy5zdGFydC55ID0gc3RhcnQucG9zLnlcbiAgICB9XG5cbiAgICBpZiAoZW5kLnBvcykge1xuICAgICAgdGhpcy5lbmQueCA9IGVuZC5wb3MueDtcbiAgICAgIHRoaXMuZW5kLnkgPSBlbmQucG9zLnlcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmWCA9IHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0Lng7XG4gICAgY29uc3QgZGlmZlkgPSB0aGlzLmVuZC55IC0gdGhpcy5zdGFydC55O1xuICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHRoaXMuc3RhcnQucm90KTtcbiAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyh0aGlzLnN0YXJ0LnJvdCk7XG5cbiAgICB0aGlzLmdvYWwgPSB7XG4gICAgICB4OiBjb3NSb3QgKiBkaWZmWCArIHNpblJvdCAqIGRpZmZZLFxuICAgICAgeTogLXNpblJvdCAqIGRpZmZYICsgY29zUm90ICogZGlmZlksXG4gICAgICByb3Q6IE1hdGgud3JhcEFuZ2xlKHRoaXMuZW5kLnJvdCAtIHRoaXMuc3RhcnQucm90KSxcbiAgICAgIGN1cnY6IHRoaXMuZW5kLmN1cnZcbiAgICB9O1xuXG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHsgcDA6IHRoaXMuc3RhcnQuY3VydiwgcDE6IHRoaXMuc3RhcnQuZEN1cnYgfHwgMCwgcDI6IHRoaXMuc3RhcnQuZGRDdXJ2IHx8IDAsIHA1OiB0aGlzLmVuZC5jdXJ2IH0pO1xuICB9XG5cbiAgYnVpbGRQYXRoKG51bSkge1xuICAgIGNvbnN0IHsgcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgc0cgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgY29uc3Qgc0dfMiA9IHNHICogc0c7XG4gICAgY29uc3Qgc0dfMyA9IHNHXzIgKiBzRztcblxuICAgIGNvbnN0IGEgPSBwMDtcbiAgICBjb25zdCBiID0gcDE7XG4gICAgY29uc3QgYyA9IHAyIC8gMi4wO1xuICAgIGNvbnN0IGQgPSAoLTcxLjg3NSAqIHAwICsgODEuMCAqIHAzIC0gMTAuMTI1ICogcDQgKyBwNSAtIDIxLjI1ICogcDEgKiBzRyAtIDIuNzUgKiBwMiAqIHNHXzIpIC8gc0dfMztcbiAgICBjb25zdCBlID0gKDE2Ni41ICogcDAgLSAyMDIuNSAqIHAzICsgNDAuNSAqIHA0IC0gNC41ICogcDUgKyA0NS4wICogcDEgKiBzRyArIDQuNSAqIHAyICogc0dfMikgLyAoc0dfMiAqIHNHXzIpO1xuICAgIGNvbnN0IGYgPSAoLTk1LjYyNSAqIHAwICsgMTIxLjUgKiBwMyAtIDMwLjM3NSAqIHA0ICsgNC41ICogcDUgLSAyNC43NSAqIHAxICogc0cgLSAyLjI1ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMyk7XG5cbiAgICBjb25zdCBwYXRoID0gW3sgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLnN0YXJ0LngsIHRoaXMuc3RhcnQueSksIHJvdDogdGhpcy5zdGFydC5yb3QsIGN1cnY6IHRoaXMuc3RhcnQuY3VydiB9XTtcbiAgICBjb25zdCBkcyA9IHNHIC8gKG51bSAtIDEpO1xuICAgIGxldCBzID0gZHM7XG4gICAgbGV0IGR4ID0gMDtcbiAgICBsZXQgZHkgPSAwO1xuICAgIGxldCBwcmV2Q29zUm90ID0gTWF0aC5jb3MocGF0aFswXS5yb3QpO1xuICAgIGxldCBwcmV2U2luUm90ID0gTWF0aC5zaW4ocGF0aFswXS5yb3QpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW0gLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdCA9ICgoKCgoZiAqIHMgLyA2LjAgKyBlIC8gNS4wKSAqIHMgKyBkIC8gNC4wKSAqIHMgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHMgKyB0aGlzLnN0YXJ0LnJvdDtcbiAgICAgIGNvbnN0IGN1cnYgPSAoKCgoZiAqIHMgKyBlKSAqIHMgKyBkKSAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuICAgICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3Mocm90KTtcbiAgICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHJvdCk7XG5cbiAgICAgIGR4ID0gZHggKiAoaSAtIDEpIC8gaSArIChjb3NSb3QgKyBwcmV2Q29zUm90KSAvICgyICogaSk7XG4gICAgICBkeSA9IGR5ICogKGkgLSAxKSAvIGkgKyAoc2luUm90ICsgcHJldlNpblJvdCkgLyAoMiAqIGkpO1xuXG4gICAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHMgKiBkeCArIHRoaXMuc3RhcnQueCwgcyAqIGR5ICsgdGhpcy5zdGFydC55KSwgcm90OiByb3QsIGN1cnY6IGN1cnYgfSk7XG5cbiAgICAgIHMgKz0gZHM7XG4gICAgICBwcmV2Q29zUm90ID0gY29zUm90O1xuICAgICAgcHJldlNpblJvdCA9IHNpblJvdDtcbiAgICB9XG5cbiAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuZW5kLngsIHRoaXMuZW5kLnkpLCByb3Q6IHRoaXMuZW5kLnJvdCwgY3VydjogdGhpcy5lbmQuY3VydiB9KTtcblxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG4iLCJjb25zdCBPQlNUQUNMRV9WRVJURVhfU0hBREVSID0gYCN2ZXJzaW9uIDMwMCBlc1xudW5pZm9ybSBtYXQzIHhmb3JtO1xuaW4gdmVjMiBwb3NpdGlvbjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh4Zm9ybSAqIHZlYzMocG9zaXRpb24sIDEpKS54eSwgMCwgMSk7XG59XG5gO1xuXG5jb25zdCBPQlNUQUNMRV9LRVJORUwgPSBgXG4gIHZlYzQga2VybmVsKCkge1xuICAgIHJldHVybiB2ZWM0KDEsIDAsIDAsIDEpO1xuICB9XG5gO1xuXG5sZXQgb2JzdGFjbGVWZXJ0aWNlcztcbmxldCBvYnN0YWNsZVhmb3JtO1xuXG4vLyBEcmF3IG9ic3RhY2xlIHRyaWFuZ2xlcyB0byBYWS1zcGFjZSBvYnN0YWNsZSBncmlkXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXJuZWw6IE9CU1RBQ0xFX0tFUk5FTCxcbiAgICAgIHZlcnRleFNoYWRlcjogT0JTVEFDTEVfVkVSVEVYX1NIQURFUixcbiAgICAgIG91dHB1dDogeyBuYW1lOiAneHlPYnN0YWNsZUdyaWQnIH0sXG4gICAgICBkcmF3OiAoZ3BncHUsIHByb2dyYW0pID0+IHtcbiAgICAgICAgY29uc3QgZ2wgPSBncGdwdS5nbDtcblxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgICBpZiAob2JzdGFjbGVWZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgYnVmID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmKTtcbiAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgb2JzdGFjbGVWZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtLnBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgICBjb25zdCB4Zm9ybUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAneGZvcm0nKTtcbiAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHhmb3JtTG9jYXRpb24sIGZhbHNlLCBvYnN0YWNsZVhmb3JtLmVsZW1lbnRzKTtcblxuICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBvYnN0YWNsZVZlcnRpY2VzLmxlbmd0aCAvIDIpO1xuXG4gICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50LCB2ZWhpY2xlWGZvcm0sIG9ic3RhY2xlcykge1xuICAgIG9ic3RhY2xlVmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIG9ic3RhY2xlcy5tYXAobyA9PiBvLnZlcnRpY2VzKSkpO1xuXG4gICAgY29uc3QgdHJhbnNsYXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgICB0cmFuc2xhdGUuc2V0KFxuICAgICAgMSwgMCwgLXh5Q2VudGVyUG9pbnQueCxcbiAgICAgIDAsIDEsIC14eUNlbnRlclBvaW50LnksXG4gICAgICAwLCAwLCAxXG4gICAgKTtcblxuICAgIGNvbnN0IHNjYWxlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgICBzY2FsZS5zZXQoXG4gICAgICAyIC8gKHh5V2lkdGggKiBjb25maWcueHlHcmlkQ2VsbFNpemUpLCAwLCAwLFxuICAgICAgMCwgMiAvICh4eUhlaWdodCAqIGNvbmZpZy54eUdyaWRDZWxsU2l6ZSksIDAsXG4gICAgICAwLCAwLCAxXG4gICAgKTtcblxuICAgIG9ic3RhY2xlWGZvcm0gPSBzY2FsZS5tdWx0aXBseSh0cmFuc2xhdGUpLm11bHRpcGx5KHZlaGljbGVYZm9ybSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHh5V2lkdGgsXG4gICAgICBoZWlnaHQ6IHh5SGVpZ2h0XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBTTF9PQlNUQUNMRV9LRVJORUwgPSBgXG5cbnZlYzQga2VybmVsKCkge1xuICBmbG9hdCBjZW50ZXJsaW5lV2lkdGggPSBmbG9hdCh0ZXh0dXJlU2l6ZShjZW50ZXJsaW5lLCAwKS54KTtcblxuICB2ZWMyIHNsID0gKGtlcm5lbFBvc2l0aW9uIC0gMC41KSAqIHZlYzIoa2VybmVsU2l6ZSkgKiB2ZWMyKHNsR3JpZENlbGxTaXplKSArIHNsQ2VudGVyUG9pbnQ7XG4gIGZsb2F0IGNlbnRlcmxpbmVDb29yZCA9IHNsLnggLyBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsIC8gY2VudGVybGluZVdpZHRoICogKGNlbnRlcmxpbmVXaWR0aCAtIDEuMCkgLyBjZW50ZXJsaW5lV2lkdGggKyAoMC41IC8gY2VudGVybGluZVdpZHRoKTtcbiAgaWYgKGNlbnRlcmxpbmVDb29yZCA8IDAuMCB8fCBjZW50ZXJsaW5lQ29vcmQgPiAxLjApIHJldHVybiB2ZWM0KDApO1xuXG4gIHZlYzMgY2VudGVybGluZVNhbXBsZSA9IHRleHR1cmUoY2VudGVybGluZSwgdmVjMihjZW50ZXJsaW5lQ29vcmQsIDApKS54eXo7XG4gIGZsb2F0IHBlcnBpbmRpY3VsYXIgPSBjZW50ZXJsaW5lU2FtcGxlLnogKyByYWRpYW5zKDkwLjApO1xuICB2ZWMyIHh5ID0gY2VudGVybGluZVNhbXBsZS54eSArIHNsLnl5ICogdmVjMihjb3MocGVycGluZGljdWxhciksIHNpbihwZXJwaW5kaWN1bGFyKSk7XG5cbiAgdmVjMiB4eVRleENvb3JkcyA9ICh4eSAtIHh5Q2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZSh4eU9ic3RhY2xlR3JpZCwgMCkpIC8gdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHh5T2JzdGFjbGVHcmlkLCB4eVRleENvb3Jkcyk7XG59XG5cbmA7XG5cbi8vIENvbnZlcnQgWFktc3BhY2Ugb2JzdGFjbGUgZ3JpZCB0byBTTC1zcGFjZSBvYnN0YWNsZSBncmlkXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXJuZWw6IFNMX09CU1RBQ0xFX0tFUk5FTCxcbiAgICAgIG91dHB1dDogeyBuYW1lOiAnc2xPYnN0YWNsZUdyaWQnIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB4eU9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgICAgICAgc2xHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIHNsQ2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBjZW50ZXJsaW5lOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0LCBzbENlbnRlclBvaW50LCB4eUNlbnRlclBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBzbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBzbEhlaWdodCxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHNsR3JpZENlbGxTaXplOiBjb25maWcuc2xHcmlkQ2VsbFNpemUsXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiBjb25maWcueHlHcmlkQ2VsbFNpemUsXG4gICAgICAgIHNsQ2VudGVyUG9pbnQ6IFtzbENlbnRlclBvaW50LngsIHNsQ2VudGVyUG9pbnQueV0sXG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IFt4eUNlbnRlclBvaW50LngsIHh5Q2VudGVyUG9pbnQueV0sXG4gICAgICAgIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IGNvbmZpZy5jZW50ZXJsaW5lU3RhdGlvbkludGVydmFsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBTTF9PQlNUQUNMRV9ESUxBVElPTl9LRVJORUwgPSBgXG5cbi8vIFRPRE86IHRlc3QgcGVyZm9ybWFuY2Ugb2YgcmV0dXJuaW5nIGVhcmx5IGlmIG5vbi16ZXJvIHBpeGVsIGZvdW5kXG52ZWM0IGtlcm5lbCgpIHtcbiAgZmxvYXQgdmFsID0gMC4wO1xuXG4gIGZvciAoaW50IGQgPSAwOyBkIDw9IGNvbGxpc2lvbkRpbGF0aW9uOyBkKyspIHtcbiAgICB2YWwgPSBtYXgodmFsLCB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBrZXJuZWxQb3NpdGlvbiArIGRlbHRhICogdmVjMihkKSkucik7XG4gICAgdmFsID0gbWF4KHZhbCwgdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwga2VybmVsUG9zaXRpb24gKyBkZWx0YSAqIHZlYzIoLWQpKS5yKTtcbiAgfVxuXG4gIGZvciAoaW50IGQgPSBjb2xsaXNpb25EaWxhdGlvbiArIDE7IGQgPD0gY29sbGlzaW9uRGlsYXRpb24gKyBoYXphcmREaWxhdGlvbjsgZCsrKSB7XG4gICAgdmFsID0gbWF4KHZhbCwgdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwga2VybmVsUG9zaXRpb24gKyBkZWx0YSAqIHZlYzIoZCkpLnIgKiAwLjUpO1xuICAgIHZhbCA9IG1heCh2YWwsIHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIGtlcm5lbFBvc2l0aW9uICsgZGVsdGEgKiB2ZWMyKC1kKSkuciAqIDAuNSk7XG4gIH1cblxuICB2YWwgPSBtYXgodmFsLCBzdGVwKDAuMSwgdmFsKSAqIDAuNSk7XG5cbiAgcmV0dXJuIHZlYzQodmFsLCAwLCAwLCAxKTtcbn1cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIFMgZGlsYXRpb25cbiAgICAgICAga2VybmVsOiBTTF9PQlNUQUNMRV9ESUxBVElPTl9LRVJORUwsXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnc2xPYnN0YWNsZUdyaWRTdGF0aW9uRGlsYXRlZCcgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBzbE9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgICAgICAgICBkZWx0YTogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIGhhemFyZERpbGF0aW9uOiB7IHR5cGU6ICdpbnQnIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgLy8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZCBMIGRpbGF0aW9uXG4gICAgICAgIGtlcm5lbDogU0xfT0JTVEFDTEVfRElMQVRJT05fS0VSTkVMLFxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ3NsT2JzdGFjbGVHcmlkRGlsYXRlZCcgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBzbE9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbE9ic3RhY2xlR3JpZFN0YXRpb25EaWxhdGVkJyB9LFxuICAgICAgICAgIGRlbHRhOiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICAgIGNvbGxpc2lvbkRpbGF0aW9uOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IHsgdHlwZTogJ2ludCcgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IC8vIFNMLXNwYWNlIG9ic3RhY2xlIGdyaWQgUyBkaWxhdGlvblxuICAgICAgICB3aWR0aDogc2xXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzbEhlaWdodCxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBkZWx0YTogWzEgLyBzbFdpZHRoLCAwXSxcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogTWF0aC5jZWlsKGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblMgLyBjb25maWcuc2xHcmlkQ2VsbFNpemUpLFxuICAgICAgICAgIGhhemFyZERpbGF0aW9uOiBNYXRoLmNlaWwoY29uZmlnLmhhemFyZERpbGF0aW9uUyAvIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgLy8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZCBMIGRpbGF0aW9uXG4gICAgICAgIHdpZHRoOiBzbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNsSGVpZ2h0LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIGRlbHRhOiBbMCwgMSAvIHNsSGVpZ2h0XSxcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogTWF0aC5jZWlsKGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvbkwgLyBjb25maWcuc2xHcmlkQ2VsbFNpemUpLFxuICAgICAgICAgIGhhemFyZERpbGF0aW9uOiBNYXRoLmNlaWwoY29uZmlnLmhhemFyZERpbGF0aW9uTCAvIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH1cbn1cbiIsImNvbnN0IERZTkFNSUNfT0JTVEFDTEVfVkVSVEVYX1NIQURFUiA9IGAjdmVyc2lvbiAzMDAgZXNcbnVuaWZvcm0gbWF0MyB4Zm9ybTtcbmluIHZlYzMgcG9zaXRpb247XG5vdXQgZmxvYXQgY29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgoeGZvcm0gKiB2ZWMzKHBvc2l0aW9uLnh5LCAxKSkueHksIHBvc2l0aW9uLnosIDEpO1xuXG4gIC8vIFRoZSB6IGNvb3JkaW5hdGUgaXMgMC4yNSBmb3IgY29sbGlzaW9uIHpvbmUgYW5kIDAuNzUgZm9yIGhhemFyZCB6b25lLFxuICAvLyBzbyB0aGF0IHRoZSBjb2xsaXNpb24gem9uZSBpcyBkcmF3biBvbiB0b3AuXG4gIC8vIENvbnZlcnQgdGhpcyB0byAxLjAgZm9yIGNvbGxpc2lvbiB6b25lLCAwLjUgZm9yIGhhemFyZCB6b25lXG4gIGNvbG9yID0gKDEuMCAtIHN0ZXAoMC41LCBwb3NpdGlvbi56KSkgKiAwLjUgKyAwLjU7XG59XG5gO1xuXG5jb25zdCBEWU5BTUlDX09CU1RBQ0xFX0tFUk5FTCA9IGBcbiAgaW4gZmxvYXQgY29sb3I7XG5cbiAgdmVjNCBrZXJuZWwoKSB7XG4gICAgcmV0dXJuIHZlYzQoY29sb3IsIDAsIDAsIDEpO1xuICB9XG5gO1xuXG5sZXQgb2JzdGFjbGVWZXJ0aWNlcztcbmxldCBvYnN0YWNsZVhmb3JtO1xuY29uc3QgbnVtRHluYW1pY0ZyYW1lcyA9IDIwO1xuXG4vLyBEcmF3IGR5bmFtaWMgb2JzdGFjbGUgdHJpYW5nbGVzIHRvIFNMLXNwYWNlIG9ic3RhY2xlIGdyaWRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogRFlOQU1JQ19PQlNUQUNMRV9LRVJORUwsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IERZTkFNSUNfT0JTVEFDTEVfVkVSVEVYX1NIQURFUixcbiAgICAgIG91dHB1dDogeyBuYW1lOiAnc2xEeW5hbWljT2JzdGFjbGVHcmlkJywgdGV4dHVyZVR5cGU6ICcyREFycmF5JywgZGVwdGg6IG51bUR5bmFtaWNGcmFtZXMgfSxcbiAgICAgIGRyYXc6IChncGdwdSwgcHJvZ3JhbSkgPT4ge1xuICAgICAgICBjb25zdCBnbCA9IGdwZ3B1LmdsO1xuXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcblxuICAgICAgICBjb25zdCByZW5kZXJidWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0KTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcblxuICAgICAgICBmb3IgKGxldCBmcmFtZSA9IDA7IGZyYW1lIDwgbnVtRHluYW1pY0ZyYW1lczsgZnJhbWUrKykge1xuICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgcHJvZ3JhbS5vdXRwdXRUZXh0dXJlLCAwLCBmcmFtZSk7XG4gICAgICAgICAgY29uc3QgZnJhbWVCdWZmZXJTdGF0dXMgPSAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xuICAgICAgICAgIGlmICghZnJhbWVCdWZmZXJTdGF0dXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGF0dGFjaGluZyBmbG9hdCB0ZXh0dXJlIHRvIGZyYW1lYnVmZmVyLiBZb3VyIGRldmljZSBpcyBwcm9iYWJseSBpbmNvbXBhdGlibGUuJyk7XG5cbiAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgICAgICAgIGlmIChvYnN0YWNsZVZlcnRpY2VzW2ZyYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1Zik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgb2JzdGFjbGVWZXJ0aWNlc1tmcmFtZV0sIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgICAgICAgICAgY29uc3QgeGZvcm1Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ3hmb3JtJyk7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHhmb3JtTG9jYXRpb24sIGZhbHNlLCBvYnN0YWNsZVhmb3JtLmVsZW1lbnRzKTtcblxuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIG9ic3RhY2xlVmVydGljZXNbZnJhbWVdLmxlbmd0aCAvIDMpO1xuXG4gICAgICAgICAgICBpZiAoZnJhbWUgPT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBvYnN0YWNsZUdyaWQgPSBuZXcgRmxvYXQzMkFycmF5KHByb2dyYW0uaW5wdXRXaWR0aCAqIHByb2dyYW0uaW5wdXRIZWlnaHQgKiA0KTtcbiAgICAgICAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQsIGdsLlJHQkEsIGdsLkZMT0FULCBvYnN0YWNsZUdyaWQpO1xuICAgICAgICAgICAgICBncGdwdS5fZHluYW1pY09ic3RhY2xlR3JpZCA9IG9ic3RhY2xlR3JpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKGJ1Zik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyYnVmZmVyKTtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0LCBzbENlbnRlclBvaW50LCB2ZWhpY2xlU3RhdGlvbiwgc3RhcnRUaW1lLCBkeW5hbWljRnJhbWVUaW1lLCBkeW5hbWljT2JzdGFjbGVzKSB7XG4gICAgb2JzdGFjbGVWZXJ0aWNlcyA9IFtdO1xuXG4gICAgbGV0IHRpbWUgPSBzdGFydFRpbWU7XG4gICAgZm9yIChsZXQgZnJhbWUgPSAwOyBmcmFtZSA8IG51bUR5bmFtaWNGcmFtZXM7IGZyYW1lKyspIHtcbiAgICAgIGNvbnN0IHZlcnRpY2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgZHluYW1pY09ic3RhY2xlcy5tYXAobyA9PiBvLnZlcnRpY2VzSW5UaW1lUmFuZ2UodGltZSwgdGltZSArIGR5bmFtaWNGcmFtZVRpbWUsIGNvbmZpZykpKTtcbiAgICAgIG9ic3RhY2xlVmVydGljZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKSk7XG4gICAgICB0aW1lICs9IGR5bmFtaWNGcmFtZVRpbWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgICB0cmFuc2xhdGUuc2V0KFxuICAgICAgMSwgMCwgLXNsQ2VudGVyUG9pbnQueCAtIHZlaGljbGVTdGF0aW9uLFxuICAgICAgMCwgMSwgLXNsQ2VudGVyUG9pbnQueSxcbiAgICAgIDAsIDAsIDFcbiAgICApO1xuXG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICAgIHNjYWxlLnNldChcbiAgICAgIDIgLyAoc2xXaWR0aCAqIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSksIDAsIDAsXG4gICAgICAwLCAyIC8gKHNsSGVpZ2h0ICogY29uZmlnLnNsR3JpZENlbGxTaXplKSwgMCxcbiAgICAgIDAsIDAsIDFcbiAgICApO1xuXG4gICAgb2JzdGFjbGVYZm9ybSA9IHNjYWxlLm11bHRpcGx5KHRyYW5zbGF0ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHNsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHNsSGVpZ2h0XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBYWVNMX01BUF9LRVJORUwgPSBgXG5cbnZlYzQga2VybmVsKCkge1xuICB2ZWMyIHh5ID0gKGtlcm5lbFBvc2l0aW9uIC0gMC41KSAqIHZlYzIoa2VybmVsU2l6ZSkgKiB2ZWMyKHh5R3JpZENlbGxTaXplKSArIHh5Q2VudGVyUG9pbnQ7XG5cbiAgaW50IG51bVNhbXBsZXMgPSB0ZXh0dXJlU2l6ZShjZW50ZXJsaW5lLCAwKS54O1xuICBpbnQgY2xvc2VzdCA9IDA7XG4gIGZsb2F0IGNsb3Nlc3REaXN0ID0gZGlzdGFuY2UoeHksIHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoMCwgMCksIDApLnh5KTtcbiAgZm9yIChpbnQgaSA9IDE7IGkgPCBudW1TYW1wbGVzOyBpKyspIHtcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UoeHksIHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoaSwgMCksIDApLnh5KTtcbiAgICBpZiAoZGlzdCA8IGNsb3Nlc3REaXN0KSB7XG4gICAgICBjbG9zZXN0RGlzdCA9IGRpc3Q7XG4gICAgICBjbG9zZXN0ID0gaTtcbiAgICB9XG4gIH1cblxuICB2ZWMyIGNsb3Nlc3RQb3MgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGNsb3Nlc3QsIDApLCAwKS54eTtcbiAgdmVjMiBwcmV2LCBuZXh0O1xuICBpbnQgcHJldkluZGV4LCBuZXh0SW5kZXg7XG5cbiAgaWYgKGNsb3Nlc3QgPT0gMCkge1xuICAgIHByZXZJbmRleCA9IDA7XG4gICAgbmV4dEluZGV4ID0gMTtcbiAgICBwcmV2ID0gY2xvc2VzdFBvcztcbiAgICBuZXh0ID0gdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMigxLCAwKSwgMCkueHk7XG4gIH0gZWxzZSBpZiAoY2xvc2VzdCA9PSBudW1TYW1wbGVzIC0gMSkge1xuICAgIHByZXZJbmRleCA9IGNsb3Nlc3QgLSAxO1xuICAgIG5leHRJbmRleCA9IGNsb3Nlc3Q7XG4gICAgcHJldiA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIocHJldkluZGV4LCAwKSwgMCkueHk7XG4gICAgbmV4dCA9IGNsb3Nlc3RQb3M7XG4gIH0gZWxzZSB7XG4gICAgdmVjMiBiZWZvcmUgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGNsb3Nlc3QgLSAxLCAwKSwgMCkueHk7XG4gICAgdmVjMiBhZnRlciA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoY2xvc2VzdCArIDEsIDApLCAwKS54eTtcblxuICAgIGlmIChkaXN0YW5jZShiZWZvcmUsIHh5KSA8IGRpc3RhbmNlKGFmdGVyLCB4eSkpIHtcbiAgICAgIHByZXZJbmRleCA9IGNsb3Nlc3QgLSAxO1xuICAgICAgbmV4dEluZGV4ID0gY2xvc2VzdDtcbiAgICAgIHByZXYgPSBiZWZvcmU7XG4gICAgICBuZXh0ID0gY2xvc2VzdFBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldkluZGV4ID0gY2xvc2VzdDtcbiAgICAgIG5leHRJbmRleCA9IGNsb3Nlc3QgKyAxO1xuICAgICAgcHJldiA9IGNsb3Nlc3RQb3M7XG4gICAgICBuZXh0ID0gYWZ0ZXI7XG4gICAgfVxuICB9XG5cbiAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHByZXYsIG5leHQpO1xuICBmbG9hdCBwcm9ncmVzcyA9IGNsYW1wKGRvdCh4eSAtIHByZXYsIG5leHQgLSBwcmV2KSAvIGRpc3QgLyBkaXN0LCAwLjAsIDEuMCk7XG4gIHZlYzIgcHJvamVjdGVkUG9zID0gKG5leHQgLSBwcmV2KSAqIHZlYzIocHJvZ3Jlc3MpICsgcHJldjtcblxuICByZXR1cm4gdmVjNChcbiAgICAoZmxvYXQocHJldkluZGV4KSArIHByb2dyZXNzKSAqIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwsXG4gICAgc2lnbihkZXRlcm1pbmFudChtYXQyKG5leHQgLSBwcmV2LCB4eSAtIHByZXYpKSkgKiBkaXN0YW5jZSh4eSwgcHJvamVjdGVkUG9zKSxcbiAgICAwLFxuICAgIDBcbiAgKTtcbn1cblxuYDtcblxuLy8gQnVpbGQgWFktU0wgbWFwXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXJuZWw6IFhZU0xfTUFQX0tFUk5FTCxcbiAgICAgIG91dHB1dDogeyBuYW1lOiAneHlzbE1hcCcsIGZpbHRlcjogJ2xpbmVhcicgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGNlbnRlcmxpbmU6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCd9LFxuICAgICAgICBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsOiB7IHR5cGU6ICdmbG9hdCd9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogeHlXaWR0aCxcbiAgICAgIGhlaWdodDogeHlIZWlnaHQsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB4eUNlbnRlclBvaW50OiBbeHlDZW50ZXJQb2ludC54LCB4eUNlbnRlclBvaW50LnldLFxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxuICAgICAgICBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsOiBjb25maWcuY2VudGVybGluZVN0YXRpb25JbnRlcnZhbFxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvbmZpZzpcbi8vIG51bSBzdGF0aW9uc1xuLy8gbnVtIGxhdGl0dWRlc1xuLy8gc3RhdGlvbiBjb25uZWN0aXZpdHlcbi8vIGxhdGl0dWRlIGNvbm5lY3Rpdml0eVxuLy9cbi8vIFNoYXJlZDpcbi8vIGxhdHRpY2VcblxuY29uc3QgT1BUSU1JWkVfQ1VCSUNfU0hBUkVEID0gYFxuXG5jb25zdCBpbnQgTkVXVE9OX0lURVJBVElPTlMgPSAxNjtcbmNvbnN0IGludCBSRUxBWEFUSU9OX0lURVJBVElPTlMgPSAxNjtcbmNvbnN0IGZsb2F0IENPTlZFUkdFTkNFX0VSUk9SID0gMC4wMTtcblxuLy8gVGhlc2UgdHdvIGNvbnN0cyBtdXN0IHN0YXkgaW4gc3luYy5cbmNvbnN0IGludCBTSU1QU09OU19JTlRFUlZBTFMgPSA4O1xuLy9jb25zdCBmbG9hdCBTSU1QU09OU19DT0VGRlNbU0lNUFNPTlNfSU5URVJWQUxTICsgMV0gPSBmbG9hdFtdKDEuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMS4wKTtcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XG5cbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O1xuY29uc3QgZmxvYXQgVFdPX1BJID0gUEkgKyBQSTtcblxuY29uc3QgZmxvYXQgUkVMQVhBVElPTl9JVEVSQVRJT05TX0YgPSBmbG9hdChSRUxBWEFUSU9OX0lURVJBVElPTlMpO1xuY29uc3QgZmxvYXQgU0lNUFNPTlNfSU5URVJWQUxTX0YgPSBmbG9hdChTSU1QU09OU19JTlRFUlZBTFMpO1xuXG5mbG9hdCB3cmFwQW5nbGUoZmxvYXQgYW5nbGUpIHtcbiAgYW5nbGUgPSBtb2QoYW5nbGUsIFRXT19QSSk7XG4gIGlmIChhbmdsZSA8PSAtUEkpIHJldHVybiBhbmdsZSArIFRXT19QSTtcbiAgZWxzZSBpZiAoYW5nbGUgPiBQSSkgcmV0dXJuIGFuZ2xlIC0gVFdPX1BJO1xuICByZXR1cm4gYW5nbGU7XG59XG5cbnZlYzQgaXRlcmF0ZSh2ZWM0IGdvYWwsIGZsb2F0IHAwLCBmbG9hdCBwMSwgZmxvYXQgcDIsIGZsb2F0IHAzLCBmbG9hdCBzRykge1xuICBmbG9hdCBkcyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0Y7XG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gIHZlYzMgZFhfcCA9IHZlYzMoMC4wKTtcbiAgdmVjMyBkWV9wID0gdmVjMygwLjApO1xuICB2ZWMyIGd1ZXNzID0gdmVjMigwLjApO1xuICBmbG9hdCBzID0gMC4wO1xuXG4gIGZsb2F0IHRoZXRhLCBjb3NUaGV0YSwgc2luVGhldGE7XG4gIHZlYzMgZFRfcDtcblxuICBmb3IgKGludCBpID0gMDsgaSA8PSBTSU1QU09OU19JTlRFUlZBTFM7IGkrKykge1xuICAgIGZsb2F0IGNvZWZmID0gU0lNUFNPTlNfQ09FRkZTW2ldO1xuXG4gICAgZmxvYXQgYSA9IHAwO1xuICAgIGZsb2F0IGIgPSAoLTUuNSAqIHAwICsgOS4wICogcDEgLSA0LjUgKiBwMiArIHAzKSAvIHNHO1xuICAgIGZsb2F0IGMgPSAoOS4wICogcDAgLSAyMi41ICogcDEgKyAxOC4wICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xuICAgIGZsb2F0IGQgPSAoLTQuNSAqIChwMCAtIDMuMCAqIHAxICsgMy4wICogcDIgLSBwMykpIC8gc0dfMztcblxuICAgIHRoZXRhID0gKCgoZCAqIHMgLyA0LjAgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHM7XG4gICAgY29zVGhldGEgPSBjb3ModGhldGEpO1xuICAgIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIGZsb2F0IHNfc0cgPSBzIC8gc0c7XG5cbiAgICBkVF9wID0gdmVjMyhcbiAgICAgIC8vIHAxXG4gICAgICAoKDMuMzc1ICogc19zRyAtIDcuNSkgKiBzX3NHICsgNC41KSAqIHNfc0cgKiBzLFxuXG4gICAgICAvLyBwMlxuICAgICAgKCgtMy4zNzUgKiBzX3NHICsgNi4wKSAqIHNfc0cgLSAyLjI1KSAqIHNfc0cgKiBzLFxuXG4gICAgICAvLyBzR1xuICAgICAgKCgzLjM3NSAqIChwMCAtIDMuMCAqIHAxICsgMy4wICogcDIgLSBwMykgKiBzX3NHIC0gMy4wICogKDIuMCAqIHAwIC0gNS4wICogcDEgKyA0LjAgKiBwMiAtIHAzKSkgKiBzX3NHICsgMC4yNSAqICgxMS4wICogcDAgLSAxOC4wICogcDEgKyA5LjAgKiBwMiAtIDIuMCAqIHAzKSkgKiBzX3NHICogc19zR1xuICAgICk7XG5cbiAgICBkWF9wIC09IGNvZWZmICogc2luVGhldGEgKiBkVF9wO1xuICAgIGRZX3AgKz0gY29lZmYgKiBjb3NUaGV0YSAqIGRUX3A7XG5cbiAgICBndWVzcyArPSBjb2VmZiAqIHZlYzIoY29zVGhldGEsIHNpblRoZXRhKTtcblxuICAgIHMgKz0gZHM7XG4gIH1cblxuICBmbG9hdCBoT3ZlcjMgPSBzRyAvIFNJTVBTT05TX0lOVEVSVkFMU19GIC8gMy4wO1xuXG4gIHZlYzMgZGVsdGE7XG4gIGRlbHRhLnh5ID0gZ29hbC54eSAtIGd1ZXNzICogaE92ZXIzO1xuICBkZWx0YS56ID0gd3JhcEFuZ2xlKGdvYWwueiAtIHRoZXRhKTtcblxuICBpZiAoYWJzKGRlbHRhLngpICsgYWJzKGRlbHRhLnkpICsgYWJzKGRlbHRhLnopIDwgQ09OVkVSR0VOQ0VfRVJST1IpXG4gICAgcmV0dXJuIHZlYzQocDEsIHAyLCBzRywgMS4wKTtcblxuICBkWF9wLnh5eiAqPSBoT3ZlcjM7XG4gIGRZX3AueHl6ICo9IGhPdmVyMztcbiAgZFhfcC56ICs9IGNvc1RoZXRhO1xuICBkWV9wLnogKz0gc2luVGhldGE7XG5cbiAgbWF0MyBpbnZKYWNvYmlhbiA9IGludmVyc2UodHJhbnNwb3NlKG1hdDMoZFhfcCwgZFlfcCwgZFRfcCkpKTtcblxuICB2ZWMzIGRlbHRhUCA9IGludkphY29iaWFuICogZGVsdGE7XG4gIHZlYzQgcGFyYW1zID0gdmVjNChwMSwgcDIsIHNHLCAwLjApO1xuICBwYXJhbXMueHl6ICs9IGRlbHRhUDtcblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vKiBJbnB1dDpcbiAqICAgc3RhcnQ6ICh2ZWM0KVxuICogICAgIHg6IHggcG9zaXRpb24sXG4gKiAgICAgeTogeSBwb3NpdGlvbixcbiAqICAgICB6OiB0aGV0YSByb3RhdGlvbixcbiAqICAgICB3OiBrIGN1cnZhdHVyZVxuICogICBlbmQ6ICh2ZWM0KVxuICogICAgIHg6IHggcG9zaXRpb24sXG4gKiAgICAgeTogeSBwb3NpdGlvbixcbiAqICAgICB6OiB0aGV0YSByb3RhdGlvbixcbiAqICAgICB3OiBrIGN1cnZhdHVyZVxuICpcbiAqIE91dHB1dDogKHZlYzQpXG4gKiAgIHg6IHAxLFxuICogICB5OiBwMixcbiAqICAgejogc0csXG4gKiAgIHc6IDEgaWYgY29udmVyZ2VkLCAwIGlmIG5vdFxuICovXG5cbnZlYzQgb3B0aW1pemUodmVjNCBzdGFydCwgdmVjNCBlbmQpIHtcbiAgLy8gVHJhbnNsYXRlIGFuZCByb3RhdGUgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IHN0YXJ0IGlzIGF0IHRoZSBvcmlnaW5cbiAgZmxvYXQgc2luUm90ID0gc2luKHN0YXJ0LnopO1xuICBmbG9hdCBjb3NSb3QgPSBjb3Moc3RhcnQueik7XG5cbiAgdmVjNCBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gIHZlYzQgZ29hbDtcbiAgZ29hbC54eSA9IG1hdDIoY29zUm90LCAtc2luUm90LCBzaW5Sb3QsIGNvc1JvdCkgKiBkaWZmLnh5O1xuICBnb2FsLnogPSB3cmFwQW5nbGUoZGlmZi56KTtcbiAgZ29hbC53ID0gZW5kLnc7XG5cbiAgdmVjNCBvcmlnaW5hbEdvYWwgPSBnb2FsO1xuICB2ZWM0IGRHb2FsO1xuICBkR29hbC54ID0gMC4wO1xuICBkR29hbC55encgPSBnb2FsLnl6dyAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xuICBmbG9hdCBkSzAgPSBzdGFydC53IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG5cbiAgLy8gUmVsYXggdGhlIGdvYWwgdG8gKHgsIDAsIDAsIDApXG4gIGdvYWwueXp3ID0gdmVjMygwLCAwLCAwKTtcblxuICAvLyBSZWxheCB0aGUgcGFyYW1zIHRvICgwLCAwLCAwLCAwLCBnb2FsLngpXG4gIGZsb2F0IHAwID0gMC4wO1xuICBmbG9hdCBwMSA9IDAuMDtcbiAgZmxvYXQgcDIgPSAwLjA7XG4gIGZsb2F0IHAzID0gMC4wO1xuICBmbG9hdCBzRyA9IGdvYWwueDtcblxuICBpZiAoc0cgPCAwLjEpIHJldHVybiB2ZWM0KDAuMCk7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBSRUxBWEFUSU9OX0lURVJBVElPTlM7IGkrKykge1xuICAgIHAwICs9IGRLMDtcbiAgICBwMyArPSBkR29hbC53O1xuICAgIGdvYWwgKz0gZEdvYWw7XG4gICAgXG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBzRyk7XG4gICAgcDEgPSByZXN1bHQueDtcbiAgICBwMiA9IHJlc3VsdC55O1xuICAgIHNHID0gcmVzdWx0Lno7XG4gIH1cblxuICBnb2FsID0gb3JpZ2luYWxHb2FsO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7IGkrKykge1xuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgc0cpO1xuICAgIGlmIChyZXN1bHQudyA9PSAxLjApIHtcbiAgICAgIHJlc3VsdC53ID0gc3RlcCgwLjAsIHJlc3VsdC56KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcDEgPSByZXN1bHQueDtcbiAgICBwMiA9IHJlc3VsdC55O1xuICAgIHNHID0gcmVzdWx0Lno7XG4gIH1cblxuICByZXR1cm4gdmVjNChwMSwgcDIsIHNHLCAwLjApO1xufVxuXG5gO1xuXG5jb25zdCBPUFRJTUlaRV9DVUJJQ19LRVJORUwgPSBPUFRJTUlaRV9DVUJJQ19TSEFSRUQgKyBgXG5cbi8vIHdpZHRoOiBzdGF0aW9uICogbGF0aXR1ZGUgaW5kZXhcbi8vIGhlaWdodDogc3RhdGlvbl9jb25uICogbGF0dGljZV9jb25uXG4vL1xuLy8gbGF0dGljZTpcbi8vIHdpZHRoOiBsYXRpdHVkZXNcbi8vIGhlaWdodDogc3RhdGlvbnNcblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGluZGV4ZXMgPSBpdmVjMihrZXJuZWxQb3NpdGlvbiAqIHZlYzIoa2VybmVsU2l6ZSkpO1xuXG4gIGludCBlbmRTdGF0aW9uID0gaW5kZXhlcy54IC8gbnVtTGF0aXR1ZGVzO1xuICBpbnQgZW5kTGF0aXR1ZGUgPSBpbnQobW9kKGZsb2F0KGluZGV4ZXMueCksIGZsb2F0KG51bUxhdGl0dWRlcykpKTtcblxuICBpbnQgc3RhcnRTdGF0aW9uID0gZW5kU3RhdGlvbiAtIHN0YXRpb25Db25uZWN0aXZpdHkgKyBpbmRleGVzLnkgLyBsYXRpdHVkZUNvbm5lY3Rpdml0eTtcbiAgaW50IHN0YXJ0TGF0aXR1ZGUgPSBlbmRMYXRpdHVkZSAtIGxhdGl0dWRlQ29ubmVjdGl2aXR5IC8gMiArIGludChtb2QoZmxvYXQoaW5kZXhlcy55KSwgZmxvYXQobGF0aXR1ZGVDb25uZWN0aXZpdHkpKSk7XG5cbiAgaWYgKHN0YXJ0U3RhdGlvbiA8IDAgfHwgc3RhcnRTdGF0aW9uID49IG51bVN0YXRpb25zIHx8IHN0YXJ0TGF0aXR1ZGUgPCAwIHx8IHN0YXJ0TGF0aXR1ZGUgPj0gbnVtTGF0aXR1ZGVzKVxuICAgIHJldHVybiB2ZWM0KDAuMCk7XG5cbiAgdmVjNCBzdGFydCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIoc3RhcnRMYXRpdHVkZSwgc3RhcnRTdGF0aW9uKSwgMCk7XG4gIHZlYzQgZW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihlbmRMYXRpdHVkZSwgZW5kU3RhdGlvbiksIDApO1xuXG4gIHJldHVybiBvcHRpbWl6ZShzdGFydCwgZW5kKTtcbn1cblxuYDtcblxuY29uc3QgT1BUSU1JWkVfQ1VCSUNfRlJPTV9WRUhJQ0xFX0tFUk5FTCA9IE9QVElNSVpFX0NVQklDX1NIQVJFRCArIGBcblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGluZGV4ZXMgPSBpdmVjMihrZXJuZWxQb3NpdGlvbiAqIHZlYzIoa2VybmVsU2l6ZSkpO1xuXG4gIHZlYzQgc3RhcnQgPSB2ZWM0KDAsIDAsIDAsIGN1cnZWZWhpY2xlKTtcbiAgdmVjNCBlbmQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGluZGV4ZXMsIDApO1xuXG4gIHJldHVybiBvcHRpbWl6ZShzdGFydCwgZW5kKTtcbn1cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyAvLyBDdWJpYyBwYXRocyBiZXR3ZWVuIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAga2VybmVsOiBPUFRJTUlaRV9DVUJJQ19LRVJORUwsXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnY3ViaWNQYXRocycsIHJlYWQ6IHRydWUgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxuICAgICAgICAgIG51bVN0YXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgbnVtTGF0aXR1ZGVzOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiB7IHR5cGU6ICdpbnQnIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgLy8gQ3ViaWMgcGF0aHMgZnJvbSB2ZWhpY2xlIHRvIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAga2VybmVsOiBPUFRJTUlaRV9DVUJJQ19GUk9NX1ZFSElDTEVfS0VSTkVMLFxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ2N1YmljUGF0aHNGcm9tVmVoaWNsZScsIHJlYWQ6IHRydWUgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxuICAgICAgICAgIGN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHBvc2UpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyAvLyBDdWJpYyBwYXRocyBiZXR3ZWVuIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zICogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHkgKiBjb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBudW1TdGF0aW9uczogY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXG4gICAgICAgICAgbnVtTGF0aXR1ZGVzOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcbiAgICAgICAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHksXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IC8vIEN1YmljIHBhdGhzIGZyb20gdmVoaWNsZSB0byBsYXR0aWNlIG5vZGVzXG4gICAgICAgIHdpZHRoOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9XG59XG4iLCJjb25zdCBPUFRJTUlaRV9LRVJORUwgPSBgXG5cbmNvbnN0IGludCBORVdUT05fSVRFUkFUSU9OUyA9IDMyO1xuY29uc3QgaW50IFJFTEFYQVRJT05fSVRFUkFUSU9OUyA9IDMyO1xuY29uc3QgZmxvYXQgQ09OVkVSR0VOQ0VfRVJST1IgPSAwLjAxO1xuXG4vLyBUaGVzZSB0d28gY29uc3RzIG11c3Qgc3RheSBpbiBzeW5jLlxuY29uc3QgaW50IFNJTVBTT05TX0lOVEVSVkFMUyA9IDg7XG5jb25zdCBmbG9hdCBTSU1QU09OU19DT0VGRlNbU0lNUFNPTlNfSU5URVJWQUxTICsgMV0gPSBmbG9hdFtdKDEuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAxLjApO1xuXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTtcbmNvbnN0IGZsb2F0IFRXT19QSSA9IFBJICsgUEk7XG5cbmNvbnN0IGZsb2F0IFJFTEFYQVRJT05fSVRFUkFUSU9OU19GID0gZmxvYXQoUkVMQVhBVElPTl9JVEVSQVRJT05TKTtcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0lOVEVSVkFMU19GID0gZmxvYXQoU0lNUFNPTlNfSU5URVJWQUxTKTtcblxuZmxvYXQgd3JhcEFuZ2xlKGZsb2F0IGFuZ2xlKSB7XG4gIGFuZ2xlID0gbW9kKGFuZ2xlLCBUV09fUEkpO1xuICBpZiAoYW5nbGUgPD0gLVBJKSByZXR1cm4gYW5nbGUgKyBUV09fUEk7XG4gIGVsc2UgaWYgKGFuZ2xlID4gUEkpIHJldHVybiBhbmdsZSAtIFRXT19QSTtcbiAgcmV0dXJuIGFuZ2xlO1xufVxuXG52ZWM0IGl0ZXJhdGUodmVjNCBnb2FsLCBmbG9hdCBwMCwgZmxvYXQgcDEsIGZsb2F0IHAyLCBmbG9hdCBwMywgZmxvYXQgcDQsIGZsb2F0IHA1LCBmbG9hdCBzRykge1xuICBmbG9hdCBkcyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0Y7XG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gIHZlYzMgZFhfcCA9IHZlYzMoMC4wKTtcbiAgdmVjMyBkWV9wID0gdmVjMygwLjApO1xuICB2ZWMyIGd1ZXNzID0gdmVjMigwLjApO1xuICBmbG9hdCBzID0gMC4wO1xuXG4gIGZsb2F0IHRoZXRhLCBjb3NUaGV0YSwgc2luVGhldGE7XG4gIHZlYzMgZFRfcDtcblxuICBmb3IgKGludCBpID0gMDsgaSA8PSBTSU1QU09OU19JTlRFUlZBTFM7IGkrKykge1xuICAgIGZsb2F0IGNvZWZmID0gU0lNUFNPTlNfQ09FRkZTW2ldO1xuXG4gICAgZmxvYXQgYSA9IHAwO1xuICAgIGZsb2F0IGIgPSBwMTtcbiAgICBmbG9hdCBjID0gcDIgLyAyLjA7XG4gICAgZmxvYXQgZCA9ICgtNzEuODc1ICogcDAgKyA4MS4wICogcDMgLSAxMC4xMjUgKiBwNCArIHA1IC0gMjEuMjUgKiBwMSAqIHNHIC0gMi43NSAqIHAyICogc0dfMikgLyBzR18zO1xuICAgIGZsb2F0IGUgPSAoMTY2LjUgKiBwMCAtIDIwMi41ICogcDMgKyA0MC41ICogcDQgLSA0LjUgKiBwNSArIDQ1LjAgKiBwMSAqIHNHICsgNC41ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMik7XG4gICAgZmxvYXQgZiA9ICgtOTUuNjI1ICogcDAgKyAxMjEuNSAqIHAzIC0gMzAuMzc1ICogcDQgKyA0LjUgKiBwNSAtIDI0Ljc1ICogcDEgKiBzRyAtIDIuMjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18zKTtcblxuICAgIHRoZXRhID0gKCgoKChmICogcyAvIDYuMCArIGUgLyA1LjApICogcyArIGQgLyA0LjApICogcyArIGMgLyAzLjApICogcyArIGIgLyAyLjApICogcyArIGEpICogcztcbiAgICBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgc2luVGhldGEgPSBzaW4odGhldGEpO1xuXG4gICAgZmxvYXQgc18yID0gcyAqIHM7XG4gICAgZmxvYXQgc19zRyA9IHMgLyBzRztcbiAgICBmbG9hdCBzX3NHXzIgPSBzX3NHICogc19zRztcbiAgICBmbG9hdCBzX3NHXzMgPSBzX3NHXzIgKiBzX3NHO1xuICAgIGZsb2F0IHNfc0dfNCA9IHNfc0dfMyAqIHNfc0c7XG4gICAgZmxvYXQgc19zR181ID0gc19zR180ICogc19zRztcblxuICAgIGRUX3AgPSB2ZWMzKFxuICAgICAgLy8gcDNcbiAgICAgICgoMjAuMjUgKiBzX3NHIC0gNDAuNSkgKiBzX3NHICsgMjAuMjUpICogc19zR18zICogcyxcblxuICAgICAgLy8gcDRcbiAgICAgICgoLTUuMDYyNSAqIHNfc0cgKyA4LjEpICogc19zRyAtIDIuNTMxMjUpICogc19zR18zICogcyxcblxuICAgICAgLy8gc0dcbiAgICAgICg1My45MDYyNSAqIHAwIC0gNjAuNzUgKiBwMyArIDcuNTkzNzUgKiBwNCAtIDAuNzUgKiBwNSkgKiBzX3NHXzQgKyAxMC42MjUgKiBwMSAqIHMgKiBzX3NHXzMgKyAwLjY4NzUgKiBwMiAqIHNfMiAqIHNfc0dfMiArICgtMTMzLjIgKiBwMCArIDE2Mi4wICogcDMgLSAzMi40ICogcDQgKyAzLjYgKiBwNSkgKiBzX3NHXzUgKyAoLTI3LjApICogcDEgKiBzICogc19zR180IC0gMS44ICogcDIgKiBzXzIgKiBzX3NHXzMgKyAoNzkuNjg3NSAqIHAwIC0gMTAxLjI1ICogcDMgKyAyNS4zMTI1ICogcDQgLSAzLjc1ICogcDUpICogc19zR181ICogc19zRyArIDE2LjUgKiBwMSAqIHMgKiBzX3NHXzUgKyAxLjEyNSAqIHAyICogc18yICogc19zR180XG4gICAgKTtcblxuICAgIGRYX3AgLT0gY29lZmYgKiBzaW5UaGV0YSAqIGRUX3A7XG4gICAgZFlfcCArPSBjb2VmZiAqIGNvc1RoZXRhICogZFRfcDtcblxuICAgIGd1ZXNzICs9IGNvZWZmICogdmVjMihjb3NUaGV0YSwgc2luVGhldGEpO1xuXG4gICAgcyArPSBkcztcbiAgfVxuXG4gIGZsb2F0IGhPdmVyMyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0YgLyAzLjA7XG5cbiAgdmVjMyBkZWx0YTtcbiAgZGVsdGEueHkgPSBnb2FsLnh5IC0gZ3Vlc3MgKiBoT3ZlcjM7XG4gIGRlbHRhLnogPSB3cmFwQW5nbGUoZ29hbC56IC0gdGhldGEpO1xuXG4gIGlmIChhYnMoZGVsdGEueCkgKyBhYnMoZGVsdGEueSkgKyBhYnMoZGVsdGEueikgPCBDT05WRVJHRU5DRV9FUlJPUilcbiAgICByZXR1cm4gdmVjNChwMywgcDQsIHNHLCAxLjApO1xuXG4gIGRYX3AueHl6ICo9IGhPdmVyMztcbiAgZFlfcC54eXogKj0gaE92ZXIzO1xuICBkWF9wLnogKz0gY29zVGhldGE7XG4gIGRZX3AueiArPSBzaW5UaGV0YTtcblxuICBtYXQzIGludkphY29iaWFuID0gaW52ZXJzZSh0cmFuc3Bvc2UobWF0MyhkWF9wLCBkWV9wLCBkVF9wKSkpO1xuXG4gIHZlYzMgZGVsdGFQID0gaW52SmFjb2JpYW4gKiBkZWx0YTtcbiAgdmVjNCBwYXJhbXMgPSB2ZWM0KHAzLCBwNCwgc0csIDAuMCk7XG4gIHBhcmFtcy54eXogKz0gZGVsdGFQO1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbnZlYzQgb3B0aW1pemUodmVjNCBzdGFydCwgdmVjNCBlbmQpIHtcbiAgLy8gVHJhbnNsYXRlIGFuZCByb3RhdGUgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IHN0YXJ0IGlzIGF0IHRoZSBvcmlnaW5cbiAgZmxvYXQgc2luUm90ID0gc2luKHN0YXJ0LnopO1xuICBmbG9hdCBjb3NSb3QgPSBjb3Moc3RhcnQueik7XG5cbiAgdmVjNCBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gIHZlYzQgZ29hbDtcbiAgZ29hbC54eSA9IG1hdDIoY29zUm90LCAtc2luUm90LCBzaW5Sb3QsIGNvc1JvdCkgKiBkaWZmLnh5O1xuICBnb2FsLnogPSB3cmFwQW5nbGUoZGlmZi56KTtcbiAgZ29hbC53ID0gZW5kLnc7XG5cbiAgdmVjNCBvcmlnaW5hbEdvYWwgPSBnb2FsO1xuICB2ZWM0IGRHb2FsO1xuICBkR29hbC54ID0gMC4wO1xuICBkR29hbC55encgPSBnb2FsLnl6dyAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xuICBmbG9hdCBkX0swID0gc3RhcnQudyAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xuICBmbG9hdCBkX2RLMCA9IGRDdXJ2VmVoaWNsZSAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xuICBmbG9hdCBkX2RkSzAgPSBkZEN1cnZWZWhpY2xlIC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG5cbiAgLy8gUmVsYXggdGhlIGdvYWwgdG8gKHgsIDAsIDAsIDApXG4gIGdvYWwueXp3ID0gdmVjMygwLCAwLCAwKTtcblxuICAvLyBSZWxheCB0aGUgcGFyYW1zIHRvICgwLCAwLCAwLCAwLCBnb2FsLngpXG4gIGZsb2F0IHAwID0gMC4wO1xuICBmbG9hdCBwMSA9IDAuMDtcbiAgZmxvYXQgcDIgPSAwLjA7XG4gIGZsb2F0IHAzID0gMC4wO1xuICBmbG9hdCBwNCA9IDAuMDtcbiAgZmxvYXQgcDUgPSAwLjA7XG4gIGZsb2F0IHNHID0gZ29hbC54O1xuXG4gIGlmIChzRyA8IDAuMSkgcmV0dXJuIHZlYzQoMC4wKTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IFJFTEFYQVRJT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgcDAgKz0gZF9LMDtcbiAgICBwMSArPSBkX2RLMDtcbiAgICBwMiArPSBkX2RkSzA7XG4gICAgcDUgKz0gZEdvYWwudztcbiAgICBnb2FsICs9IGRHb2FsO1xuICAgIFxuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBzRyk7XG4gICAgcDMgPSByZXN1bHQueDtcbiAgICBwNCA9IHJlc3VsdC55O1xuICAgIHNHID0gcmVzdWx0Lno7XG4gIH1cblxuICBnb2FsID0gb3JpZ2luYWxHb2FsO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7IGkrKykge1xuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBzRyk7XG4gICAgaWYgKHJlc3VsdC53ID09IDEuMCkge1xuICAgICAgcmVzdWx0LncgPSBzdGVwKDAuMCwgcmVzdWx0LnopO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwMyA9IHJlc3VsdC54O1xuICAgIHA0ID0gcmVzdWx0Lnk7XG4gICAgc0cgPSByZXN1bHQuejtcbiAgfVxuXG4gIHJldHVybiB2ZWM0KHAzLCBwNCwgc0csIDAuMCk7XG59XG5cbnZlYzQga2VybmVsKCkge1xuICBpdmVjMiBsYXR0aWNlSW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XG5cbiAgdmVjNCBzdGFydCA9IHZlYzQoMCwgMCwgMCwgY3VydlZlaGljbGUpO1xuICB2ZWM0IGVuZCA9IHRleGVsRmV0Y2gobGF0dGljZSwgbGF0dGljZUluZGV4ZXMsIDApO1xuXG4gIHJldHVybiBvcHRpbWl6ZShzdGFydCwgZW5kKTtcbn1cblxuYDtcblxuLy8gUXVpbnRpYyBzcGlyYWwgcGF0aCBvcHRpbWl6ZXJcbi8vICAgKiBTdGFydCBvZiBwYXRocyBpcyB0aGUgdmVoaWNsZSBwb3NlXG4vLyAgICAgKiB4LXBvcywgeS1wb3MsIGFuZCByb3RhdGlvbiBhcmVuJ3QgbmVlZGVkLCBzaW5jZSB0aGUgbGF0dGljZSBvcmlnaW4gaXMgdGhlIHZlaGljbGUgcG9zZVxuLy8gICAgICogU28gYXNzdW1lIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBhcmUgMFxuLy8gICAqIEVuZHMgb2YgcGF0aHMgYXJlIGFsbCBsYXRpdHVkZXMgd2l0aGluIHRoZSBmaXJzdCAoc3RhdGlvbkNvbm5lY3Rpdml0eSkgc3RhdGlvbnNcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogT1BUSU1JWkVfS0VSTkVMLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICdxdWludGljUGF0aHNGcm9tVmVoaWNsZScsIHJlYWQ6IHRydWUgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgIGN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHBvc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGN1cnZWZWhpY2xlOiBwb3NlLmN1cnYsXG4gICAgICAgIGRDdXJ2VmVoaWNsZTogcG9zZS5kQ3VydixcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogcG9zZS5kZEN1cnZcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4iLCJjb25zdCBTSEFSRURfU0hBREVSID0gYFxuXG5jb25zdCBmbG9hdCBzbWFsbFYgPSAwLjAxO1xudmVjNCBwYXRoU2FtcGxlc1sxMjhdO1xuZmxvYXQgcGF0aFNhbXBsZUN1cnZSYXRlc1sxMjhdO1xuXG5mbG9hdCBjYWxjdWxhdGVBY2NlbGVyYXRpb24oaW50IGluZGV4LCBmbG9hdCBpbml0aWFsVmVsb2NpdHlTcSwgZmxvYXQgZGlzdGFuY2UpIHtcbiAgaWYgKGluZGV4IDw9IDQpIHtcbiAgICAvLyBbYU1heEhhcmQsIGFNaW5IYXJkLCBhTWF4U29mdCwgYU1pblNvZnQsIDBdXG4gICAgcmV0dXJuIGFjY2VsZXJhdGlvblByb2ZpbGVzW2luZGV4XTtcbiAgfSBlbHNlIHtcbiAgICBmbG9hdCBmaW5hbFZlbG9jaXR5ID0gZmluYWxWZWxvY2l0eVByb2ZpbGVzW2luZGV4IC0gNV07XG4gICAgaWYgKGRpc3RhbmNlIDwgMC4wMDEpIHJldHVybiAwLjA7XG4gICAgcmV0dXJuIGNsYW1wKChmaW5hbFZlbG9jaXR5ICogZmluYWxWZWxvY2l0eSAtIGluaXRpYWxWZWxvY2l0eVNxKSAvICgyLjAgKiBkaXN0YW5jZSksIGFjY2VsZXJhdGlvblByb2ZpbGVzWzFdLCBhY2NlbGVyYXRpb25Qcm9maWxlc1swXSk7XG4gIH1cbn1cblxudmVjMiB4eTJzbCh2ZWM0IHh5dGspIHtcbiAgdmVjMiB4eSA9IHh5dGsueHkgKyByZWFyQXhsZVRvQ2VudGVyICogdmVjMihjb3MoeHl0ay56KSwgc2luKHh5dGsueikpO1xuICB2ZWMyIHh5VGV4Q29vcmRzID0gKHh5IC0geHlDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHh5c2xNYXAsIDApKSAvIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh4eXNsTWFwLCB4eVRleENvb3JkcykueHk7XG59XG5cbmZsb2F0IHNhbXBsZVN0YXRpY0Nvc3QodmVjNCB4eXRrKSB7XG4gIHZlYzIgc2wgPSB4eTJzbCh4eXRrKTtcbiAgdmVjMiBzbFRleENvb3JkcyA9IChzbCAtIHNsQ2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZShzbE9ic3RhY2xlR3JpZCwgMCkpIC8gdmVjMihzbEdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIGZsb2F0IG9ic3RhY2xlQ29zdCA9IHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIHNsVGV4Q29vcmRzKS5yO1xuXG4gIGlmIChvYnN0YWNsZUNvc3QgPj0gMC43NSkgcmV0dXJuIC0xLjA7IC8vIEluZmluaXRlIGNvc3RcblxuICBvYnN0YWNsZUNvc3QgPSBzdGVwKDAuMjUsIG9ic3RhY2xlQ29zdCkgKiBvYnN0YWNsZUhhemFyZENvc3Q7XG5cbiAgZmxvYXQgYWJzTGF0aXR1ZGUgPSBhYnMoc2wueSk7XG4gIGlmIChhYnNMYXRpdHVkZSA+PSBsYW5lU2hvdWxkZXJMYXRpdHVkZSkgcmV0dXJuIC0xLjA7XG5cbiAgZmxvYXQgbGFuZUNvc3QgPSBhYnMoYWJzTGF0aXR1ZGUgLSBsYW5lQ2VudGVyTGF0aXR1ZGUpICogbGFuZUNvc3RTbG9wZSArIHN0ZXAoMC4wLCAtc2wueSAqIHNpZ24obGFuZVByZWZlcmVuY2UpKSAqIGxhbmVQcmVmZXJlbmNlRGlzY291bnQ7XG5cbiAgcmV0dXJuIG9ic3RhY2xlQ29zdCArIGxhbmVDb3N0O1xufVxuXG5mbG9hdCBzYW1wbGVEeW5hbWljQ29zdCh2ZWM0IHh5dGssIGZsb2F0IHRpbWUsIGZsb2F0IHZlbG9jaXR5LCBmbG9hdCBhY2NlbGVyYXRpb24pIHtcbiAgdmVjMiBzbCA9IHh5MnNsKHh5dGspO1xuICB2ZWMyIHNsVGV4Q29vcmRzID0gKHNsIC0gc2xDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHNsRHluYW1pY09ic3RhY2xlR3JpZCwgMCkueHkpIC8gdmVjMihzbEdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIGZsb2F0IGR5bmFtaWNGcmFtZSA9IGZsb29yKHRpbWUgLyBkeW5hbWljRnJhbWVUaW1lKTtcblxuICBmbG9hdCBvYnN0YWNsZUNvc3QgPSB0ZXh0dXJlKHNsRHluYW1pY09ic3RhY2xlR3JpZCwgdmVjMyhzbFRleENvb3JkcywgZHluYW1pY0ZyYW1lKSkucjtcblxuICBpZiAob2JzdGFjbGVDb3N0ID4gMC43NSkgcmV0dXJuIC0xLjA7IC8vIEluZmluaXRlIGNvc3RcblxuICByZXR1cm4gc3RlcCgwLjI1LCBvYnN0YWNsZUNvc3QpICogb2JzdGFjbGVIYXphcmRDb3N0O1xufVxuXG5mbG9hdCBjYWxjdWxhdGVBdmVyYWdlU3RhdGljQ29zdChpbnQgbnVtU2FtcGxlcykge1xuICBmbG9hdCBhdmVyYWdlU3RhdGljQ29zdCA9IDAuMDtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIGZsb2F0IGNvc3QgPSBzYW1wbGVTdGF0aWNDb3N0KHBhdGhTYW1wbGVzW2ldKTtcblxuICAgIGlmIChjb3N0IDwgMC4wKSByZXR1cm4gY29zdDtcblxuICAgIGF2ZXJhZ2VTdGF0aWNDb3N0ICs9IGNvc3Q7XG4gIH1cblxuICBhdmVyYWdlU3RhdGljQ29zdCAvPSBmbG9hdChudW1TYW1wbGVzKTtcblxuICByZXR1cm4gYXZlcmFnZVN0YXRpY0Nvc3Q7XG59XG5cbmZsb2F0IGNhbGN1bGF0ZUF2ZXJhZ2VEeW5hbWljQ29zdChpbnQgbnVtU2FtcGxlcywgZmxvYXQgcGF0aExlbmd0aCwgZmxvYXQgaW5pdGlhbFRpbWUsIGZsb2F0IGluaXRpYWxWZWxvY2l0eSwgZmxvYXQgYWNjZWxlcmF0aW9uLCBmbG9hdCBhYmFuZG9uVGhyZXNob2xkKSB7XG4gIGZsb2F0IHMgPSAwLjA7XG4gIGZsb2F0IGRzID0gcGF0aExlbmd0aCAvIGZsb2F0KG51bVNhbXBsZXMgLSAxKTtcbiAgZmxvYXQgYXZlcmFnZUR5bmFtaWNDb3N0ID0gMC4wO1xuICBmbG9hdCBtYXhWZWxvY2l0eSA9IDAuMDtcbiAgZmxvYXQgbWF4TGF0ZXJhbEFjY2VsZXJhdGlvbiA9IDAuMDtcbiAgZmxvYXQgbnVtU2FtcGxlc19mID0gZmxvYXQobnVtU2FtcGxlcyk7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1TYW1wbGVzOyBpKyspIHtcbiAgICB2ZWM0IHBhdGhTYW1wbGUgPSBwYXRoU2FtcGxlc1tpXTsgLy8gdmVjNCh4LXBvcywgeS1wb3MsIHRoZXRhIChyb3RhdGlvbiksIGthcHBhIChjdXJ2YXR1cmUpKVxuXG4gICAgZmxvYXQgdmVsb2NpdHlTcSA9IDIuMCAqIGFjY2VsZXJhdGlvbiAqIHMgKyBpbml0aWFsVmVsb2NpdHkgKiBpbml0aWFsVmVsb2NpdHk7XG4gICAgZmxvYXQgdmVsb2NpdHkgPSBtYXgoc21hbGxWLCBzcXJ0KG1heCgwLjAsIHZlbG9jaXR5U3EpKSk7XG4gICAgbWF4VmVsb2NpdHkgPSBtYXgobWF4VmVsb2NpdHksIHZlbG9jaXR5KTtcbiAgICBtYXhMYXRlcmFsQWNjZWxlcmF0aW9uID0gbWF4KG1heExhdGVyYWxBY2NlbGVyYXRpb24sIGFicyhwYXRoU2FtcGxlLncgKiB2ZWxvY2l0eSAqIHZlbG9jaXR5KSk7XG5cbiAgICBmbG9hdCB0aW1lID0gMi4wICogcyAvIChpbml0aWFsVmVsb2NpdHkgKyB2ZWxvY2l0eSkgKyBpbml0aWFsVGltZTtcblxuICAgIGZsb2F0IGRDdXJ2ID0gcGF0aFNhbXBsZUN1cnZSYXRlc1tpXSAqIHZlbG9jaXR5O1xuICAgIGlmIChkQ3VydiA+IGRDdXJ2YXR1cmVNYXgpIHJldHVybiAtMS4wO1xuXG4gICAgZmxvYXQgY29zdCA9IHNhbXBsZUR5bmFtaWNDb3N0KHBhdGhTYW1wbGUsIHRpbWUsIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24pO1xuICAgIGlmIChjb3N0IDwgMC4wKSByZXR1cm4gY29zdDtcblxuICAgIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBjb3N0O1xuICAgIGlmIChhdmVyYWdlRHluYW1pY0Nvc3QgLyBudW1TYW1wbGVzX2YgPj0gYWJhbmRvblRocmVzaG9sZCkgcmV0dXJuIC0xLjA7XG5cbiAgICBzICs9IGRzO1xuICB9XG5cbiAgYXZlcmFnZUR5bmFtaWNDb3N0IC89IG51bVNhbXBsZXNfZjtcblxuICAvLyBBcHBseSBzcGVlZGluZyBwZW5hbGl0eSBpZiBhbnkgdmVsb2NpdHkgYWxvbmcgdGhlIHRyYWplY3RvcnkgaXMgb3ZlciB0aGUgc3BlZWQgbGltaXRcbiAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IHN0ZXAoc3BlZWRMaW1pdCwgbWF4VmVsb2NpdHkpICogc3BlZWRMaW1pdFBlbmFsdHk7XG5cbiAgLy8gQXBwbHkgaGFyZCBhY2NlbGVyYXRpb24vZGVjZWxlcmF0aW9uIHBlbmFsdGllcyBpZiB0aGUgYWNjZWxlcmF0aW9uL2RlY2VsZXJhdGlvbiBleGNlZWRzIHRoZSBzb2Z0IGxpbWl0c1xuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gc3RlcChhY2NlbGVyYXRpb25Qcm9maWxlc1syXSArIDAuMDAwMSwgYWNjZWxlcmF0aW9uKSAqIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5O1xuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gKDEuMCAtIHN0ZXAoYWNjZWxlcmF0aW9uUHJvZmlsZXNbM10sIGFjY2VsZXJhdGlvbikpICogaGFyZERlY2VsZXJhdGlvblBlbmFsdHk7XG5cbiAgLy8gUGVuYWxpemUgbGF0ZXJhbCBhY2NlbGVyYXRpb25cbiAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IHN0ZXAoc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdCwgbWF4TGF0ZXJhbEFjY2VsZXJhdGlvbikgKiBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk7XG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBsaW5lYXJMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eSAqIG1heExhdGVyYWxBY2NlbGVyYXRpb247XG5cbiAgcmV0dXJuIGF2ZXJhZ2VEeW5hbWljQ29zdDtcbn1cblxudmVjMyBjYWxjdWxhdGVBVlQoaW50IGFjY2VsZXJhdGlvbkluZGV4LCBmbG9hdCBpbml0aWFsVmVsb2NpdHksIGZsb2F0IGluaXRpYWxUaW1lLCBmbG9hdCBwYXRoTGVuZ3RoKSB7XG4gIGZsb2F0IGluaXRpYWxWZWxvY2l0eVNxID0gaW5pdGlhbFZlbG9jaXR5ICogaW5pdGlhbFZlbG9jaXR5O1xuICBmbG9hdCBhY2NlbGVyYXRpb24gPSBjYWxjdWxhdGVBY2NlbGVyYXRpb24oYWNjZWxlcmF0aW9uSW5kZXgsIGluaXRpYWxWZWxvY2l0eVNxLCBwYXRoTGVuZ3RoKTtcblxuICBmbG9hdCBmaW5hbFZlbG9jaXR5U3EgPSAyLjAgKiBhY2NlbGVyYXRpb24gKiBwYXRoTGVuZ3RoICsgaW5pdGlhbFZlbG9jaXR5U3E7XG4gIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBtYXgoc21hbGxWLCBzcXJ0KG1heCgwLjAsIGZpbmFsVmVsb2NpdHlTcSkpKTtcblxuICBmbG9hdCBmaW5hbFRpbWUgPSBpbml0aWFsVGltZTtcblxuICBpZiAoYWNjZWxlcmF0aW9uID09IDAuMCkge1xuICAgIGZpbmFsVGltZSArPSBwYXRoTGVuZ3RoIC8gZmluYWxWZWxvY2l0eTtcbiAgfSBlbHNlIGlmIChmaW5hbFZlbG9jaXR5U3EgPD0gMC4wKSB7IC8vIENhbGN1bGF0ZSBmaW5hbCB0aW1lIGlmIHRoZSB2ZWhpY2xlIHN0b3BzIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSB0cmFqZWN0b3J5XG4gICAgZmxvYXQgZGlzdGFuY2VMZWZ0ID0gcGF0aExlbmd0aCAtIChzbWFsbFYgKiBzbWFsbFYgLSBpbml0aWFsVmVsb2NpdHlTcSkgLyAoMi4wICogYWNjZWxlcmF0aW9uKTtcbiAgICBmaW5hbFRpbWUgKz0gKGZpbmFsVmVsb2NpdHkgLSBpbml0aWFsVmVsb2NpdHkpIC8gYWNjZWxlcmF0aW9uICsgZGlzdGFuY2VMZWZ0IC8gc21hbGxWO1xuICB9IGVsc2Uge1xuICAgIGZpbmFsVGltZSArPSAyLjAgKiBwYXRoTGVuZ3RoIC8gKGZpbmFsVmVsb2NpdHkgKyBpbml0aWFsVmVsb2NpdHkpO1xuICB9XG5cbiAgcmV0dXJuIHZlYzMoYWNjZWxlcmF0aW9uLCBmaW5hbFZlbG9jaXR5LCBmaW5hbFRpbWUpO1xufVxuXG5gO1xuXG5jb25zdCBTQU1QTEVfQ1VCSUNfUEFUSF9GTiA9IGBcblxuaW50IHNhbXBsZUN1YmljUGF0aCh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCwgdmVjNCBjdWJpY1BhdGhQYXJhbXMpIHtcbiAgZmxvYXQgcDAgPSBzdGFydC53O1xuICBmbG9hdCBwMSA9IGN1YmljUGF0aFBhcmFtcy54O1xuICBmbG9hdCBwMiA9IGN1YmljUGF0aFBhcmFtcy55O1xuICBmbG9hdCBwMyA9IGVuZC53O1xuICBmbG9hdCBzRyA9IGN1YmljUGF0aFBhcmFtcy56O1xuXG4gIGlmIChzRyA8PSAwLjApIHJldHVybiAwO1xuXG4gIGludCBudW1TYW1wbGVzID0gaW50KGNlaWwoc0cgLyBwYXRoU2FtcGxpbmdTdGVwKSkgKyAxO1xuXG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gIGZsb2F0IGEgPSBwMDtcbiAgZmxvYXQgYiA9ICgtNS41ICogcDAgKyA5LjAgKiBwMSAtIDQuNSAqIHAyICsgcDMpIC8gc0c7XG4gIGZsb2F0IGMgPSAoOS4wICogcDAgLSAyMi41ICogcDEgKyAxOC4wICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xuICBmbG9hdCBkID0gKC00LjUgKiAocDAgLSAzLjAgKiBwMSArIDMuMCAqIHAyIC0gcDMpKSAvIHNHXzM7XG5cbiAgcGF0aFNhbXBsZXNbMF0gPSBzdGFydDtcblxuICBmbG9hdCBkcyA9IHNHIC8gZmxvYXQobnVtU2FtcGxlcyAtIDEpO1xuICBmbG9hdCBzID0gZHM7XG4gIHZlYzIgZHh5ID0gdmVjMigwKTtcbiAgdmVjMiBwcmV2Q29zU2luID0gdmVjMihjb3Moc3RhcnQueiksIHNpbihzdGFydC56KSk7XG5cbiAgZm9yIChpbnQgaSA9IDE7IGkgPCBudW1TYW1wbGVzOyBpKyspIHtcbiAgICBmbG9hdCByb3QgPSAoKChkICogcyAvIDQuMCArIGMgLyAzLjApICogcyArIGIgLyAyLjApICogcyArIGEpICogcyArIHN0YXJ0Lno7XG4gICAgZmxvYXQgY3VydiA9ICgoZCAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuXG4gICAgdmVjMiBjb3NTaW4gPSB2ZWMyKGNvcyhyb3QpLCBzaW4ocm90KSk7XG4gICAgZHh5ID0gZHh5ICogdmVjMihmbG9hdChpIC0gMSkgLyBmbG9hdChpKSkgKyAoY29zU2luICsgcHJldkNvc1NpbikgLyB2ZWMyKDIgKiBpKTtcblxuICAgIHBhdGhTYW1wbGVzW2ldID0gdmVjNChkeHkgKiB2ZWMyKHMpICsgc3RhcnQueHksIHJvdCwgY3Vydik7XG4gICAgcGF0aFNhbXBsZUN1cnZSYXRlc1tpXSA9IGIgKyBzICogKDIuMCAqIGMgKyAzLjAgKiBkICogcyk7XG5cbiAgICBzICs9IGRzO1xuICAgIHByZXZDb3NTaW4gPSBjb3NTaW47XG4gIH1cblxuICByZXR1cm4gbnVtU2FtcGxlcztcbn1cblxuYDtcblxuY29uc3QgU0FNUExFX1FVSU5USUNfUEFUSF9GTiA9IGBcblxuaW50IHNhbXBsZVF1aW50aWNQYXRoKHZlYzQgc3RhcnQsIHZlYzQgZW5kLCB2ZWM0IHF1aW50aWNQYXRoUGFyYW1zKSB7XG4gIGZsb2F0IHAwID0gc3RhcnQudztcbiAgZmxvYXQgcDEgPSBkQ3VydlZlaGljbGU7XG4gIGZsb2F0IHAyID0gZGRDdXJ2VmVoaWNsZTtcbiAgZmxvYXQgcDMgPSBxdWludGljUGF0aFBhcmFtcy54O1xuICBmbG9hdCBwNCA9IHF1aW50aWNQYXRoUGFyYW1zLnk7XG4gIGZsb2F0IHA1ID0gZW5kLnc7XG4gIGZsb2F0IHNHID0gcXVpbnRpY1BhdGhQYXJhbXMuejtcblxuICBpZiAoc0cgPD0gMC4wKSByZXR1cm4gMDtcblxuICBpbnQgbnVtU2FtcGxlcyA9IGludChjZWlsKHNHIC8gcGF0aFNhbXBsaW5nU3RlcCkpICsgMTtcblxuICBmbG9hdCBzR18yID0gc0cgKiBzRztcbiAgZmxvYXQgc0dfMyA9IHNHXzIgKiBzRztcblxuICBmbG9hdCBhID0gcDA7XG4gIGZsb2F0IGIgPSBwMTtcbiAgZmxvYXQgYyA9IHAyIC8gMi4wO1xuICBmbG9hdCBkID0gKC03MS44NzUgKiBwMCArIDgxLjAgKiBwMyAtIDEwLjEyNSAqIHA0ICsgcDUgLSAyMS4yNSAqIHAxICogc0cgLSAyLjc1ICogcDIgKiBzR18yKSAvIHNHXzM7XG4gIGZsb2F0IGUgPSAoMTY2LjUgKiBwMCAtIDIwMi41ICogcDMgKyA0MC41ICogcDQgLSA0LjUgKiBwNSArIDQ1LjAgKiBwMSAqIHNHICsgNC41ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMik7XG4gIGZsb2F0IGYgPSAoLTk1LjYyNSAqIHAwICsgMTIxLjUgKiBwMyAtIDMwLjM3NSAqIHA0ICsgNC41ICogcDUgLSAyNC43NSAqIHAxICogc0cgLSAyLjI1ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMyk7XG5cbiAgcGF0aFNhbXBsZXNbMF0gPSBzdGFydDtcblxuICBmbG9hdCBkcyA9IHNHIC8gZmxvYXQobnVtU2FtcGxlcyAtIDEpO1xuICBmbG9hdCBzID0gZHM7XG4gIHZlYzIgZHh5ID0gdmVjMigwKTtcbiAgdmVjMiBwcmV2Q29zU2luID0gdmVjMihjb3Moc3RhcnQueiksIHNpbihzdGFydC56KSk7XG5cbiAgZm9yIChpbnQgaSA9IDE7IGkgPCBudW1TYW1wbGVzOyBpKyspIHtcbiAgICBmbG9hdCByb3QgPSAoKCgoKGYgKiBzIC8gNi4wICsgZSAvIDUuMCkgKiBzICsgZCAvIDQuMCkgKiBzICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzICsgc3RhcnQuejtcbiAgICBmbG9hdCBjdXJ2ID0gKCgoKGYgKiBzICsgZSkgKiBzICsgZCkgKiBzICsgYykgKiBzICsgYikgKiBzICsgYTtcblxuICAgIHZlYzIgY29zU2luID0gdmVjMihjb3Mocm90KSwgc2luKHJvdCkpO1xuICAgIGR4eSA9IGR4eSAqIHZlYzIoZmxvYXQoaSAtIDEpIC8gZmxvYXQoaSkpICsgKGNvc1NpbiArIHByZXZDb3NTaW4pIC8gdmVjMigyICogaSk7XG5cbiAgICBwYXRoU2FtcGxlc1tpXSA9IHZlYzQoZHh5ICogdmVjMihzKSArIHN0YXJ0Lnh5LCByb3QsIGN1cnYpO1xuICAgIHBhdGhTYW1wbGVDdXJ2UmF0ZXNbaV0gPSBiICsgcyAqICgyLjAgKiBjICsgcyAqICgzLjAgKiBkICsgcyAqICg0LjAgKiBlICsgNS4wICogZiAqIHMpKSk7XG5cbiAgICBzICs9IGRzO1xuICAgIHByZXZDb3NTaW4gPSBjb3NTaW47XG4gIH1cblxuICByZXR1cm4gbnVtU2FtcGxlcztcbn1cblxuYDtcblxuY29uc3QgTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyA9IDg7XG5jb25zdCBOVU1fVkVMT0NJVFlfUkFOR0VTID0gNDtcbmNvbnN0IE5VTV9USU1FX1JBTkdFUyA9IDI7XG5cbmNvbnN0IFNIQVJFRF9VTklGT1JNUyA9IHtcbiAgeHlzbE1hcDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xPYnN0YWNsZUdyaWREaWxhdGVkJyB9LFxuICBzbER5bmFtaWNPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xEeW5hbWljT2JzdGFjbGVHcmlkJywgdGV4dHVyZVR5cGU6ICcyREFycmF5JyB9LFxuICBhY2NlbGVyYXRpb25Qcm9maWxlczogeyB0eXBlOiAnZmxvYXQnLCBsZW5ndGg6IDUgfSxcbiAgZmluYWxWZWxvY2l0eVByb2ZpbGVzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogMyB9LFxuICB4eUNlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxuICB4eUdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHNsQ2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gIHNsR3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCd9LFxuICBsYW5lQ2VudGVyTGF0aXR1ZGU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVTaG91bGRlckxhdGl0dWRlOiB7IHR5cGU6ICdmbG9hdCd9LFxuICBsYW5lQ29zdFNsb3BlOiB7IHR5cGU6ICdmbG9hdCd9LFxuICBsYW5lUHJlZmVyZW5jZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIGxhbmVQcmVmZXJlbmNlRGlzY291bnQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBvYnN0YWNsZUhhemFyZENvc3Q6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBzcGVlZExpbWl0OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgc3BlZWRMaW1pdFBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBoYXJkQWNjZWxlcmF0aW9uUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIGhhcmREZWNlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHNvZnRMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIGxpbmVhckxhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgZEN1cnZhdHVyZU1heDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHBhdGhTYW1wbGluZ1N0ZXA6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICByZWFyQXhsZVRvQ2VudGVyOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgZHluYW1pY0ZyYW1lVGltZTogeyB0eXBlOiAnZmxvYXQnIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVW5pZm9ybVZhbHVlcyhjb25maWcsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBhY2NlbGVyYXRpb25Qcm9maWxlczogWzMuNSwgLTYuNSwgMi4wLCAtMy4wLCAwXSxcbiAgICBmaW5hbFZlbG9jaXR5UHJvZmlsZXM6IFswLjk5OSAqIGNvbmZpZy5zcGVlZExpbWl0LCAxLjAsIDAuMDFdLFxuICAgIHh5Q2VudGVyUG9pbnQ6IFt4eUNlbnRlclBvaW50LngsIHh5Q2VudGVyUG9pbnQueV0sXG4gICAgeHlHcmlkQ2VsbFNpemU6IGNvbmZpZy54eUdyaWRDZWxsU2l6ZSxcbiAgICBzbENlbnRlclBvaW50OiBbc2xDZW50ZXJQb2ludC54LCBzbENlbnRlclBvaW50LnldLFxuICAgIHNsR3JpZENlbGxTaXplOiBjb25maWcuc2xHcmlkQ2VsbFNpemUsXG4gICAgbGFuZUNlbnRlckxhdGl0dWRlOiBjb25maWcubGFuZUNlbnRlckxhdGl0dWRlLFxuICAgIGxhbmVTaG91bGRlckxhdGl0dWRlOiBjb25maWcubGFuZVNob3VsZGVyTGF0aXR1ZGUsXG4gICAgbGFuZUNvc3RTbG9wZTogY29uZmlnLmxhbmVDb3N0U2xvcGUsXG4gICAgbGFuZVByZWZlcmVuY2U6IGNvbmZpZy5sYW5lUHJlZmVyZW5jZSxcbiAgICBsYW5lUHJlZmVyZW5jZURpc2NvdW50OiBjb25maWcubGFuZVByZWZlcmVuY2VEaXNjb3VudCxcbiAgICBvYnN0YWNsZUhhemFyZENvc3Q6IGNvbmZpZy5vYnN0YWNsZUhhemFyZENvc3QsXG4gICAgc3BlZWRMaW1pdDogY29uZmlnLnNwZWVkTGltaXQsXG4gICAgc3BlZWRMaW1pdFBlbmFsdHk6IGNvbmZpZy5zcGVlZExpbWl0UGVuYWx0eSxcbiAgICBoYXJkQWNjZWxlcmF0aW9uUGVuYWx0eTogY29uZmlnLmhhcmRBY2NlbGVyYXRpb25QZW5hbHR5LFxuICAgIGhhcmREZWNlbGVyYXRpb25QZW5hbHR5OiBjb25maWcuaGFyZERlY2VsZXJhdGlvblBlbmFsdHksXG4gICAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdDogY29uZmlnLnNvZnRMYXRlcmFsQWNjZWxlcmF0aW9uTGltaXQsXG4gICAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5OiBjb25maWcuc29mdExhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5LFxuICAgIGxpbmVhckxhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5OiBjb25maWcubGluZWFyTGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHksXG4gICAgZEN1cnZhdHVyZU1heDogY29uZmlnLmRDdXJ2YXR1cmVNYXgsXG4gICAgcGF0aFNhbXBsaW5nU3RlcDogY29uZmlnLnBhdGhTYW1wbGluZ1N0ZXAsXG4gICAgcmVhckF4bGVUb0NlbnRlcjogY29uZmlnLnJlYXJBeGxlVG9DZW50ZXIsXG4gICAgZHluYW1pY0ZyYW1lVGltZTogZHluYW1pY0ZyYW1lVGltZVxuICB9O1xufVxuXG5leHBvcnQge1xuICBTSEFSRURfU0hBREVSLFxuICBTQU1QTEVfQ1VCSUNfUEFUSF9GTixcbiAgU0FNUExFX1FVSU5USUNfUEFUSF9GTixcblxuICBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICBOVU1fVkVMT0NJVFlfUkFOR0VTLFxuICBOVU1fVElNRV9SQU5HRVMsXG5cbiAgU0hBUkVEX1VOSUZPUk1TLFxuICBidWlsZFVuaWZvcm1WYWx1ZXNcbn1cbiIsImltcG9ydCB7IFNIQVJFRF9TSEFERVIsIFNBTVBMRV9DVUJJQ19QQVRIX0ZOLCBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOLCBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLCBTSEFSRURfVU5JRk9STVMsIGJ1aWxkVW5pZm9ybVZhbHVlcyB9IGZyb20gXCIuL2dyYXBoU2VhcmNoU2hhcmVkLmpzXCI7XG5cbmZ1bmN0aW9uIGZyb21WZWhpY2xlUGF0aENvc3RzS2VybmVsKHBhdGhUeXBlKSB7XG4gIHJldHVybiBTSEFSRURfU0hBREVSICsgKHBhdGhUeXBlID09ICdjdWJpYycgPyBTQU1QTEVfQ1VCSUNfUEFUSF9GTiA6IFNBTVBMRV9RVUlOVElDX1BBVEhfRk4pICtcblxuYFxuXG4vKiBDYWxjdWxhdGUgY29zdCBvZiBhIHtjdWJpY3xxdWludGljfSBwYXRoIGZyb20gdmVoaWNsZSB0byAoc3RhdGlvbkNvbm5lY3Rpdml0eSAqIG51bUxhdGl0dWRlcyAqIG51bUFjY2VsZXJhdGlvbnMpIG5vZGVzXG4gKiAgIHdpZHRoOiBudW1MYXRpdHVkZXNcbiAqICAgaGVpZ2h0OiBzdGF0aW9uICogbnVtQWNjZWxlcmF0aW9uc1xuICovXG52ZWM0IGtlcm5lbCgpIHtcbiAgaXZlYzIgaW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XG5cbiAgaW50IGxhdGl0dWRlID0gaW5kZXhlcy54O1xuICBpbnQgc3RhdGlvbiA9IGluZGV4ZXMueSAvIG51bUFjY2VsZXJhdGlvbnM7XG4gIGludCBhY2NlbGVyYXRpb25JbmRleCA9IGludChtb2QoZmxvYXQoaW5kZXhlcy55KSwgZmxvYXQobnVtQWNjZWxlcmF0aW9ucykpKTtcblxuICB2ZWM0IHBhdGhTdGFydCA9IHZlYzQoMCwgMCwgMCwgY3VydlZlaGljbGUpO1xuICB2ZWM0IHBhdGhFbmQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGl2ZWMyKGxhdGl0dWRlLCBzdGF0aW9uKSwgMCk7XG5cbiAgdmVjNCBwYXRoUGFyYW1zID0gdGV4ZWxGZXRjaChwYXRoc0Zyb21WZWhpY2xlLCBpdmVjMihsYXRpdHVkZSwgc3RhdGlvbiksIDApO1xuXG4gIC8vIElmIHRoZSBwYXRoIGRpZG4ndCBjb252ZXJnZVxuICBpZiAocGF0aFBhcmFtcy53ID09IDAuMCkgcmV0dXJuIHZlYzQoLTEpO1xuXG4gIGludCBudW1TYW1wbGVzID0gJHtwYXRoVHlwZSA9PSAnY3ViaWMnID8gJ3NhbXBsZUN1YmljUGF0aCcgOiAnc2FtcGxlUXVpbnRpY1BhdGgnfShwYXRoU3RhcnQsIHBhdGhFbmQsIHBhdGhQYXJhbXMpO1xuICBmbG9hdCBwYXRoTGVuZ3RoID0gcGF0aFBhcmFtcy56O1xuXG4gIGlmIChudW1TYW1wbGVzIDwgMikgcmV0dXJuIHZlYzQoLTEpO1xuXG4gIGZsb2F0IGF2ZXJhZ2VTdGF0aWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZVN0YXRpY0Nvc3QobnVtU2FtcGxlcyk7XG4gIGlmIChhdmVyYWdlU3RhdGljQ29zdCA8IDAuMCkgcmV0dXJuIHZlYzQoLTEpO1xuXG4gIGludCBzbEluZGV4ID0gc3RhdGlvbiAqIGtlcm5lbFNpemUueCArIGxhdGl0dWRlO1xuICBmbG9hdCBoeXN0ZXJlc2lzQWRqdXN0bWVudCA9IChzbEluZGV4ID09IGZpcnN0TGF0dGljZVBvaW50IHx8IHNsSW5kZXggPT0gc2Vjb25kTGF0dGljZVBvaW50KSA/ICAwLjAgOiBoeXN0ZXJlc2lzRGlzY291bnQ7XG4gIGF2ZXJhZ2VTdGF0aWNDb3N0ICs9IGh5c3RlcmVzaXNBZGp1c3RtZW50O1xuXG4gIHZlYzMgYXZ0ID0gY2FsY3VsYXRlQVZUKGFjY2VsZXJhdGlvbkluZGV4LCB2ZWxvY2l0eVZlaGljbGUsIDAuMCwgcGF0aExlbmd0aCk7XG4gIGZsb2F0IGFjY2VsZXJhdGlvbiA9IGF2dC54O1xuICBmbG9hdCBmaW5hbFZlbG9jaXR5ID0gYXZ0Lnk7XG4gIGZsb2F0IGZpbmFsVGltZSA9IGF2dC56O1xuXG4gIGZsb2F0IGF2ZXJhZ2VEeW5hbWljQ29zdCA9IGNhbGN1bGF0ZUF2ZXJhZ2VEeW5hbWljQ29zdChudW1TYW1wbGVzLCBwYXRoTGVuZ3RoLCAwLjAsIHZlbG9jaXR5VmVoaWNsZSwgYWNjZWxlcmF0aW9uLCAxLjAgLyAwLjApO1xuICBpZiAoYXZlcmFnZUR5bmFtaWNDb3N0IDwgMC4wKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk7XG5cbiAgLy8gVGhlIGNvc3Qgb2YgYSB0cmFqZWN0b3J5IGlzIHRoZSBhdmVyYWdlIHNhbXBsZSBjb3N0IHNjYWxlZCBieSB0aGUgcGF0aCBsZW5ndGhcbiAgZmxvYXQgdG90YWxDb3N0ID0gKGF2ZXJhZ2VTdGF0aWNDb3N0ICsgYXZlcmFnZUR5bmFtaWNDb3N0ICsgJHtwYXRoVHlwZSA9PSAnY3ViaWMnID8gJyhjdWJpY1BhdGhQZW5hbHR5ICogdmVsb2NpdHlWZWhpY2xlICogdmVsb2NpdHlWZWhpY2xlKScgOiAnMC4wJ30pICogcGF0aExlbmd0aDtcbiAgJHtwYXRoVHlwZSAhPSAnY3ViaWMnID8gJ3RvdGFsQ29zdCA9IC0xLjA7JyA6ICcnfVxuXG4gIHJldHVybiB2ZWM0KHRvdGFsQ29zdCwgZmluYWxWZWxvY2l0eSwgZmluYWxUaW1lLCAke3BhdGhUeXBlID09ICdjdWJpYycgPyAnLTInIDogJy0xJ30pO1xufVxuXG5gO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGtlcm5lbDogZnJvbVZlaGljbGVQYXRoQ29zdHNLZXJuZWwoJ2N1YmljJyksXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnY3ViaWNQYXRoRnJvbVZlaGljbGVDb3N0cycgfSxcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIFNIQVJFRF9VTklGT1JNUywge1xuICAgICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgICAgcGF0aHNGcm9tVmVoaWNsZTogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdjdWJpY1BhdGhzRnJvbVZlaGljbGUnIH0sXG4gICAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgIGN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgY3ViaWNQYXRoUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2VybmVsOiBmcm9tVmVoaWNsZVBhdGhDb3N0c0tlcm5lbCgncXVpbnRpYycpLFxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ3F1aW50aWNQYXRoRnJvbVZlaGljbGVDb3N0cycgfSxcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIFNIQVJFRF9VTklGT1JNUywge1xuICAgICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgICAgcGF0aHNGcm9tVmVoaWNsZTogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdxdWludGljUGF0aHNGcm9tVmVoaWNsZScgfSxcbiAgICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIHZlbG9jaXR5VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgIGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgZGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHBvc2UsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGZpcnN0TGF0dGljZVBvaW50LCBzZWNvbmRMYXR0aWNlUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHkgKiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRVbmlmb3JtVmFsdWVzKGNvbmZpZywgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZHluYW1pY0ZyYW1lVGltZSksIHtcbiAgICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogZmlyc3RMYXR0aWNlUG9pbnQsXG4gICAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiBzZWNvbmRMYXR0aWNlUG9pbnQsXG4gICAgICAgICAgdmVsb2NpdHlWZWhpY2xlOiBwb3NlLnZlbG9jaXR5LFxuICAgICAgICAgIGN1cnZWZWhpY2xlOiBwb3NlLmN1cnYsXG4gICAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyxcbiAgICAgICAgICBjdWJpY1BhdGhQZW5hbHR5OiBjb25maWcuY3ViaWNQYXRoUGVuYWx0eSxcbiAgICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IGNvbmZpZy5oeXN0ZXJlc2lzRGlzY291bnQsXG4gICAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogY29uZmlnLmFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSAqIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsXG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xuICAgICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiBmaXJzdExhdHRpY2VQb2ludCxcbiAgICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHNlY29uZExhdHRpY2VQb2ludCxcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXG4gICAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcbiAgICAgICAgICBkQ3VydlZlaGljbGU6IHBvc2UuZEN1cnYsXG4gICAgICAgICAgZGRDdXJ2VmVoaWNsZTogcG9zZS5kZEN1cnYsXG4gICAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyxcbiAgICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IGNvbmZpZy5oeXN0ZXJlc2lzRGlzY291bnQsXG4gICAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogY29uZmlnLmFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICBdO1xuICB9XG59XG4iLCIvKiBTdGF0ZSBMYXR0aWNlIENvc3QgTWFwXG4gKiBcbiAqIDUtZGltZW5zaW9uYWwgbm9kZTogc3RhdGlvbiwgbGF0aXR1ZGUsIGFjY2VsZXJhdGlvbiBwcm9maWxlLCB2ZWxvY2l0eSwgdGltZVxuICpcbiAqIEEgZHJhdyBjYWxsIHBlciBzdGF0aW9uIHNcbiAqICAgKiBJbnB1dCB0byBrZXJuZWw6IGxhdGl0dWRlIGwsIGFjY2VsZXJhdGlvbiBwcm9maWxlIGEsIHZlbG9jaXR5IHJhbmdlIHYsIHRpbWUgcmFuZ2UgdFxuICogICAqIEZpbmQgYWxsIFNMIHZlcnRpY2VzIHRoYXQgY2FuIGNvbm5lY3QgdG8gdGhpcyBub2RlXG4gKiAgICogRm9yIGVhY2ggb2YgdGhvc2UgdmVydGljZXMsIGNoZWNrIGlmIGFueSB0ZXJtaW5hdGUgaW4gdGhpcyBzcGVjaWZpYyB2ZWxvY2l0eSBhbmQgdGltZSByYW5nZVxuICogICAgICogQmFzZWQgb24gaW5pdGlhbCB2ZWxvY2l0eSwgaW5pdGlhbCB0aW1lLCBhbmQgYWNjZWxlcmF0aW9uXG4gKiAgICAgKiBFYWNoIGNvbm5lY3RlZCBTTCB2ZXJ0ZXggc2hvdWxkIGhhdmUgYSAqIHYgKiB0IG5vZGVzIHRoYXQgY291bGQgcG9zc2libHkgdGVybWluYXRlIGF0IHRoaXMgbm9kZVxuICogICAqIEZvciBhbGwgdmFsaWQgZWRnZXMsIGZpbmQgdGhlIG9uZSB3aXRoIHRoZSBsb3dlc3QgY29zdFxuICpcbiAqIElucHV0OlxuICogICAqIDJEIHRleHR1cmUgYXJyYXkgY29zdCBtYXBcbiAqICAgICAqIEhlaWdodDogbnVtIG9mIGxhdGl0dWRlcyAofjIwKVxuICogICAgICogV2lkdGg6IG51bSBvZiBhY2NlbGVyYXRpb24gcHJvZmlsZXMgKiBudW0gb2YgdGltZSByYW5nZXMgKiBudW0gb2YgdmVsb2NpdHkgcmFuZ2VzICg4ICogMiAqIDQgPSB+NjQpXG4gKiAgICAgICAqIEEgZmxhdHRlbmVkIDNEIGFycmF5OlxuICogICAgICAgICBkMTogYWNjZWxlcmF0aW9uXG4gKiAgICAgICAgIGQyOiB2ZWxvY2l0eVxuICogICAgICAgICBkMzogdGltZVxuICogICAgICogTGF5ZXI6IG51bSBvZiBzdGF0aW9ucyAofjEwKVxuICogICBcbiAqIE91dHB1dDpcbiAqICAgKiAyRCB0ZXh0dXJlIHNsaWNlIG9mIHRoZSBuZXh0IHN0YXRpb24gaW4gdGhlIGlucHV0IDJEIHRleHR1cmUgYXJyYXkgY29zdCBtYXBcbiAqXG4gKiBDb3N0IE1hcCBFbGVtZW50czpcbiAqICAgKiBUcmF2ZXJzYWwgY29zdCBzbyBmYXJcbiAqICAgKiBFbmRpbmcgdmVsb2NpdHlcbiAqICAgKiBFbmRpbmcgdGltZVxuICogICAqIEluZGV4IG9mIHBhcmVudCBub2RlXG4gKlxuICogU2luY2Ugb25lIGN1YmljIHBhdGggY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIHRyYWplY3RvcmllcywgdGhleSBuZWVkIHRvIGJlIHByZS1vcHRpbWl6ZWQuXG4gKlxuICogUXVpbnRpYyBQYXRoczpcbiAqICAgU3RhdGlvbnMgMCB0aHJvdWdoIChudW1TdGF0aW9ucyAtIDEpIGNvcnJlc3BvbmQgdG8gdGhlIHN0YXRpb25zIG9uIHRoZSBsYXR0aWNlOyBob3dldmVyLFxuICogICBhIG5ldyBzdGF0aW9uIChzdGF0aW9uIC0xKSB3aWxsIGJlIHVzZWQgdG8gc2lnbmlmaXkgdGhlIHNpbmdsZSB2ZWhpY2xlIHBvc2Ugbm9kZS4gRWl0aGVyXG4gKiAgIGEgY3ViaWMgcGF0aCBvciBxdWludGljIHBhdGggY2FuIGJlIHVzZWQgdG8gY29ubmVjdCB0aGlzIHNpbmdsZSBub2RlIHRvIHRoZSBsYXR0aWNlXG4gKiAgIChkZXBlbmRpbmcgb24gdmVoaWNsZSB2ZWxvY2l0eSkuIEF0IHN0YXRpb24gLTEsIGxhdGl0dWRlIDAgd2lsbCBjb3JyZXNwb25kIHRvIGEgY3ViaWMgcGF0aCxcbiAqICAgYW5kIGxhdGl0dWRlIDEgd2lsbCBjb3JyZXNwb25kIHRvIGEgcXVpbnRpYyBwYXRoLiBBbGwgb3RoZXIgbGF0aXR1ZGVzIHdpbGwgYmUgc2tpcHBlZC5cbiAqL1xuXG5pbXBvcnQgeyBTSEFSRURfU0hBREVSLCBTQU1QTEVfQ1VCSUNfUEFUSF9GTiwgU0FNUExFX1FVSU5USUNfUEFUSF9GTiwgTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUywgTlVNX1ZFTE9DSVRZX1JBTkdFUywgTlVNX1RJTUVfUkFOR0VTLCBTSEFSRURfVU5JRk9STVMsIGJ1aWxkVW5pZm9ybVZhbHVlcyB9IGZyb20gXCIuL2dyYXBoU2VhcmNoU2hhcmVkLmpzXCI7XG5cbmNvbnN0IFNPTFZFX1NUQVRJT05fS0VSTkVMID1cbiAgU0hBUkVEX1NIQURFUiArXG4gIFNBTVBMRV9DVUJJQ19QQVRIX0ZOICtcbiAgU0FNUExFX1FVSU5USUNfUEFUSF9GTiArXG5cbmBcblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGluZGV4ZXMgPSBpdmVjMihrZXJuZWxQb3NpdGlvbiAqIHZlYzIoa2VybmVsU2l6ZSkpO1xuXG4gIGludCBsYXRpdHVkZSA9IGluZGV4ZXMueTtcblxuICBpbnQgbnVtUGVyVGltZSA9IG51bUFjY2VsZXJhdGlvbnMgKiBudW1WZWxvY2l0aWVzO1xuICBpbnQgdGltZUluZGV4ID0gaW5kZXhlcy54IC8gbnVtUGVyVGltZTtcbiAgaW5kZXhlcy54IC09IHRpbWVJbmRleCAqIG51bVBlclRpbWU7XG4gIGludCB2ZWxvY2l0eUluZGV4ID0gaW5kZXhlcy54IC8gbnVtQWNjZWxlcmF0aW9ucztcbiAgaW50IGFjY2VsZXJhdGlvbkluZGV4ID0gaW50KG1vZChmbG9hdChpbmRleGVzLngpLCBmbG9hdChudW1BY2NlbGVyYXRpb25zKSkpO1xuXG4gIGludCBtaW5MYXRpdHVkZSA9IG1heChsYXRpdHVkZSAtIGxhdGl0dWRlQ29ubmVjdGl2aXR5IC8gMiwgMCk7XG4gIGludCBtYXhMYXRpdHVkZSA9IG1pbihsYXRpdHVkZSArIGxhdGl0dWRlQ29ubmVjdGl2aXR5IC8gMiwgbnVtTGF0aXR1ZGVzIC0gMSk7XG5cbiAgaW50IHNsSW5kZXggPSBzdGF0aW9uICogbnVtTGF0aXR1ZGVzICsgbGF0aXR1ZGU7XG5cbiAgdmVjNCBwYXRoRW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihsYXRpdHVkZSwgc3RhdGlvbiksIDApO1xuXG4gIGZsb2F0IG1pblZlbG9jaXR5ID0gdmVsb2NpdHlSYW5nZXNbdmVsb2NpdHlJbmRleF07XG4gIGZsb2F0IG1heFZlbG9jaXR5ID0gdmVsb2NpdHlSYW5nZXNbdmVsb2NpdHlJbmRleCArIDFdO1xuXG4gIGZsb2F0IG1pblRpbWUgPSB0aW1lUmFuZ2VzW3RpbWVJbmRleF07XG4gIGZsb2F0IG1heFRpbWUgPSB0aW1lUmFuZ2VzW3RpbWVJbmRleCArIDFdO1xuXG4gIHZlYzQgYmVzdFRyYWplY3RvcnkgPSB2ZWM0KC0xKTsgLy8gLTEgbWVhbnMgaW5maW5pdGUgY29zdFxuICBmbG9hdCBiZXN0VGVybWluYWxDb3N0ID0gMS4wIC8gMC4wO1xuXG4gIGZsb2F0IGh5c3RlcmVzaXNBZGp1c3RtZW50ID0gKHNsSW5kZXggPT0gZmlyc3RMYXR0aWNlUG9pbnQgfHwgc2xJbmRleCA9PSBzZWNvbmRMYXR0aWNlUG9pbnQpID8gIDAuMCA6IGh5c3RlcmVzaXNEaXNjb3VudDtcblxuICBmb3IgKGludCBwcmV2U3RhdGlvbiA9IG1heChzdGF0aW9uIC0gc3RhdGlvbkNvbm5lY3Rpdml0eSwgMCk7IHByZXZTdGF0aW9uIDwgc3RhdGlvbjsgcHJldlN0YXRpb24rKykge1xuICAgIGludCBzdGF0aW9uQ29ubmVjdGl2aXR5SW5kZXggPSBwcmV2U3RhdGlvbiAtIHN0YXRpb24gKyBzdGF0aW9uQ29ubmVjdGl2aXR5O1xuXG4gICAgZm9yIChpbnQgcHJldkxhdGl0dWRlID0gbWluTGF0aXR1ZGU7IHByZXZMYXRpdHVkZSA8PSBtYXhMYXRpdHVkZTsgcHJldkxhdGl0dWRlKyspIHtcbiAgICAgIGludCBsYXRpdHVkZUNvbm5lY3Rpdml0eUluZGV4ID0gcHJldkxhdGl0dWRlIC0gbGF0aXR1ZGUgKyBsYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDI7XG4gICAgICBpbnQgY29ubmVjdGl2aXR5SW5kZXggPSBzdGF0aW9uQ29ubmVjdGl2aXR5SW5kZXggKiBsYXRpdHVkZUNvbm5lY3Rpdml0eSArIGxhdGl0dWRlQ29ubmVjdGl2aXR5SW5kZXg7XG5cbiAgICAgIHZlYzQgcGF0aFN0YXJ0ID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihwcmV2TGF0aXR1ZGUsIHByZXZTdGF0aW9uKSwgMCk7XG4gICAgICB2ZWM0IGN1YmljUGF0aFBhcmFtcyA9IHRleGVsRmV0Y2goY3ViaWNQYXRocywgaXZlYzIoc2xJbmRleCwgY29ubmVjdGl2aXR5SW5kZXgpLCAwKTtcblxuICAgICAgLy8gSWYgdGhlIHBhdGggZGlkbid0IGNvbnZlcmdlXG4gICAgICBpZiAoY3ViaWNQYXRoUGFyYW1zLncgPT0gMC4wKSBjb250aW51ZTtcblxuICAgICAgaW50IG51bVNhbXBsZXMgPSBzYW1wbGVDdWJpY1BhdGgocGF0aFN0YXJ0LCBwYXRoRW5kLCBjdWJpY1BhdGhQYXJhbXMpO1xuICAgICAgZmxvYXQgcGF0aExlbmd0aCA9IGN1YmljUGF0aFBhcmFtcy56O1xuXG4gICAgICBpZiAobnVtU2FtcGxlcyA8IDIpIGNvbnRpbnVlO1xuXG4gICAgICBmbG9hdCBhdmVyYWdlU3RhdGljQ29zdCA9IGNhbGN1bGF0ZUF2ZXJhZ2VTdGF0aWNDb3N0KG51bVNhbXBsZXMpO1xuICAgICAgaWYgKGF2ZXJhZ2VTdGF0aWNDb3N0IDwgMC4wKSBjb250aW51ZTtcblxuICAgICAgYXZlcmFnZVN0YXRpY0Nvc3QgKz0gaHlzdGVyZXNpc0FkanVzdG1lbnQ7XG5cbiAgICAgIGlmIChhdmVyYWdlU3RhdGljQ29zdCAqIHBhdGhMZW5ndGggPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XG5cbiAgICAgIGZvciAoaW50IHByZXZWZWxvY2l0eSA9IDA7IHByZXZWZWxvY2l0eSA8IG51bVZlbG9jaXRpZXM7IHByZXZWZWxvY2l0eSsrKSB7XG4gICAgICAgIGZvciAoaW50IHByZXZUaW1lID0gMDsgcHJldlRpbWUgPCBudW1UaW1lczsgcHJldlRpbWUrKykge1xuICAgICAgICAgIGZvciAoaW50IHByZXZBY2NlbCA9IDA7IHByZXZBY2NlbCA8IG51bUFjY2VsZXJhdGlvbnM7IHByZXZBY2NlbCsrKSB7XG4gICAgICAgICAgICBpbnQgYXZ0SW5kZXggPSBwcmV2VGltZSAqIG51bVBlclRpbWUgKyBwcmV2VmVsb2NpdHkgKiBudW1BY2NlbGVyYXRpb25zICsgcHJldkFjY2VsO1xuXG4gICAgICAgICAgICAvLyBDb3N0IHRhYmxlIGVudHJ5OlxuICAgICAgICAgICAgLy8gICB4OiBjb3N0IHNvIGZhclxuICAgICAgICAgICAgLy8gICB5OiBlbmQgdmVsb2NpdHlcbiAgICAgICAgICAgIC8vICAgejogZW5kIHRpbWVcbiAgICAgICAgICAgIC8vICAgdzogcGFyZW50IGluZGV4XG4gICAgICAgICAgICB2ZWM0IGNvc3RUYWJsZUVudHJ5ID0gdGV4ZWxGZXRjaChjb3N0VGFibGUsIGl2ZWMzKGF2dEluZGV4LCBwcmV2TGF0aXR1ZGUsIHByZXZTdGF0aW9uKSwgMCk7XG5cbiAgICAgICAgICAgIC8vIElmIGNvc3QgZW50cnkgaXMgaW5maW5pdHlcbiAgICAgICAgICAgIGlmIChjb3N0VGFibGVFbnRyeS54IDwgMC4wIHx8IGF2ZXJhZ2VTdGF0aWNDb3N0ICogcGF0aExlbmd0aCArIGNvc3RUYWJsZUVudHJ5LnggPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZlYzMgYXZ0ID0gY2FsY3VsYXRlQVZUKGFjY2VsZXJhdGlvbkluZGV4LCBjb3N0VGFibGVFbnRyeS55LCBjb3N0VGFibGVFbnRyeS56LCBwYXRoTGVuZ3RoKTtcbiAgICAgICAgICAgIGZsb2F0IGFjY2VsZXJhdGlvbiA9IGF2dC54O1xuICAgICAgICAgICAgZmxvYXQgZmluYWxWZWxvY2l0eSA9IGF2dC55O1xuICAgICAgICAgICAgZmxvYXQgZmluYWxUaW1lID0gYXZ0Lno7XG5cbiAgICAgICAgICAgIGlmIChhdmVyYWdlU3RhdGljQ29zdCAqIHBhdGhMZW5ndGggKyBjb3N0VGFibGVFbnRyeS54ICsgZXh0cmFUaW1lUGVuYWx0eSAqIGZpbmFsVGltZSA+PSBiZXN0VGVybWluYWxDb3N0KSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgZmluYWwgdmVsb2NpdHkgZG9lcyBub3QgbWF0Y2ggdGhpcyBmcmFnbWVudCdzIHZlbG9jaXR5IHJhbmdlLCB0aGVuIHNraXAgdGhpcyB0cmFqZWN0b3J5XG4gICAgICAgICAgICBpZiAoZmluYWxWZWxvY2l0eSA8IG1pblZlbG9jaXR5IHx8IGZpbmFsVmVsb2NpdHkgPj0gbWF4VmVsb2NpdHkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBmaW5hbCB0aW1lIGRvZXMgbm90IG1hdGNoIHRoaXMgZnJhZ21lbnQncyB0aW1lIHJhbmdlLCB0aGVuIHNraXAgdGhpcyB0cmFqZWN0b3J5XG4gICAgICAgICAgICBpZiAoZmluYWxUaW1lIDwgbWluVGltZSB8fCBmaW5hbFRpbWUgPj0gbWF4VGltZSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGZsb2F0IGFiYW5kb25UaHJlc2hvbGQgPSAoYmVzdFRlcm1pbmFsQ29zdCAtIGV4dHJhVGltZVBlbmFsdHkgKiBmaW5hbFRpbWUgLSBjb3N0VGFibGVFbnRyeS54KSAvIHBhdGhMZW5ndGggLSBhdmVyYWdlU3RhdGljQ29zdDtcbiAgICAgICAgICAgIGZsb2F0IGF2ZXJhZ2VEeW5hbWljQ29zdCA9IGNhbGN1bGF0ZUF2ZXJhZ2VEeW5hbWljQ29zdChudW1TYW1wbGVzLCBwYXRoTGVuZ3RoLCBjb3N0VGFibGVFbnRyeS56LCBjb3N0VGFibGVFbnRyeS55LCBhY2NlbGVyYXRpb24sIGFiYW5kb25UaHJlc2hvbGQpO1xuICAgICAgICAgICAgaWYgKGF2ZXJhZ2VEeW5hbWljQ29zdCA8IDAuMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChhY2NlbGVyYXRpb25JbmRleCAhPSBwcmV2QWNjZWwpXG4gICAgICAgICAgICAgIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5O1xuXG4gICAgICAgICAgICAvLyBUaGUgY29zdCBvZiBhIHRyYWplY3RvcnkgaXMgdGhlIGF2ZXJhZ2Ugc2FtcGxlIGNvc3Qgc2NhbGVkIGJ5IHRoZSBwYXRoIGxlbmd0aFxuICAgICAgICAgICAgZmxvYXQgdG90YWxDb3N0ID0gKGF2ZXJhZ2VTdGF0aWNDb3N0ICsgYXZlcmFnZUR5bmFtaWNDb3N0KSAqIHBhdGhMZW5ndGggKyBjb3N0VGFibGVFbnRyeS54O1xuXG4gICAgICAgICAgICBmbG9hdCB0ZXJtaW5hbENvc3QgPSB0b3RhbENvc3QgKyBleHRyYVRpbWVQZW5hbHR5ICogZmluYWxUaW1lO1xuICAgICAgICAgICAgaWYgKHRlcm1pbmFsQ29zdCA+PSBiZXN0VGVybWluYWxDb3N0KSBjb250aW51ZTtcbiAgICAgICAgICAgIGJlc3RUZXJtaW5hbENvc3QgPSB0ZXJtaW5hbENvc3Q7XG5cbiAgICAgICAgICAgIGludCBpbmNvbWluZ0luZGV4ID0gYXZ0SW5kZXggKyBudW1QZXJUaW1lICogbnVtVGltZXMgKiAocHJldkxhdGl0dWRlICsgbnVtTGF0aXR1ZGVzICogcHJldlN0YXRpb24pO1xuICAgICAgICAgICAgYmVzdFRyYWplY3RvcnkgPSB2ZWM0KHRvdGFsQ29zdCwgZmluYWxWZWxvY2l0eSwgZmluYWxUaW1lLCBpbmNvbWluZ0luZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGlvbiA8IHN0YXRpb25Db25uZWN0aXZpdHkpIHtcbiAgICBpdmVjMiBzbGFJbmRleCA9IGl2ZWMyKGxhdGl0dWRlLCBzdGF0aW9uICogbnVtQWNjZWxlcmF0aW9ucyArIGFjY2VsZXJhdGlvbkluZGV4KTtcblxuICAgIHZlYzQgY29zdFRhYmxlRW50cnkgPSB0ZXhlbEZldGNoKGN1YmljUGF0aEZyb21WZWhpY2xlQ29zdHMsIHNsYUluZGV4LCAwKTtcbiAgICBmbG9hdCB0ZXJtaW5hbENvc3Q7XG5cbiAgICBpZiAoY29zdFRhYmxlRW50cnkueCA+PSAwLjApIHtcbiAgICAgIHRlcm1pbmFsQ29zdCA9IGNvc3RUYWJsZUVudHJ5LnggKyBleHRyYVRpbWVQZW5hbHR5ICogY29zdFRhYmxlRW50cnkuejtcblxuICAgICAgaWYgKHRlcm1pbmFsQ29zdCA8IGJlc3RUZXJtaW5hbENvc3QpIHtcbiAgICAgICAgYmVzdFRlcm1pbmFsQ29zdCA9IHRlcm1pbmFsQ29zdDtcbiAgICAgICAgYmVzdFRyYWplY3RvcnkgPSBjb3N0VGFibGVFbnRyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb3N0VGFibGVFbnRyeSA9IHRleGVsRmV0Y2gocXVpbnRpY1BhdGhGcm9tVmVoaWNsZUNvc3RzLCBzbGFJbmRleCwgMCk7XG5cbiAgICBpZiAoY29zdFRhYmxlRW50cnkueCA+PSAwLjApIHtcbiAgICAgIHRlcm1pbmFsQ29zdCA9IGNvc3RUYWJsZUVudHJ5LnggKyBleHRyYVRpbWVQZW5hbHR5ICogY29zdFRhYmxlRW50cnkuejtcblxuICAgICAgaWYgKHRlcm1pbmFsQ29zdCA8IGJlc3RUZXJtaW5hbENvc3QpIHtcbiAgICAgICAgYmVzdFRlcm1pbmFsQ29zdCA9IHRlcm1pbmFsQ29zdDtcbiAgICAgICAgYmVzdFRyYWplY3RvcnkgPSBjb3N0VGFibGVFbnRyeTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmVzdFRyYWplY3Rvcnk7XG59XG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogU09MVkVfU1RBVElPTl9LRVJORUwsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ2dyYXBoU2VhcmNoJyB9LFxuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIFNIQVJFRF9VTklGT1JNUywge1xuICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxuICAgICAgICBjb3N0VGFibGU6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnLCB0ZXh0dXJlVHlwZTogJzJEQXJyYXknIH0sXG4gICAgICAgIGN1YmljUGF0aHM6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXG4gICAgICAgIGN1YmljUGF0aEZyb21WZWhpY2xlQ29zdHM6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXG4gICAgICAgIHF1aW50aWNQYXRoRnJvbVZlaGljbGVDb3N0czogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIHZlbG9jaXR5VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGV4dHJhVGltZVBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgbnVtU3RhdGlvbnM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgbnVtTGF0aXR1ZGVzOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIG51bUFjY2VsZXJhdGlvbnM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgbnVtVmVsb2NpdGllczogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBudW1UaW1lczogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBzdGF0aW9uQ29ubmVjdGl2aXR5OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIHZlbG9jaXR5UmFuZ2VzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogTlVNX1ZFTE9DSVRZX1JBTkdFUyArIDEgfSxcbiAgICAgICAgdGltZVJhbmdlczogeyB0eXBlOiAnZmxvYXQnLCBsZW5ndGg6IE5VTV9USU1FX1JBTkdFUyArIDEgfSxcbiAgICAgICAgc3RhdGlvbjogeyB0eXBlOiAnaW50JyB9IC8vIFVwZGF0ZWQgaW4gYGRyYXdQcm94eWBcbiAgICAgIH0pLFxuICAgICAgZHJhd1Byb3h5OiAoZ3BncHUsIHByb2dyYW0sIGRyYXcpID0+IHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUyAqIE5VTV9USU1FX1JBTkdFUztcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcHJvZ3JhbS5tZXRhLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xuICAgICAgICBjb25zdCBjb3N0VGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogcHJvZ3JhbS5tZXRhLmxhdHRpY2UubnVtU3RhdGlvbnMgKiA0KTtcblxuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHByb2dyYW0ubWV0YS5sYXR0aWNlLm51bVN0YXRpb25zOyBzKyspIHtcbiAgICAgICAgICBncGdwdS51cGRhdGVQcm9ncmFtVW5pZm9ybXMocHJvZ3JhbSwgeyBzdGF0aW9uOiBzIH0pO1xuICAgICAgICAgIGRyYXcoKTtcblxuICAgICAgICAgIGdwZ3B1LmdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ3BncHUuZ2wuUkdCQSwgZ3BncHUuZ2wuRkxPQVQsIGNvc3RUYWJsZSwgcyAqIHdpZHRoICogaGVpZ2h0ICogNCk7XG5cbiAgICAgICAgICBncGdwdS5nbC5iaW5kVGV4dHVyZShncGdwdS5nbC5URVhUVVJFXzJEX0FSUkFZLCBncGdwdS5zaGFyZWRUZXh0dXJlcy5jb3N0VGFibGUpO1xuICAgICAgICAgIGdwZ3B1LmdsLmNvcHlUZXhTdWJJbWFnZTNEKGdwZ3B1LmdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIHMsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3BncHUuX2dyYXBoU2VhcmNoQ29zdFRhYmxlID0gY29zdFRhYmxlO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgcG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZmlyc3RMYXR0aWNlUG9pbnQsIHNlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyAqIE5VTV9WRUxPQ0lUWV9SQU5HRVMgKiBOVU1fVElNRV9SQU5HRVMsXG4gICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgbGF0dGljZTogY29uZmlnLmxhdHRpY2VcbiAgICAgIH0sXG4gICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRVbmlmb3JtVmFsdWVzKGNvbmZpZywgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZHluYW1pY0ZyYW1lVGltZSksIHtcbiAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IGZpcnN0TGF0dGljZVBvaW50LFxuICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHNlY29uZExhdHRpY2VQb2ludCxcbiAgICAgICAgdmVsb2NpdHlWZWhpY2xlOiBwb3NlLnZlbG9jaXR5LFxuICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2LFxuICAgICAgICBkQ3VydlZlaGljbGU6IHBvc2UuZEN1cnYsXG4gICAgICAgIGRkQ3VydlZlaGljbGU6IHBvc2UuZGRDdXJ2LFxuICAgICAgICBleHRyYVRpbWVQZW5hbHR5OiBjb25maWcuZXh0cmFUaW1lUGVuYWx0eSxcbiAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiBjb25maWcuaHlzdGVyZXNpc0Rpc2NvdW50LFxuICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiBjb25maWcuYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eSxcbiAgICAgICAgbnVtU3RhdGlvbnM6IGNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zLFxuICAgICAgICBudW1MYXRpdHVkZXM6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyxcbiAgICAgICAgbnVtVmVsb2NpdGllczogTlVNX1ZFTE9DSVRZX1JBTkdFUyxcbiAgICAgICAgbnVtVGltZXM6IE5VTV9USU1FX1JBTkdFUyxcbiAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcbiAgICAgICAgbGF0aXR1ZGVDb25uZWN0aXZpdHk6IGNvbmZpZy5sYXR0aWNlLmxhdGl0dWRlQ29ubmVjdGl2aXR5LFxuICAgICAgICB2ZWxvY2l0eVJhbmdlczogWzAsIGNvbmZpZy5zcGVlZExpbWl0IC8gMywgY29uZmlnLnNwZWVkTGltaXQgKiAyIC8gMywgY29uZmlnLnNwZWVkTGltaXQsIDEwMDAwMDBdLFxuICAgICAgICB0aW1lUmFuZ2VzOiBbMCwgMTAsIDEwMDAwMDBdXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn1cbiIsImNvbnN0IFhZX09CU1RBQ0xFX0NPU1RfS0VSTkVMID0gYFxuXG52ZWM0IGtlcm5lbCgpIHtcbiAgdmVjMiB4eSA9IChrZXJuZWxQb3NpdGlvbiAtIDAuNSkgKiB2ZWMyKGtlcm5lbFNpemUpICogdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyB4eUNlbnRlclBvaW50O1xuXG4gIHZlYzIgeHlUZXhDb29yZHMgPSAoeHkgLSB4eUNlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoeHlzbE1hcCwgMCkpIC8gdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIHZlYzIgc2wgPSB0ZXh0dXJlKHh5c2xNYXAsIHh5VGV4Q29vcmRzKS54eTtcblxuICB2ZWMyIHNsVGV4Q29vcmRzID0gKHNsIC0gc2xDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHNsT2JzdGFjbGVHcmlkLCAwKSkgLyB2ZWMyKHNsR3JpZENlbGxTaXplKSArIDAuNTtcbiAgcmV0dXJuIHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIHNsVGV4Q29vcmRzKTtcbn1cblxuYDtcblxuLy8gQnVpbGQgWFkgb2JzdGFjbGUgY29zdHMgdXNpbmcgWFlTTCBtYXBcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogWFlfT0JTVEFDTEVfQ09TVF9LRVJORUwsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3h5T2JzdGFjbGVDb3N0R3JpZCcsIHJlYWQ6IHRydWUgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHh5c2xNYXA6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXG4gICAgICAgIHNsT2JzdGFjbGVHcmlkOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ3NsT2JzdGFjbGVHcmlkRGlsYXRlZCcgfSxcbiAgICAgICAgeHlDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gICAgICAgIHNsQ2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgIHNsR3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCd9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogeHlXaWR0aCxcbiAgICAgIGhlaWdodDogeHlIZWlnaHQsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB4eUNlbnRlclBvaW50OiBbeHlDZW50ZXJQb2ludC54LCB4eUNlbnRlclBvaW50LnldLFxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxuICAgICAgICBzbENlbnRlclBvaW50OiBbc2xDZW50ZXJQb2ludC54LCBzbENlbnRlclBvaW50LnldLFxuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogY29uZmlnLnNsR3JpZENlbGxTaXplXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IEdQR1BVIGZyb20gXCIuLi8uLi9HUEdQVS5qc1wiO1xuaW1wb3J0IENhciBmcm9tIFwiLi4vLi4vcGh5c2ljcy9DYXIuanNcIjtcbmltcG9ydCBDdWJpY1BhdGggZnJvbSBcIi4vQ3ViaWNQYXRoLmpzXCI7XG5pbXBvcnQgUXVpbnRpY1BhdGggZnJvbSBcIi4vUXVpbnRpY1BhdGguanNcIjtcbmltcG9ydCB4eU9ic3RhY2xlR3JpZCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlR3JpZC5qc1wiO1xuaW1wb3J0IHNsT2JzdGFjbGVHcmlkIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkLmpzXCI7XG5pbXBvcnQgc2xPYnN0YWNsZUdyaWREaWxhdGlvbiBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy9zbE9ic3RhY2xlR3JpZERpbGF0aW9uLmpzXCI7XG5pbXBvcnQgc2xEeW5hbWljT2JzdGFjbGVHcmlkIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3NsRHluYW1pY09ic3RhY2xlR3JpZC5qc1wiO1xuaW1wb3J0IHh5c2xNYXAgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMveHlzbE1hcC5qc1wiO1xuaW1wb3J0IG9wdGltaXplQ3ViaWNQYXRocyBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZUN1YmljUGF0aHMuanNcIjtcbmltcG9ydCBvcHRpbWl6ZVF1aW50aWNQYXRocyBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZVF1aW50aWNQYXRocy5qc1wiO1xuaW1wb3J0IHBhdGhGcm9tVmVoaWNsZUNvc3RzIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3BhdGhGcm9tVmVoaWNsZUNvc3RzLmpzXCI7XG5pbXBvcnQgZ3JhcGhTZWFyY2ggZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvZ3JhcGhTZWFyY2guanNcIjtcbmltcG9ydCB4eU9ic3RhY2xlQ29zdEdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMveHlPYnN0YWNsZUNvc3RHcmlkLmpzXCI7XG5cbmNvbnN0IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMgPSA4O1xuY29uc3QgTlVNX1ZFTE9DSVRZX1JBTkdFUyA9IDQ7XG5jb25zdCBOVU1fVElNRV9SQU5HRVMgPSAyO1xuXG4vKiBPYnN0YWNsZSBjb3N0IG1hcDpcbiAqXG4gKiAxLiBSYXN0ZXJpemUgdHJpYW5nbGVzIGZyb20gcG9seWdvbmFsIG9ic3RhY2xlcyBpbnRvIFhZLXNwYWNlIG9jY3VwYW5jeSBncmlkXG4gKiAyLiBDb252ZXJ0IG9jY3VwYW5jeSBncmlkIHRvIFNMLXNwYWNlXG4gKiAgICAqIFdpZHRoIGlzIHNwYXRpYWwgaG9yaXpvbiBvZiB0aGUgc3RhdGUgbGF0dGljZVxuICogICAgKiBIZWlnaHQgaXMgbGFuZSB3aWR0aFxuICogICAgKiBSZXNvbHV0aW9uIHNob3VsZCBiZSBoaWdoZXIgdGhhbiBYWS1ncmlkXG4gKiAgICAqIEdldCBYWSBwb3NpdGlvbiBmcm9tIGNlbnRlcmxpbmUgdGV4dHVyZVxuICogICAgKiBMb29rdXAgWFkgaW4gWFkgb2NjdXBhbmN5IGdyaWQgKG5lYXJlc3QpXG4gKiAzLiBEaWxhdGUgU0wtc3BhY2UgZ3JpZCB1c2luZyB0d28gcGFzc2VzIChhbG9uZyBzdGF0aW9uLCB0aGVuIGFsb25nIGxhdGl0dWRlKVxuICogICAgKiBjb2xsaXNpb24gYXJlYTogaGFsZiBjYXIgc2l6ZSArIDAuM21cbiAqICAgICogaGlnaCBjb3N0IGFyZWE6IDEgbWV0ZXJcbiAqIDQuIENvbnZlcnQgYmFjayB0byBYWS1zcGFjZSB1c2luZyBYWVNMIG1hcFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhQbGFubmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50ID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuICAgIHRoaXMucHJldmlvdXNGaXJzdEFjY2VsZXJhdGlvbiA9IC0xO1xuICAgIHRoaXMucHJldmlvdXNTZWNvbmRMYXR0aWNlUG9pbnQgPSAtMTtcblxuICAgIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHByb2dyYW1zID0gW1xuICAgICAgeHlPYnN0YWNsZUdyaWQuc2V0VXAoKSxcbiAgICAgIHNsT2JzdGFjbGVHcmlkLnNldFVwKCksXG4gICAgICAuLi5zbE9ic3RhY2xlR3JpZERpbGF0aW9uLnNldFVwKCksXG4gICAgICBzbER5bmFtaWNPYnN0YWNsZUdyaWQuc2V0VXAoKSxcbiAgICAgIHh5c2xNYXAuc2V0VXAoKSxcbiAgICAgIC4uLm9wdGltaXplQ3ViaWNQYXRocy5zZXRVcCgpLFxuICAgICAgb3B0aW1pemVRdWludGljUGF0aHMuc2V0VXAoKSxcbiAgICAgIC4uLnBhdGhGcm9tVmVoaWNsZUNvc3RzLnNldFVwKCksXG4gICAgICBncmFwaFNlYXJjaC5zZXRVcCgpLFxuICAgIF0ubWFwKHAgPT4gT2JqZWN0LmFzc2lnbih7fSwgcCwgeyB3aWR0aDogMSwgaGVpZ2h0OiAxIH0pKTtcblxuICAgIHRoaXMuZ3BncHUgPSBuZXcgR1BHUFUocHJvZ3JhbXMpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50ID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuICAgIHRoaXMucHJldmlvdXNGaXJzdEFjY2VsZXJhdGlvbiA9IC0xO1xuICAgIHRoaXMucHJldmlvdXNTZWNvbmRMYXR0aWNlUG9pbnQgPSAtMTtcbiAgfVxuXG4gIHBsYW4odmVoaWNsZVBvc2UsIHZlaGljbGVTdGF0aW9uLCBsYW5lUGF0aCwgc3RhcnRUaW1lLCBzdGF0aWNPYnN0YWNsZXMsIGR5bmFtaWNPYnN0YWNsZXMpIHtcbiAgICBjb25zdCBsYXR0aWNlU3RhdGlvbkludGVydmFsID0gdGhpcy5fbGF0dGljZVN0YXRpb25JbnRlcnZhbCgpO1xuXG4gICAgY29uc3QgY2VudGVybGluZVJhdyA9IGxhbmVQYXRoLnNhbXBsZVN0YXRpb25zKHZlaGljbGVTdGF0aW9uLCBNYXRoLmNlaWwoKHRoaXMuY29uZmlnLnNwYXRpYWxIb3Jpem9uICsgbGF0dGljZVN0YXRpb25JbnRlcnZhbCkgLyB0aGlzLmNvbmZpZy5jZW50ZXJsaW5lU3RhdGlvbkludGVydmFsKSArIDEsIHRoaXMuY29uZmlnLmNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGFsbCBjZW50ZXJsaW5lIHBvaW50cyBpbnRvIHZlaGljbGUgZnJhbWVcbiAgICBjb25zdCB2ZWhpY2xlWGZvcm0gPSB2ZWhpY2xlVHJhbnNmb3JtKHZlaGljbGVQb3NlKTtcbiAgICBjb25zdCBjZW50ZXJsaW5lID0gY2VudGVybGluZVJhdy5tYXAoYyA9PiB7IHJldHVybiB7IHBvczogYy5wb3MuY2xvbmUoKS5hcHBseU1hdHJpeDModmVoaWNsZVhmb3JtKSwgcm90OiBjLnJvdCAtIHZlaGljbGVQb3NlLnJvdCwgY3VydjogYy5jdXJ2IH0gfSk7XG5cbiAgICBjb25zdCBjZW50ZXJsaW5lRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoY2VudGVybGluZS5sZW5ndGggKiAzKTtcbiAgICBjb25zdCBtYXhQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IyKDAsIDApO1xuICAgIGNvbnN0IG1pblBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbnRlcmxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGNlbnRlcmxpbmVbaV07XG4gICAgICBjb25zdCBwb3MgPSBzYW1wbGUucG9zO1xuICAgICAgY2VudGVybGluZURhdGFbaSAqIDMgKyAwXSA9IHBvcy54O1xuICAgICAgY2VudGVybGluZURhdGFbaSAqIDMgKyAxXSA9IHBvcy55O1xuICAgICAgY2VudGVybGluZURhdGFbaSAqIDMgKyAyXSA9IHNhbXBsZS5yb3Q7XG5cbiAgICAgIG1heFBvaW50Lm1heChwb3MpO1xuICAgICAgbWluUG9pbnQubWluKHBvcyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGlmZiA9IG1heFBvaW50LmNsb25lKCkuc3ViKG1pblBvaW50KTtcbiAgICBjb25zdCB4eUNlbnRlclBvaW50ID0gbWluUG9pbnQuY2xvbmUoKS5hZGQobWF4UG9pbnQpLmRpdmlkZVNjYWxhcigyKTtcblxuICAgIC8vIFNpemVzIG9mIHRoZSB4eSBncmlkcyAoaW4gcGl4ZWxzLCBub3QgbWV0ZXJzKVxuICAgIGNvbnN0IHh5V2lkdGggPSBNYXRoLmNlaWwoKGRpZmYueCArIHRoaXMuY29uZmlnLmdyaWRNYXJnaW4gKiAyKSAvIHRoaXMuY29uZmlnLnh5R3JpZENlbGxTaXplKTtcbiAgICBjb25zdCB4eUhlaWdodCA9IE1hdGguY2VpbCgoZGlmZi55ICsgdGhpcy5jb25maWcuZ3JpZE1hcmdpbiAqIDIpIC8gdGhpcy5jb25maWcueHlHcmlkQ2VsbFNpemUpO1xuXG4gICAgY29uc3Qgc3RhdGlvbldpZHRoID0gdGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gKyBsYXR0aWNlU3RhdGlvbkludGVydmFsICogMjtcbiAgICBjb25zdCBzbENlbnRlclBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gLyAyLCAwKTtcblxuICAgIC8vIFNpemVzIG9mIHRoZSBzbCBncmlkcyAoaW4gcGl4ZWxzLCBub3QgbWV0ZXJzKVxuICAgIGNvbnN0IHNsV2lkdGggPSBNYXRoLmNlaWwoc3RhdGlvbldpZHRoIC8gdGhpcy5jb25maWcuc2xHcmlkQ2VsbFNpemUpO1xuICAgIGNvbnN0IHNsSGVpZ2h0ID0gTWF0aC5jZWlsKCh0aGlzLmNvbmZpZy5yb2FkV2lkdGggKyB0aGlzLmNvbmZpZy5ncmlkTWFyZ2luICogMikgLyB0aGlzLmNvbmZpZy5zbEdyaWRDZWxsU2l6ZSk7XG5cbiAgICBsZXQgc3RhcnRTdGF0aW9uO1xuXG4gICAgaWYgKHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPT09IG51bGwgfHwgdmVoaWNsZVN0YXRpb24gKyBsYXR0aWNlU3RhdGlvbkludGVydmFsIC8gMiA+IHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24pIHtcbiAgICAgIHN0YXJ0U3RhdGlvbiA9ICh0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID09PSBudWxsID8gdmVoaWNsZVN0YXRpb24gOiB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uKSArIGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWw7XG4gICAgICB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID0gc3RhcnRTdGF0aW9uO1xuICAgICAgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50IC09IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xuICAgICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCAtPSB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRTdGF0aW9uID0gdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBsYXR0aWNlID0gdGhpcy5fYnVpbGRMYXR0aWNlKGxhbmVQYXRoLCBzdGFydFN0YXRpb24sIHZlaGljbGVQb3NlLnJvdCwgdmVoaWNsZVhmb3JtKTtcblxuICAgIGNvbnN0IHRlbXBvcmFsSG9yaXpvbiA9IHRoaXMuY29uZmlnLnNwYXRpYWxIb3Jpem9uIC8gdGhpcy5jb25maWcuc3BlZWRMaW1pdDtcbiAgICBjb25zdCBkeW5hbWljRnJhbWVUaW1lID0gdGVtcG9yYWxIb3Jpem9uIC8gdGhpcy5jb25maWcubnVtRHluYW1pY0ZyYW1lcztcblxuICAgIGZvciAoY29uc3QgW2ksIHBdIG9mIFtcbiAgICAgIHh5T2JzdGFjbGVHcmlkLnVwZGF0ZSh0aGlzLmNvbmZpZywgeHlXaWR0aCwgeHlIZWlnaHQsIHh5Q2VudGVyUG9pbnQsIHZlaGljbGVYZm9ybSwgc3RhdGljT2JzdGFjbGVzKSxcbiAgICAgIHNsT2JzdGFjbGVHcmlkLnVwZGF0ZSh0aGlzLmNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQsIHNsQ2VudGVyUG9pbnQsIHh5Q2VudGVyUG9pbnQpLFxuICAgICAgLi4uc2xPYnN0YWNsZUdyaWREaWxhdGlvbi51cGRhdGUodGhpcy5jb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0KSxcbiAgICAgIHNsRHluYW1pY09ic3RhY2xlR3JpZC51cGRhdGUodGhpcy5jb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0LCBzbENlbnRlclBvaW50LCB2ZWhpY2xlU3RhdGlvbiwgc3RhcnRUaW1lLCBkeW5hbWljRnJhbWVUaW1lLCBkeW5hbWljT2JzdGFjbGVzKSxcbiAgICAgIHh5c2xNYXAudXBkYXRlKHRoaXMuY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCksXG4gICAgICAuLi5vcHRpbWl6ZUN1YmljUGF0aHMudXBkYXRlKHRoaXMuY29uZmlnLCB2ZWhpY2xlUG9zZSksXG4gICAgICBvcHRpbWl6ZVF1aW50aWNQYXRocy51cGRhdGUodGhpcy5jb25maWcsIHZlaGljbGVQb3NlKSxcbiAgICAgIC4uLnBhdGhGcm9tVmVoaWNsZUNvc3RzLnVwZGF0ZSh0aGlzLmNvbmZpZywgdmVoaWNsZVBvc2UsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCwgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSksXG4gICAgICBncmFwaFNlYXJjaC51cGRhdGUodGhpcy5jb25maWcsIHZlaGljbGVQb3NlLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQsIHRoaXMucHJldmlvdXNTZWNvbmRMYXR0aWNlUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpXG4gICAgXS5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMuZ3BncHUudXBkYXRlUHJvZ3JhbShpLCBwKTtcbiAgICB9XG5cbiAgICB0aGlzLmdwZ3B1LnVwZGF0ZVNoYXJlZFRleHR1cmVzKHtcbiAgICAgIGNlbnRlcmxpbmU6IHtcbiAgICAgICAgd2lkdGg6IGNlbnRlcmxpbmUubGVuZ3RoLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBmaWx0ZXI6ICdsaW5lYXInLFxuICAgICAgICBkYXRhOiBjZW50ZXJsaW5lRGF0YVxuICAgICAgfSxcbiAgICAgIGNvc3RUYWJsZToge1xuICAgICAgICB3aWR0aDogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyAqIE5VTV9WRUxPQ0lUWV9SQU5HRVMgKiBOVU1fVElNRV9SQU5HRVMsXG4gICAgICAgIGhlaWdodDogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGRlcHRoOiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zLFxuICAgICAgICBjaGFubmVsczogNCxcbiAgICAgICAgdGV4dHVyZVR5cGU6ICcyREFycmF5J1xuICAgICAgfSxcbiAgICAgIGxhdHRpY2U6IHtcbiAgICAgICAgd2lkdGg6IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXG4gICAgICAgIGNoYW5uZWxzOiA0LFxuICAgICAgICBkYXRhOiBsYXR0aWNlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmdwZ3B1Ll9ncmFwaFNlYXJjaENvc3RUYWJsZSA9IG51bGw7XG4gICAgdGhpcy5ncGdwdS5fZHluYW1pY09ic3RhY2xlR3JpZCA9IG51bGw7XG5cbiAgICBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBvdXRwdXRzID0gdGhpcy5ncGdwdS5ydW4oKTtcbiAgICBjb25zdCBjb3N0VGFibGUgPSB0aGlzLmdwZ3B1Ll9ncmFwaFNlYXJjaENvc3RUYWJsZTtcbiAgICBjb25zdCBjdWJpY1BhdGhQYXJhbXMgPSBvdXRwdXRzWzZdO1xuICAgIGNvbnN0IGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zID0gb3V0cHV0c1s3XTtcbiAgICBjb25zdCBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zID0gb3V0cHV0c1s4XTtcblxuICAgIGxldCBiZXN0RW50cnkgPSBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXTtcbiAgICBsZXQgYmVzdEVudHJ5SW5kZXg7XG4gICAgY29uc3QgbnVtRW50cmllcyA9IGNvc3RUYWJsZS5sZW5ndGggLyA0O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbnRyaWVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5VW5wYWNrZWQgPSB0aGlzLl91bnBhY2tDb3N0VGFibGVJbmRleChpKTtcbiAgICAgIGNvbnN0IGVudHJ5ID0gW1xuICAgICAgICBjb3N0VGFibGVbaSAqIDRdLFxuICAgICAgICBjb3N0VGFibGVbaSAqIDQgKyAxXSxcbiAgICAgICAgY29zdFRhYmxlW2kgKiA0ICsgMl0sXG4gICAgICAgIGNvc3RUYWJsZVtpICogNCArIDNdXG4gICAgICBdO1xuXG4gICAgICBpZiAoZW50cnlbMF0gPCAwKSBjb250aW51ZTtcblxuICAgICAgZW50cnlbMF0gKz0gdGhpcy5fdGVybWluYWxDb3N0KGVudHJ5VW5wYWNrZWQsIGVudHJ5KTtcblxuICAgICAgaWYgKGVudHJ5WzBdIDwgYmVzdEVudHJ5WzBdKSB7XG4gICAgICAgIGJlc3RFbnRyeUluZGV4ID0gaTtcbiAgICAgICAgYmVzdEVudHJ5ID0gZW50cnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW52ZXJzZVZlaGljbGVYZm9ybSA9IChuZXcgVEhSRUUuTWF0cml4MygpKS5nZXRJbnZlcnNlKHZlaGljbGVYZm9ybSk7XG4gICAgbGV0IGJlc3RUcmFqZWN0b3J5ID0gbnVsbDtcbiAgICBsZXQgZnJvbVZlaGljbGVTZWdtZW50ID0gbnVsbDtcbiAgICBsZXQgZnJvbVZlaGljbGVQYXJhbXMgPSBudWxsO1xuICAgIGxldCBmaXJzdExhdHRpY2VQb2ludCA9IC0xO1xuICAgIGxldCBmaXJzdEFjY2VsZXJhdGlvbiA9IC0xO1xuICAgIGxldCBzZWNvbmRMYXR0aWNlUG9pbnQgPSAtMTtcbiAgICBsZXQgc2Vjb25kQWNjZWxlcmF0aW9uID0gLTE7XG5cbiAgICBpZiAoaXNGaW5pdGUoYmVzdEVudHJ5WzBdKSkge1xuICAgICAgW2Jlc3RUcmFqZWN0b3J5LCBmcm9tVmVoaWNsZVNlZ21lbnQsIGZyb21WZWhpY2xlUGFyYW1zLCBmaXJzdExhdHRpY2VQb2ludCwgZmlyc3RBY2NlbGVyYXRpb24sIHNlY29uZExhdHRpY2VQb2ludCwgc2Vjb25kQWNjZWxlcmF0aW9uXSA9IHRoaXMuX3JlY29uc3RydWN0VHJhamVjdG9yeShcbiAgICAgICAgYmVzdEVudHJ5SW5kZXgsXG4gICAgICAgIGNvc3RUYWJsZSxcbiAgICAgICAgY3ViaWNQYXRoUGFyYW1zLFxuICAgICAgICBjdWJpY1BhdGhGcm9tVmVoaWNsZVBhcmFtcyxcbiAgICAgICAgcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtcyxcbiAgICAgICAgdmVoaWNsZVBvc2UsXG4gICAgICAgIGxhdHRpY2VcbiAgICAgICk7XG5cbiAgICAgIGZyb21WZWhpY2xlU2VnbWVudC5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLnBvcyA9IHAucG9zLmFwcGx5TWF0cml4MyhpbnZlcnNlVmVoaWNsZVhmb3JtKTtcbiAgICAgICAgcC5yb3QgKz0gdmVoaWNsZVBvc2Uucm90O1xuICAgICAgfSk7XG5cbiAgICAgIGJlc3RUcmFqZWN0b3J5LmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAucG9zID0gcC5wb3MuYXBwbHlNYXRyaXgzKGludmVyc2VWZWhpY2xlWGZvcm0pO1xuICAgICAgICBwLnJvdCArPSB2ZWhpY2xlUG9zZS5yb3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgPSBmaXJzdExhdHRpY2VQb2ludDtcbiAgICB0aGlzLnByZXZpb3VzRmlyc3RBY2NlbGVyYXRpb24gPSBmaXJzdEFjY2VsZXJhdGlvbjtcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gc2Vjb25kTGF0dGljZVBvaW50O1xuICAgIHRoaXMucHJldmlvdXNTZWNvbmRBY2NlbGVyYXRpb24gPSBzZWNvbmRBY2NlbGVyYXRpb247XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogYmVzdFRyYWplY3RvcnksXG4gICAgICBmcm9tVmVoaWNsZVNlZ21lbnQ6IGZyb21WZWhpY2xlU2VnbWVudCxcbiAgICAgIGZyb21WZWhpY2xlUGFyYW1zOiBmcm9tVmVoaWNsZVBhcmFtcyxcbiAgICAgIGxhdHRpY2VTdGFydFN0YXRpb246IHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24sXG4gICAgICBkeW5hbWljT2JzdGFjbGVHcmlkOiB7IGRhdGE6IHRoaXMuZ3BncHUuX2R5bmFtaWNPYnN0YWNsZUdyaWQsIHdpZHRoOiBzbFdpZHRoLCBoZWlnaHQ6IHNsSGVpZ2h0IH1cbiAgICB9O1xuICB9XG5cbiAgX2J1aWxkTGF0dGljZShsYW5lUGF0aCwgc3RhcnRTdGF0aW9uLCB2ZWhpY2xlUm90LCB2ZWhpY2xlWGZvcm0pIHtcbiAgICBjb25zdCBjZW50ZXJsaW5lID0gbGFuZVBhdGguc2FtcGxlU3RhdGlvbnMoc3RhcnRTdGF0aW9uLCB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zLCB0aGlzLl9sYXR0aWNlU3RhdGlvbkludGVydmFsKCkpO1xuICAgIGNvbnN0IG9mZnNldCA9IE1hdGguZmxvb3IodGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgLyAyKTtcbiAgICBjb25zdCBsYXR0aWNlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKiA0KTtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjZW50ZXJsaW5lLmxlbmd0aDsgcysrKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSBjZW50ZXJsaW5lW3NdO1xuXG4gICAgICBmb3IgKGxldCBsID0gMDsgbCA8IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzOyBsKyspIHtcbiAgICAgICAgY29uc3QgbGF0aXR1ZGUgPSAobCAtIG9mZnNldCkgLyBvZmZzZXQgKiB0aGlzLmNvbmZpZy5yb2FkV2lkdGggLyAyO1xuICAgICAgICBjb25zdCByb3QgPSBzYW1wbGUucm90IC0gdmVoaWNsZVJvdDtcbiAgICAgICAgY29uc3QgcG9zID0gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUocm90ICsgTWF0aC5QSSAvIDIpLm11bHRpcGx5U2NhbGFyKGxhdGl0dWRlKS5hZGQoc2FtcGxlLnBvcy5jbG9uZSgpLmFwcGx5TWF0cml4Myh2ZWhpY2xlWGZvcm0pKTtcbiAgICAgICAgY29uc3QgY3VydiA9IHNhbXBsZS5jdXJ2ID09IDAgPyAwIDogMSAvICgxIC8gc2FtcGxlLmN1cnYgLSBsYXRpdHVkZSk7XG5cbiAgICAgICAgbGF0dGljZVtpbmRleCsrXSA9IHBvcy54O1xuICAgICAgICBsYXR0aWNlW2luZGV4KytdID0gcG9zLnk7XG4gICAgICAgIGxhdHRpY2VbaW5kZXgrK10gPSByb3Q7XG4gICAgICAgIGxhdHRpY2VbaW5kZXgrK10gPSBjdXJ2O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYXR0aWNlO1xuICB9XG5cbiAgX2xhdHRpY2VTdGF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnNwYXRpYWxIb3Jpem9uIC8gdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucztcbiAgfVxuXG4gIF90ZXJtaW5hbENvc3QoW3N0YXRpb25JbmRleCwgbGF0aXR1ZGVJbmRleCwgdGltZUluZGV4LCB2ZWxvY2l0eUluZGV4LCBhY2NlbGVyYXRpb25JbmRleF0sIFtjb3N0LCBmaW5hbFZlbG9jaXR5LCBmaW5hbFRpbWUsIGluY29taW5nSW5kZXhdKSB7XG4gICAgLy8gT25seSBjb25zaWRlciB2ZXJ0aWNlcyB0aGF0IHJlYWNoIHRoZSBlbmQgb2YgdGhlIHNwYXRpYWwgb3IgdGVtcG9yYWwgaG9yaXpvblxuICAgIGlmIChzdGF0aW9uSW5kZXggIT0gdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucyAtIDEgJiYgZmluYWxWZWxvY2l0eSA+IDAuMDUpXG4gICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgY29uc3Qgc3RhdGlvbiA9ICh0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMpICogKHN0YXRpb25JbmRleCArIDEpO1xuXG4gICAgcmV0dXJuIHN0YXRpb24gKiAtdGhpcy5jb25maWcuc3RhdGlvblJlYWNoRGlzY291bnQgKyBmaW5hbFRpbWUgKiB0aGlzLmNvbmZpZy5leHRyYVRpbWVQZW5hbHR5O1xuICB9XG5cbiAgX3VucGFja0Nvc3RUYWJsZUluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIFstMSwgaW5kZXggKyAyLCBudWxsLCBudWxsLCBudWxsXTtcblxuICAgIGNvbnN0IG51bVBlclRpbWUgPSBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUztcbiAgICBjb25zdCBudW1QZXJMYXRpdHVkZSA9IG51bVBlclRpbWUgKiBOVU1fVElNRV9SQU5HRVM7XG4gICAgY29uc3QgbnVtUGVyU3RhdGlvbiA9IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICogbnVtUGVyTGF0aXR1ZGU7XG5cbiAgICBjb25zdCBzdGF0aW9uSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gbnVtUGVyU3RhdGlvbik7XG4gICAgaW5kZXggLT0gc3RhdGlvbkluZGV4ICogbnVtUGVyU3RhdGlvbjtcblxuICAgIGNvbnN0IGxhdGl0dWRlSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gbnVtUGVyTGF0aXR1ZGUpO1xuICAgIGluZGV4IC09IGxhdGl0dWRlSW5kZXggKiBudW1QZXJMYXRpdHVkZTtcblxuICAgIGNvbnN0IHRpbWVJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJUaW1lKTtcbiAgICBpbmRleCAtPSB0aW1lSW5kZXggKiBudW1QZXJUaW1lO1xuXG4gICAgY29uc3QgdmVsb2NpdHlJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTKTtcbiAgICBjb25zdCBhY2NlbGVyYXRpb25JbmRleCA9IGluZGV4ICUgTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUztcblxuICAgIHJldHVybiBbc3RhdGlvbkluZGV4LCBsYXRpdHVkZUluZGV4LCB0aW1lSW5kZXgsIHZlbG9jaXR5SW5kZXgsIGFjY2VsZXJhdGlvbkluZGV4XTtcbiAgfVxuXG4gIF9yZWNvbnN0cnVjdFRyYWplY3RvcnkoaW5kZXgsIGNvc3RUYWJsZSwgY3ViaWNQYXRoUGFyYW1zLCBjdWJpY1BhdGhGcm9tVmVoaWNsZVBhcmFtcywgcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtcywgdmVoaWNsZVBvc2UsIGxhdHRpY2UpIHtcbiAgICBsZXQgdW5wYWNrZWQgPSB0aGlzLl91bnBhY2tDb3N0VGFibGVJbmRleChpbmRleCk7XG4gICAgdW5wYWNrZWQucHVzaChjb3N0VGFibGVbaW5kZXggKiA0ICsgMV0pO1xuICAgIGNvbnN0IG5vZGVzID0gW3VucGFja2VkXTtcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgd2hpbGUgKHVucGFja2VkWzBdID49IDAgJiYgY291bnQrKyA8IDEwMCkge1xuICAgICAgaW5kZXggPSBjb3N0VGFibGVbaW5kZXggKiA0ICsgM107XG4gICAgICB1bnBhY2tlZCA9IHRoaXMuX3VucGFja0Nvc3RUYWJsZUluZGV4KGluZGV4KTtcblxuICAgICAgY29uc3QgZmluYWxWZWxvY2l0eSA9IHVucGFja2VkWzBdID49IDAgPyBjb3N0VGFibGVbaW5kZXggKiA0ICsgMV0gOiB2ZWhpY2xlUG9zZS52ZWxvY2l0eTtcbiAgICAgIHVucGFja2VkLnB1c2goZmluYWxWZWxvY2l0eSk7XG5cbiAgICAgIG5vZGVzLnVuc2hpZnQodW5wYWNrZWQpO1xuICAgIH1cbiAgICBpZiAoY291bnQgPj0gMTAwKSB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZW5jb3VudGVyZWQgd2hpbGUgcmVjb25zdHJ1Y3RpbmcgdHJhamVjdG9yeS4nKTtcblxuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGxldCBmcm9tVmVoaWNsZVNlZ21lbnQgPSBbXTtcbiAgICBsZXQgZnJvbVZlaGljbGVQYXJhbXMgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IFtwcmV2U3RhdGlvbiwgcHJldkxhdGl0dWRlLCBfcHQsIF9wdiwgX3BhLCBwcmV2VmVsb2NpdHldID0gbm9kZXNbaV07XG4gICAgICBjb25zdCBbc3RhdGlvbiwgbGF0aXR1ZGUsIF90LCBfdiwgX2EsIHZlbG9jaXR5XSA9IG5vZGVzW2kgKyAxXTtcblxuICAgICAgbGV0IGxlbmd0aDtcbiAgICAgIGxldCBwYXRoQnVpbGRlcjtcblxuICAgICAgaWYgKHByZXZTdGF0aW9uIDwgMCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHtcbiAgICAgICAgICBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKDAsIDApLFxuICAgICAgICAgIHJvdDogMCxcbiAgICAgICAgICBjdXJ2OiB2ZWhpY2xlUG9zZS5jdXJ2XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSAoc3RhdGlvbiAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgbGF0aXR1ZGUpICogNDtcbiAgICAgICAgY29uc3QgZW5kID0ge1xuICAgICAgICAgIHBvczogbmV3IFRIUkVFLlZlY3RvcjIobGF0dGljZVtlbmRJbmRleF0sIGxhdHRpY2VbZW5kSW5kZXggKyAxXSksXG4gICAgICAgICAgcm90OiBsYXR0aWNlW2VuZEluZGV4ICsgMl0sXG4gICAgICAgICAgY3VydjogbGF0dGljZVtlbmRJbmRleCArIDNdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByZXZMYXRpdHVkZSA9PSAwKSB7IC8vIEN1YmljIHBhdGggZnJvbSB2ZWhpY2xlIHRvIGxhdHRpY2Ugbm9kZVxuICAgICAgICAgIGxlbmd0aCA9IGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4ICsgMl07XG5cbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwMTogY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXhdLFxuICAgICAgICAgICAgcDI6IGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4ICsgMV0sXG4gICAgICAgICAgICBzRzogbGVuZ3RoXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHBhdGhCdWlsZGVyID0gbmV3IEN1YmljUGF0aChzdGFydCwgZW5kLCBwYXJhbXMpO1xuXG4gICAgICAgICAgZnJvbVZlaGljbGVQYXJhbXMgPSB7IHR5cGU6ICdjdWJpYycsIHBhcmFtczogcGFyYW1zIH07XG4gICAgICAgIH0gZWxzZSB7IC8vIFF1aW50aWMgcGF0aCBmcm9tIHZlaGljbGUgdG8gbGF0dGljZSBub2RlXG4gICAgICAgICAgbGVuZ3RoID0gcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleCArIDJdO1xuXG4gICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgcDM6IHF1aW50aWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXhdLFxuICAgICAgICAgICAgcDQ6IHF1aW50aWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAxXSxcbiAgICAgICAgICAgIHNHOiBsZW5ndGhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcGF0aEJ1aWxkZXIgPSBuZXcgUXVpbnRpY1BhdGgoc3RhcnQsIGVuZCwgcGFyYW1zKTtcblxuICAgICAgICAgIGZyb21WZWhpY2xlUGFyYW1zID0geyB0eXBlOiAncXVpbnRpYycsIHBhcmFtczogcGFyYW1zIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAocHJldlN0YXRpb24gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIHByZXZMYXRpdHVkZSkgKiA0O1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IChzdGF0aW9uICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBsYXRpdHVkZSkgKiA0O1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0ge1xuICAgICAgICAgIHBvczogbmV3IFRIUkVFLlZlY3RvcjIobGF0dGljZVtzdGFydEluZGV4XSwgbGF0dGljZVtzdGFydEluZGV4ICsgMV0pLFxuICAgICAgICAgIHJvdDogbGF0dGljZVtzdGFydEluZGV4ICsgMl0sXG4gICAgICAgICAgY3VydjogbGF0dGljZVtzdGFydEluZGV4ICsgM11cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbmQgPSB7XG4gICAgICAgICAgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihsYXR0aWNlW2VuZEluZGV4XSwgbGF0dGljZVtlbmRJbmRleCArIDFdKSxcbiAgICAgICAgICByb3Q6IGxhdHRpY2VbZW5kSW5kZXggKyAyXSxcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW2VuZEluZGV4ICsgM11cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzbEluZGV4ID0gc3RhdGlvbiAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgbGF0aXR1ZGU7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eUluZGV4ID0gKHByZXZTdGF0aW9uIC0gc3RhdGlvbiArIHRoaXMuY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSkgKiB0aGlzLmNvbmZpZy5sYXR0aWNlLmxhdGl0dWRlQ29ubmVjdGl2aXR5ICsgcHJldkxhdGl0dWRlIC0gbGF0aXR1ZGUgKyBNYXRoLmZsb29yKHRoaXMuY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyKTtcbiAgICAgICAgY29uc3QgY3ViaWNQYXRoSW5kZXggPSAoY29ubmVjdGl2aXR5SW5kZXggKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBzbEluZGV4KSAqIDQ7XG5cbiAgICAgICAgbGVuZ3RoID0gY3ViaWNQYXRoUGFyYW1zW2N1YmljUGF0aEluZGV4ICsgMl07XG5cbiAgICAgICAgcGF0aEJ1aWxkZXIgPSBuZXcgQ3ViaWNQYXRoKHN0YXJ0LCBlbmQsIHtcbiAgICAgICAgICBwMTogY3ViaWNQYXRoUGFyYW1zW2N1YmljUGF0aEluZGV4XSxcbiAgICAgICAgICBwMjogY3ViaWNQYXRoUGFyYW1zW2N1YmljUGF0aEluZGV4ICsgMV0sXG4gICAgICAgICAgc0c6IGxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aCA9IHBhdGhCdWlsZGVyLmJ1aWxkUGF0aChNYXRoLmNlaWwobGVuZ3RoIC8gMC4yNSkpO1xuXG4gICAgICBjb25zdCBwcmV2VmVsb2NpdHlTcSA9IHByZXZWZWxvY2l0eSAqIHByZXZWZWxvY2l0eTtcbiAgICAgIGNvbnN0IGFjY2VsID0gKHZlbG9jaXR5ICogdmVsb2NpdHkgLSBwcmV2VmVsb2NpdHlTcSkgLyAyIC8gbGVuZ3RoO1xuICAgICAgY29uc3QgZHMgPSBsZW5ndGggLyAocGF0aC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBzID0gMDtcblxuICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXRoLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHBhdGhbcF0udmVsb2NpdHkgPSBNYXRoLnNxcnQoMiAqIGFjY2VsICogcyArIHByZXZWZWxvY2l0eVNxKTtcbiAgICAgICAgcGF0aFtwXS5hY2NlbGVyYXRpb24gPSBhY2NlbDtcbiAgICAgICAgcyArPSBkcztcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZTdGF0aW9uIDwgMCkge1xuICAgICAgICBmcm9tVmVoaWNsZVNlZ21lbnQgPSBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIHBvaW50cy5wdXNoKC4uLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmaXJzdExhdHRpY2VQb2ludCA9IG51bGxcbiAgICBsZXQgZmlyc3RBY2NlbGVyYXRpb24gPSBudWxsO1xuICAgIGxldCBzZWNvbmRMYXR0aWNlUG9pbnQgPSBudWxsO1xuICAgIGxldCBzZWNvbmRBY2NlbGVyYXRpb24gPSBudWxsO1xuXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBmaXJzdExhdHRpY2VQb2ludCA9IG5vZGVzWzFdWzBdICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBub2Rlc1sxXVsxXTtcbiAgICAgIGZpcnN0QWNjZWxlcmF0aW9uID0gbm9kZXNbMV1bNF07XG4gICAgfVxuXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBzZWNvbmRMYXR0aWNlUG9pbnQgPSBub2Rlc1syXVswXSAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgbm9kZXNbMl1bMV07XG4gICAgICBzZWNvbmRBY2NlbGVyYXRpb24gPSBub2Rlc1syXVs0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3BvaW50cywgZnJvbVZlaGljbGVTZWdtZW50LCBmcm9tVmVoaWNsZVBhcmFtcywgZmlyc3RMYXR0aWNlUG9pbnQsIGZpcnN0QWNjZWxlcmF0aW9uLCBzZWNvbmRMYXR0aWNlUG9pbnQsIHNlY29uZEFjY2VsZXJhdGlvbl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdmVoaWNsZVRyYW5zZm9ybSh7IHBvcywgcm90IH0pIHtcbiAgY29uc3QgdHJhbnNsYXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgdHJhbnNsYXRlLnNldChcbiAgICAxLCAwLCAtcG9zLngsXG4gICAgMCwgMSwgLXBvcy55LFxuICAgIDAsIDAsIDFcbiAgKTtcblxuICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyhyb3QpO1xuICBjb25zdCBzaW5Sb3QgPSBNYXRoLnNpbihyb3QpO1xuXG4gIGNvbnN0IHJvdGF0ZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gIHJvdGF0ZS5zZXQoXG4gICAgY29zUm90LCBzaW5Sb3QsIDAsXG4gICAgLXNpblJvdCwgY29zUm90LCAwLFxuICAgIDAsIDAsIDFcbiAgKTtcblxuICByZXR1cm4gcm90YXRlLm11bHRpcGx5KHRyYW5zbGF0ZSk7XG59XG5cbmZ1bmN0aW9uIG9ic3RhY2xlVHJhbnNmb3JtKHZlaGljbGVYZm9ybSwgeHlDZW50ZXJQb2ludCwgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICB0cmFuc2xhdGUuc2V0KFxuICAgIDEsIDAsIC14eUNlbnRlclBvaW50LngsXG4gICAgMCwgMSwgLXh5Q2VudGVyUG9pbnQueSxcbiAgICAwLCAwLCAxXG4gICk7XG5cbiAgY29uc3Qgc2NhbGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICBzY2FsZS5zZXQoXG4gICAgMiAvIHdpZHRoLCAwLCAwLFxuICAgIDAsIDIgLyBoZWlnaHQsIDAsXG4gICAgMCwgMCwgMVxuICApO1xuXG4gIHJldHVybiBzY2FsZS5tdWx0aXBseSh0cmFuc2xhdGUpLm11bHRpcGx5KHZlaGljbGVYZm9ybSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///6\\n\")},,function(module,exports){eval(\"throw new Error(\\\"Module parse failed: Unexpected character '' (1:2)\\\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\\\n(Source code omitted for this binary file)\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI4LmpzIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///8\\n\")},,,,,,function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('// ESM COMPAT FLAG\\n__webpack_require__.r(__webpack_exports__);\\n\\n// EXTERNAL MODULE: ./js/physics/Car.js\\nvar Car = __webpack_require__(0);\\n\\n// CONCATENATED MODULE: ./js/physics/Physics.js\\n\\n\\nclass Physics_Physics {\\n  constructor() {\\n    this.cars = [];\\n  }\\n\\n  step(dt) {\\n    this.cars.forEach(c => c.step(dt));\\n  }\\n\\n  createCar() {\\n    const newCar = new Car[\"a\" /* default */]();\\n    this.cars.push(newCar);\\n\\n    return newCar;\\n  }\\n};\\n\\n// CONCATENATED MODULE: ./js/autonomy/Path.js\\n\\n\\n// input pose: { pos: Vector2 [, rot: radians] }\\n// pose: { pos: Vector2, frontPos: Vector2, fakePos: Vector2, rot: radians }\\nclass Path_Path {\\n  constructor(poses, startRotation = 0, goalRotation = 0) {\\n    this.poses = poses;\\n\\n    for (let i = 0; i < poses.length; i++) {\\n      const pose = poses[i];\\n\\n      if (pose.rot === undefined) {\\n        let rot;\\n\\n        if (i == 0) {\\n          rot = startRotation;\\n        } else if (i == poses.length - 1) {\\n          rot = goalRotation;\\n        } else {\\n          const prev = poses[i - 1].pos;\\n          const next = poses[i + 1].pos;\\n          rot = Math.atan2(next.y - prev.y, next.x - prev.x);\\n        }\\n\\n        pose.rot = rot;\\n      }\\n\\n      pose.frontPos = Car[\"a\" /* default */].getFrontAxlePosition(pose.pos, pose.rot);\\n      pose.fakePos = Car[\"a\" /* default */].getFakeAxlePosition(pose.pos, pose.rot);\\n    }\\n  }\\n}\\n\\n// EXTERNAL MODULE: ./js/autonomy/path-planning/CubicPath.js\\nvar CubicPath = __webpack_require__(2);\\n\\n// CONCATENATED MODULE: ./js/autonomy/control/AutonomousController.js\\n\\n\\nclass AutonomousController_AutonomousController {\\n  constructor(path) {\\n    this.path = path;\\n    this.nextIndex = 1;\\n    this.prevPhiError = 0;\\n    this.prevVelocity = 0;\\n  }\\n\\n  reset() {\\n    this.prevVelocity = 0;\\n  }\\n\\n  replacePath(path) {\\n    this.path = path;\\n    this.nextIndex = 1;\\n  }\\n\\n  predictPoseAfterTime(currentPose, predictionTime) {\\n    const pathPoses = this.path.poses;\\n    const frontAxlePos = Car[\"a\" /* default */].getFrontAxlePosition(currentPose.pos, currentPose.rot);\\n    let [nextIndex, progress] = this.findNextIndex(frontAxlePos);\\n    let currentVelocity = currentPose.velocity;\\n\\n    if (currentVelocity <= 0.01) return currentPose;\\n\\n    while (predictionTime > 0) {\\n      const prevPose = pathPoses[nextIndex - 1];\\n      const nextPose = pathPoses[nextIndex];\\n\\n      const segmentDist = nextPose.pos.distanceTo(prevPose.pos);\\n      const distLeft = segmentDist * (1 - progress);\\n      const sumV = currentVelocity + nextPose.velocity;\\n      const timeToNextIndex = 2 * distLeft / (sumV == 0 ? 0.01 : sumV);\\n      //const timeToNextIndex = distLeft / currentVelocity;\\n\\n      if (timeToNextIndex >= predictionTime || nextIndex + 1 >= pathPoses.length) {\\n        const dist = sumV / 2 * predictionTime;\\n        const newProgress = progress + dist / segmentDist;\\n\\n        return {\\n          pos: nextPose.pos.clone().sub(prevPose.pos).multiplyScalar(newProgress).add(nextPose.pos),\\n          rot: prevPose.rot + (nextPose.rot - prevPose.rot) * newProgress,\\n          curv: prevPose.curv + (nextPose.curv - prevPose.curv) * newProgress,\\n          dCurv: 0,\\n          ddCurv: 0,\\n          velocity: nextPose.velocity\\n        }\\n      }\\n\\n      //currentVelocity = nextPose.velocity;\\n      predictionTime -= timeToNextIndex;\\n      progress = 0;\\n      nextIndex++;\\n    }\\n  }\\n\\n  control(pose, wheelAngle, velocity, dt) {\\n    const pathPoses = this.path.poses;\\n    const frontAxlePos = Car[\"a\" /* default */].getFrontAxlePosition(pose.pos, pose.rot);\\n    const [nextIndex, progress] = this.findNextIndex(frontAxlePos);\\n    this.nextIndex = nextIndex;\\n\\n    let gas = 0;\\n    let brake = 0;\\n    let phi = 0; // the desired wheel deflection\\n\\n    if (nextIndex >= pathPoses.length - 1 && progress >= 1) {\\n      gas = 0;\\n      brake = 1;\\n      phi = 0;\\n    } else {\\n      const kp_a = 4;\\n      const kd_a = 0.5;\\n      const kff_a = 0.5;\\n\\n      const currentAccel = (velocity - this.prevVelocity) / dt;\\n      const prevNextDist = pathPoses[this.nextIndex].pos.distanceTo(pathPoses[this.nextIndex - 1].pos);\\n      const targetVelocity = Math.sqrt(2 * pathPoses[nextIndex].acceleration * prevNextDist * Math.clamp(progress, 0, 1) + pathPoses[this.nextIndex - 1].velocity * pathPoses[this.nextIndex - 1].velocity);\\n      const diffVelocity = targetVelocity - velocity;\\n      const diffAccel = pathPoses[this.nextIndex].acceleration - currentAccel;\\n      const targetAccel = kp_a * diffVelocity + kd_a * diffAccel + kff_a * pathPoses[this.nextIndex].acceleration;\\n\\n      if (targetAccel > 0)\\n        gas = Math.min(targetAccel / Car[\"a\" /* default */].MAX_GAS_ACCEL, 1);\\n      else\\n        brake = Math.min(-targetAccel / Car[\"a\" /* default */].MAX_BRAKE_DECEL, 1);\\n\\n      this.prevVelocity = velocity;\\n\\n      const closestFrontPathPos = projectPointOnSegment(frontAxlePos, pathPoses[this.nextIndex - 1].frontPos, pathPoses[this.nextIndex].frontPos)[0];\\n\\n      // Determine the desired heading at the specific point on the front path by lerping between prevHeading and nextHeading using progress as the weight\\n      const prevHeading = this.nextIndex > 1 ? pathPoses[nextIndex].frontPos.clone().sub(pathPoses[nextIndex - 2].frontPos).angle() : pathPoses[0].rot;\\n      const nextHeading = this.nextIndex < pathPoses.length - 1 ? pathPoses[nextIndex + 1].frontPos.clone().sub(pathPoses[nextIndex - 1].frontPos).angle() : pathPoses[pathPoses.length - 1].rot;\\n      const desiredHeading = prevHeading + (nextHeading - prevHeading) * progress;\\n\\n      // Determine if the front axle is to the left or right of the front path\\n      const pathVec = pathPoses[nextIndex].frontPos.clone().sub(pathPoses[nextIndex - 1].frontPos).normalize();\\n      const zero = new THREE.Vector2(0, 0);\\n      const left = pathVec.clone().rotateAround(zero, Math.PI / 2).add(closestFrontPathPos);\\n      const right = pathVec.clone().rotateAround(zero, -Math.PI / 2).add(closestFrontPathPos);\\n      const dir = frontAxlePos.distanceToSquared(left) < frontAxlePos.distanceToSquared(right) ? -1 : 1;\\n\\n      const k = 4;\\n      const gain = 0.8;\\n      const crossTrackError = frontAxlePos.distanceTo(closestFrontPathPos);\\n      const headingError = Math.wrapAngle(pose.rot - desiredHeading);\\n\\n      //phi = -headingError + gain * Math.atan(k * dir * crossTrackError / velocity);\\n\\n      const curv = pathPoses[nextIndex - 1].curv + (pathPoses[nextIndex].curv - pathPoses[nextIndex - 1].curv) * progress;\\n\\n      phi = Math.atan(curv * Car[\"a\" /* default */].WHEEL_BASE) + gain * Math.atan(k * dir * crossTrackError / Math.max(velocity, 0.01));\\n\\n      const checkSteer = Math.clamp((phi - wheelAngle) / dt / Car[\"a\" /* default */].MAX_STEER_SPEED, -1, 1);\\n    }\\n\\n    const phiError = phi - wheelAngle;\\n    /*\\n    const dPhiError = (phiError - this.prevPhiError) / dt;\\n    this.prevPhiError = phiError;\\n    \\n    const steer = Math.clamp(12 * phiError + 0.8 * dPhiError, -1, 1);\\n    */\\n\\n    const steer = Math.clamp(phiError / dt / Car[\"a\" /* default */].MAX_STEER_SPEED, -1, 1);\\n\\n    return { gas, brake, steer };\\n  }\\n\\n  // Finds the next point the vehicle is approaching and the progress between the prev point and the next point\\n  // Returns [nextPointIndex, progress from (nextPointIndex - 1) to nextPointIndex, {0 - 1}]\\n  findNextIndex(frontAxlePos) {\\n    const pathPoses = this.path.poses;\\n\\n    // Constrain the search to just a few points surrounding the current nextIndex\\n    // for performance and to avoid problems with a path that crosses itself\\n    const start = Math.max(0, this.nextIndex - 20);\\n    const end = Math.min(pathPoses.length - 1, this.nextIndex + 20);\\n    let closestDistSqr = frontAxlePos.distanceToSquared(pathPoses[start].frontPos);\\n    let closestIndex = start;\\n\\n    for (let i = start + 1; i < end; i++) {\\n      const distSqr = frontAxlePos.distanceToSquared(pathPoses[i].frontPos);\\n      if (distSqr < closestDistSqr) {\\n        closestDistSqr = distSqr;\\n        closestIndex = i;\\n      }\\n    }\\n\\n    if (closestIndex == pathPoses.length - 1) {\\n      const [_, progress] = projectPointOnSegment(frontAxlePos, pathPoses[closestIndex - 1].frontPos, pathPoses[closestIndex].frontPos);\\n      return [closestIndex, progress];\\n    } else if (closestIndex == 0) {\\n      const [_, progress] = projectPointOnSegment(frontAxlePos, pathPoses[closestIndex].frontPos, pathPoses[closestIndex + 1].frontPos);\\n      return [closestIndex + 1, progress];\\n    } else {\\n      // The nextPoint is either (closestPoint) or (closestPoint + 1). Project the frontAxlePos to both\\n      // of those two line segments (the segment preceding closestPoint and the segment succeeding closestPoint)\\n      // to determine which segment it\\'s closest to.\\n      const [precedingProjection, precedingProgress] = projectPointOnSegment(frontAxlePos, pathPoses[closestIndex - 1].frontPos, pathPoses[closestIndex].frontPos);\\n      const [succeedingProjection, succeedingProgress] = projectPointOnSegment(frontAxlePos, pathPoses[closestIndex].frontPos, pathPoses[closestIndex + 1].frontPos);\\n\\n      if (frontAxlePos.distanceToSquared(precedingProjection) < frontAxlePos.distanceToSquared(succeedingProjection)) {\\n        return [closestIndex, precedingProgress];\\n      } else {\\n        return [closestIndex + 1, succeedingProgress];\\n      }\\n    }\\n  }\\n}\\n\\n// Returns [pointOnSegment, progressAlongSegment {0 - 1}]\\nfunction projectPointOnSegment(point, start, end) {\\n  const distSqr = start.distanceToSquared(end);\\n  //const progress = Math.clamp(point.clone().sub(start).dot(end.clone().sub(start)) / distSqr, 0, 1);\\n  const progress = point.clone().sub(start).dot(end.clone().sub(start)) / distSqr;\\n  return [end.clone().sub(start).multiplyScalar(progress).add(start), progress];\\n}\\n\\n// CONCATENATED MODULE: ./js/autonomy/control/FollowController.js\\n\\n\\nclass FollowController_FollowController {\\n  constructor(path, car) {\\n    this.path = path;\\n    this.car = car;\\n    this.nextIndex = 1;\\n    this.prevVelocity = 0;\\n    this.prevAccel = 0;\\n  }\\n\\n  reset() {\\n    this.prevVelocity = 0;\\n    this.prevAccel = 0;\\n  }\\n\\n  replacePath(path) {\\n    this.path = path;\\n    this.nextIndex = 1;\\n  }\\n\\n  predictPoseAfterTime(currentPose, predictionTime) {\\n    const pathPoses = this.path.poses;\\n    let [nextIndex, progress] = this.findNextIndex(currentPose.pos);\\n    let currentVelocity = currentPose.velocity;\\n\\n    if (currentVelocity <= 0.01) return currentPose;\\n\\n    while (predictionTime > 0) {\\n      const prevPose = pathPoses[nextIndex - 1];\\n      const nextPose = pathPoses[nextIndex];\\n\\n      const segmentDist = nextPose.pos.distanceTo(prevPose.pos);\\n      const distLeft = segmentDist * (1 - progress);\\n      const sumV = (currentVelocity + nextPose.velocity) / 2;\\n      const timeToNextIndex = 2 * distLeft / (sumV == 0 ? 0.01 : sumV);\\n\\n      if (timeToNextIndex >= predictionTime || nextIndex + 1 >= pathPoses.length) {\\n        const dist = sumV / 2 * predictionTime;\\n        const newProgress = progress + dist / segmentDist;\\n        const newRotation = Math.wrapAngle(prevPose.rot + Math.wrapAngle(nextPose.rot - prevPose.rot) * newProgress);\\n\\n        const pprevPose = nextIndex - 2 >= 0 ? pathPoses[nextIndex - 2] : prevPose;\\n        const nnextPose = nextIndex + 1 < pathPoses.length ? pathPoses[nextIndex + 1] : nextPose;\\n\\n        const dCurv = (nextPose.curv - prevPose.curv) / segmentDist;\\n        const dCurvPrev = ((prevPose.curv - pprevPose.curv) / pprevPose.pos.distanceTo(prevPose.pos) + dCurv) / 2;\\n        const dCurvNext = (dCurv + (nnextPose.curv - nextPose.curv) / nextPose.pos.distanceTo(nnextPose.pos)) / 2;\\n\\n        const ddCurv = (dCurvNext - dCurvPrev) / segmentDist;\\n\\n        return {\\n          pos: nextPose.pos.clone().sub(prevPose.pos).multiplyScalar(newProgress).add(nextPose.pos),\\n          rot: newRotation,\\n          curv: prevPose.curv + (nextPose.curv - prevPose.curv) * newProgress,\\n          dCurv: dCurv,\\n          ddCurv: ddCurv,\\n          velocity: nextPose.velocity\\n        }\\n      }\\n\\n      currentVelocity = nextPose.velocity;\\n      predictionTime -= timeToNextIndex;\\n      progress = 0;\\n      nextIndex++;\\n    }\\n  }\\n\\n  control(pose, wheelAngle, velocity, dt, lockPath = false) {\\n    const pathPoses = this.path.poses;\\n    const [nextIndex, progress, projection] = this.findNextIndex(pose.pos);\\n    this.nextIndex = nextIndex;\\n\\n    const prevPose = pathPoses[nextIndex - 1];\\n    const nextPose = pathPoses[nextIndex];\\n\\n    let gas = 0;\\n    let brake = 0;\\n    let steer = 0;\\n\\n    if (nextIndex >= pathPoses.length - 2 && progress >= 1) {\\n      brake = 1;\\n    } else {\\n      /*\\n      const kp_a = 4;\\n      const kd_a = 0.5;\\n      const kff_a = 0.5;\\n\\n      const currentAccel = (velocity - this.prevVelocity) / dt;\\n      const prevNextDist = nextPose.pos.distanceTo(prevPose.pos);\\n      const targetVelocity = Math.sqrt(2 * nextPose.acceleration * prevNextDist * Math.clamp(progress, 0, 1) + prevPose.velocity * prevPose.velocity);\\n      const diffVelocity = targetVelocity - velocity;\\n      const diffAccel = nextPose.acceleration - currentAccel;\\n      const targetAccel = kp_a * diffVelocity + kd_a * diffAccel + kff_a * nextPose.acceleration;\\n      */\\n      const accelDamping = 0.1;\\n      const targetAccel = nextPose.acceleration;\\n      const dampedAccel = this.prevAccel * (1 - accelDamping) + targetAccel * accelDamping;\\n\\n      if (dampedAccel > 0)\\n        gas = Math.min(dampedAccel / Car[\"a\" /* default */].MAX_GAS_ACCEL, 1);\\n      else\\n        brake = Math.min(-dampedAccel / Car[\"a\" /* default */].MAX_BRAKE_DECEL, 1);\\n\\n      this.prevVelocity = velocity;\\n      this.prevAccel = dampedAccel;\\n\\n      const curvature = prevPose.curv + (nextPose.curv - prevPose.curv) * progress;\\n      const desiredWheelAngle = Math.atan(curvature * Car[\"a\" /* default */].WHEEL_BASE);\\n      const wheelAngleError = desiredWheelAngle - wheelAngle;\\n      steer = Math.clamp(wheelAngleError / dt / Car[\"a\" /* default */].MAX_STEER_SPEED, -1, 1);\\n\\n      if (lockPath) {\\n        const damping = 0.1;\\n        const newRotation = Math.wrapAngle(prevPose.rot + Math.wrapAngle(nextPose.rot - prevPose.rot) * progress);\\n        const newPosition = new THREE.Vector2(projection.x - Car[\"a\" /* default */].REAR_AXLE_POS * Math.cos(newRotation), projection.y - Car[\"a\" /* default */].REAR_AXLE_POS * Math.sin(newRotation));\\n\\n        if (Math.abs(Math.wrapAngle(newRotation - this.car.rotation)) > 0.5) {\\n          console.log(\\'wut\\');\\n        }\\n\\n        this.car.rotation += damping * Math.wrapAngle(newRotation - this.car.rotation);\\n        this.car.position = this.car.position.clone().multiplyScalar(1 - damping).add(newPosition.multiplyScalar(damping));\\n      }\\n    }\\n\\n    return { gas, brake, steer };\\n  }\\n\\n  findNextIndex(pos) {\\n    const pathPoses = this.path.poses;\\n\\n    // Constrain the search to just a few points surrounding the current nextIndex\\n    // for performance and to avoid problems with a path that crosses itself\\n    const start = Math.max(0, this.nextIndex - 20);\\n    const end = Math.min(pathPoses.length - 1, this.nextIndex + 20);\\n    let closestDistSqr = pos.distanceToSquared(pathPoses[start].pos);\\n    let closestIndex = start;\\n\\n    for (let i = start + 1; i < end; i++) {\\n      const distSqr = pos.distanceToSquared(pathPoses[i].pos);\\n      if (distSqr < closestDistSqr) {\\n        closestDistSqr = distSqr;\\n        closestIndex = i;\\n      }\\n    }\\n\\n    if (closestIndex == pathPoses.length - 1) {\\n      const [projection, progress] = FollowController_projectPointOnSegment(pos, pathPoses[closestIndex - 1].pos, pathPoses[closestIndex].pos);\\n      return [closestIndex, progress, projection];\\n    } else if (closestIndex == 0) {\\n      const [projection, progress] = FollowController_projectPointOnSegment(pos, pathPoses[closestIndex].pos, pathPoses[closestIndex + 1].pos);\\n      return [closestIndex + 1, progress, projection];\\n    } else {\\n      // The nextPoint is either (closestPoint) or (closestPoint + 1). Project the pos to both\\n      // of those two line segments (the segment preceding closestPoint and the segment succeeding closestPoint)\\n      // to determine which segment it\\'s closest to.\\n      const [precedingProjection, precedingProgress] = FollowController_projectPointOnSegment(pos, pathPoses[closestIndex - 1].pos, pathPoses[closestIndex].pos);\\n      const [succeedingProjection, succeedingProgress] = FollowController_projectPointOnSegment(pos, pathPoses[closestIndex].pos, pathPoses[closestIndex + 1].pos);\\n\\n      if (pos.distanceToSquared(precedingProjection) < pos.distanceToSquared(succeedingProjection)) {\\n        return [closestIndex, precedingProgress, precedingProjection];\\n      } else {\\n        return [closestIndex + 1, succeedingProgress, succeedingProjection];\\n      }\\n    }\\n  }\\n}\\n\\n// Returns [pointOnSegment, progressAlongSegment {0 - 1}]\\nfunction FollowController_projectPointOnSegment(point, start, end) {\\n  const distSqr = start.distanceToSquared(end);\\n  const progress = point.clone().sub(start).dot(end.clone().sub(start)) / distSqr;\\n  return [end.clone().sub(start).multiplyScalar(progress).add(start), progress];\\n}\\n\\n// CONCATENATED MODULE: ./js/autonomy/control/ManualController.js\\nclass ManualController {\\n  constructor() {\\n    this.carKeys = { forward: false, backward: false, left: false, right: false, brake: false };\\n\\n    document.addEventListener(\\'keydown\\', event => {\\n      switch (event.key) {\\n        case \\'w\\': case \\'W\\': this.carKeys.forward = true; break;\\n        case \\'s\\': case \\'S\\': this.carKeys.backward = true; break;\\n        case \\'a\\': case \\'A\\': this.carKeys.left = true; break;\\n        case \\'d\\': case \\'D\\': this.carKeys.right = true; break;\\n        case \\' \\': this.carKeys.brake = true; break;\\n      }\\n    });\\n\\n    document.addEventListener(\\'keyup\\', event => {\\n      switch (event.key) {\\n        case \\'w\\': case \\'W\\': this.carKeys.forward = false; break;\\n        case \\'s\\': case \\'S\\': this.carKeys.backward = false; break;\\n        case \\'a\\': case \\'A\\': this.carKeys.left = false; break;\\n        case \\'d\\': case \\'D\\': this.carKeys.right = false; break;\\n        case \\' \\': this.carKeys.brake = false; break;\\n      }\\n    });\\n  }\\n\\n  control() {\\n    let gas = 0;\\n    let brake = 0;\\n    let steer = 0;\\n\\n    if (this.carKeys.forward) gas += 1;\\n    if (this.carKeys.backward) gas -= 1;\\n    if (this.carKeys.left) steer -= 1;\\n    if (this.carKeys.right) steer += 1;\\n    if (this.carKeys.brake) brake += 1;\\n\\n    return { gas, brake, steer };\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/objects/MapObject.js\\n// geolocation = [33.523900, -111.908756];\\nclass MapObject extends THREE.Object3D {\\n  constructor(geolocation = null) {\\n    super();\\n\\n    this.geolocation = geolocation;\\n    this.tilesGroup = null;\\n\\n    const tileSize = geolocation ? this.tileSizeInMeters() : 10;\\n    const grid = new THREE.GridHelper(MapObject.HALF_NUM_TILES * 8 * tileSize, MapObject.HALF_NUM_TILES * 8, 0x333333, 0x333333);\\n    grid.renderOrder = -1;\\n    grid.material.depthTest = false;\\n    grid.position.add(new THREE.Vector3(-tileSize / 2, 0, -tileSize / 2));\\n    this.add(grid);\\n\\n    if (geolocation)\\n      this.drawTiles();\\n  }\\n\\n  // Converts lat-long geolocation to Google Maps world coodinates\\n  static geoToWorld(latlng) {\\n    const latitudeRadians = latlng[0] * Math.PI / 180;\\n    const x = (latlng[1] + 180) / 360 * 256;\\n    const y = ((1 - Math.log(Math.tan(latitudeRadians) + 1 / Math.cos(latitudeRadians)) / Math.PI) / 2) * 256;\\n    return [x, y];\\n  }\\n\\n  // Calculates the x and y tile indices for the provided world coordinates\\n  static worldToTile(worldCoordinates) {\\n    return [Math.floor(worldCoordinates[0] * MapObject.SCALE / 256), Math.floor(worldCoordinates[1] * MapObject.SCALE / 256)];\\n  }\\n\\n  drawTiles() {\\n    if (this.tileGroup != null) this.remove(this.tilesGroup);\\n    this.tileGroup = new THREE.Group();\\n\\n    const originTile = MapObject.worldToTile(MapObject.geoToWorld(this.geolocation));\\n    const tileSize = this.tileSizeInMeters();\\n\\n    for (let x = -MapObject.HALF_NUM_TILES, h = 0; x < MapObject.HALF_NUM_TILES; x++) {\\n      for (let y = -MapObject.HALF_NUM_TILES; y < MapObject.HALF_NUM_TILES; y++, h++) {\\n        const tileTexture = new THREE.TextureLoader().load(`https://khms${h % 4}.google.com/kh/v=748?x=${originTile[0] + x}&y=${originTile[1] + y}&z=${MapObject.ZOOM}`);\\n        tileTexture.anisotropy = 16;\\n        const tileGeometry = new THREE.PlaneBufferGeometry(tileSize, tileSize);\\n        const tileMaterial = new THREE.MeshBasicMaterial({ map: tileTexture, color: 0xffffff });\\n        const tile = new THREE.Mesh(tileGeometry, tileMaterial);\\n        tile.rotation.x = -Math.PI / 2;\\n        tile.position.x = x * tileSize;\\n        tile.position.z = y * tileSize;\\n\\n        this.tileGroup.add(tile);\\n      }\\n    }\\n\\n    this.add(this.tileGroup);\\n  }\\n\\n  tileSizeInMeters() {\\n    // Because of the Mercator projection used to create the tile images, the size of a tile (in meters) depends on the latitude\\n    return 2 * Math.PI * MapObject.EARTH_RADIUS * Math.cos(this.geolocation[0] * Math.PI / 180) / Math.pow(2, MapObject.ZOOM);\\n  }\\n}\\n\\nMapObject.EARTH_RADIUS = 6378137; // meters\\nMapObject.TILE_PIXELS = 256; // pixels per tile\\nMapObject.ZOOM = 20;\\nMapObject.SCALE = 1 << MapObject.ZOOM;\\nMapObject.HALF_NUM_TILES = 20;\\n\\n// CONCATENATED MODULE: ./js/objects/TDSLoader.js\\n/*\\n * Autodesk 3DS threee.js file loader, based on lib3ds.\\n *\\n * Loads geometry with uv and materials basic properties with texture support.\\n *\\n * @author @tentone\\n * @author @timknip\\n * @class TDSLoader\\n * @constructor\\n */\\n\\n\\n\\nTHREE.TDSLoader = function ( manager ) {\\n\\n\\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\\n\\tthis.debug = false;\\n\\n\\tthis.group = null;\\n\\tthis.position = 0;\\n\\n\\tthis.materials = [];\\n\\tthis.meshes = [];\\n\\n};\\n\\nTHREE.TDSLoader.prototype = {\\n\\n\\tconstructor: THREE.TDSLoader,\\n\\n\\t/**\\n\\t * Load 3ds file from url.\\n\\t *\\n\\t * @method load\\n\\t * @param {[type]} url URL for the file.\\n\\t * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\\n\\t * @param {Function} onProgress onProgress callback.\\n\\t * @param {Function} onError onError callback.\\n\\t */\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase( url );\\n\\n\\t\\tvar loader = new THREE.FileLoader( this.manager );\\n\\n\\t\\tloader.setResponseType( \\'arraybuffer\\' );\\n\\n\\t\\tloader.load( url, function ( data ) {\\n\\n\\t\\t\\tonLoad( scope.parse( data, path ) );\\n\\n\\t\\t}, onProgress, onError );\\n\\n\\t},\\n\\n\\t/**\\n\\t * Parse arraybuffer data and load 3ds file.\\n\\t *\\n\\t * @method parse\\n\\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\\n\\t * @param {String} path Path for external resources.\\n\\t * @return {Object3D} Group loaded from 3ds file.\\n\\t */\\n\\tparse: function ( arraybuffer, path ) {\\n\\n\\t\\tthis.group = new THREE.Group();\\n\\t\\tthis.position = 0;\\n\\t\\tthis.materials = [];\\n\\t\\tthis.meshes = [];\\n\\n\\t\\tthis.readFile( arraybuffer, path );\\n\\n\\t\\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\\n\\n\\t\\t\\tthis.group.add( this.meshes[ i ] );\\n\\n\\t\\t}\\n\\n\\t\\treturn this.group;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Decode file content to read 3ds data.\\n\\t *\\n\\t * @method readFile\\n\\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\\n\\t */\\n\\treadFile: function ( arraybuffer, path ) {\\n\\n\\t\\tvar data = new DataView( arraybuffer );\\n\\t\\tvar chunk = this.readChunk( data );\\n\\n\\t\\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\\n\\n\\t\\t\\tvar next = this.nextChunk( data, chunk );\\n\\n\\t\\t\\twhile ( next !== 0 ) {\\n\\n\\t\\t\\t\\tif ( next === M3D_VERSION ) {\\n\\n\\t\\t\\t\\t\\tvar version = this.readDWord( data );\\n\\t\\t\\t\\t\\tthis.debugMessage( \\'3DS file version: \\' + version );\\n\\n\\t\\t\\t\\t} else if ( next === MDATA ) {\\n\\n\\t\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\t\\tthis.readMeshData( data, path );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis.debugMessage( \\'Unknown main chunk: \\' + next.toString( 16 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnext = this.nextChunk( data, chunk );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.debugMessage( \\'Parsed \\' + this.meshes.length + \\' meshes\\' );\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read mesh data chunk.\\n\\t *\\n\\t * @method readMeshData\\n\\t * @param {Dataview} data Dataview in use.\\n\\t */\\n\\treadMeshData: function ( data, path ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar next = this.nextChunk( data, chunk );\\n\\n\\t\\twhile ( next !== 0 ) {\\n\\n\\t\\t\\tif ( next === MESH_VERSION ) {\\n\\n\\t\\t\\t\\tvar version = + this.readDWord( data );\\n\\t\\t\\t\\tthis.debugMessage( \\'Mesh Version: \\' + version );\\n\\n\\t\\t\\t} else if ( next === MASTER_SCALE ) {\\n\\n\\t\\t\\t\\tvar scale = this.readFloat( data );\\n\\t\\t\\t\\tthis.debugMessage( \\'Master scale: \\' + scale );\\n\\t\\t\\t\\tthis.group.scale.set( scale, scale, scale );\\n\\n\\t\\t\\t} else if ( next === NAMED_OBJECT ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'Named Object\\' );\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tthis.readNamedObject( data );\\n\\n\\t\\t\\t} else if ( next === MAT_ENTRY ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'Material\\' );\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tthis.readMaterialEntry( data, path );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'Unknown MDATA chunk: \\' + next.toString( 16 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnext = this.nextChunk( data, chunk );\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read named object chunk.\\n\\t *\\n\\t * @method readNamedObject\\n\\t * @param {Dataview} data Dataview in use.\\n\\t */\\n\\treadNamedObject: function ( data ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar name = this.readString( data, 64 );\\n\\t\\tchunk.cur = this.position;\\n\\n\\t\\tvar next = this.nextChunk( data, chunk );\\n\\t\\twhile ( next !== 0 ) {\\n\\n\\t\\t\\tif ( next === N_TRI_OBJECT ) {\\n\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tvar mesh = this.readMesh( data );\\n\\t\\t\\t\\tmesh.name = name;\\n\\t\\t\\t\\tthis.meshes.push( mesh );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'Unknown named object chunk: \\' + next.toString( 16 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnext = this.nextChunk( data, chunk );\\n\\n\\t\\t}\\n\\n\\t\\tthis.endChunk( chunk );\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read material data chunk and add it to the material list.\\n\\t *\\n\\t * @method readMaterialEntry\\n\\t * @param {Dataview} data Dataview in use.\\n\\t */\\n\\treadMaterialEntry: function ( data, path ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar next = this.nextChunk( data, chunk );\\n\\t\\tvar material = new THREE.MeshPhongMaterial();\\n\\n\\t\\twhile ( next !== 0 ) {\\n\\n\\t\\t\\tif ( next === MAT_NAME ) {\\n\\n\\t\\t\\t\\tmaterial.name = this.readString( data, 64 );\\n\\t\\t\\t\\tthis.debugMessage( \\'   Name: \\' + material.name );\\n\\n\\t\\t\\t} else if ( next === MAT_WIRE ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Wireframe\\' );\\n\\t\\t\\t\\tmaterial.wireframe = true;\\n\\n\\t\\t\\t} else if ( next === MAT_WIRE_SIZE ) {\\n\\n\\t\\t\\t\\tvar value = this.readByte( data );\\n\\t\\t\\t\\tmaterial.wireframeLinewidth = value;\\n\\t\\t\\t\\tthis.debugMessage( \\'   Wireframe Thickness: \\' + value );\\n\\n\\t\\t\\t} else if ( next === MAT_TWO_SIDE ) {\\n\\n\\t\\t\\t\\tmaterial.side = THREE.DoubleSide;\\n\\t\\t\\t\\tthis.debugMessage( \\'   DoubleSided\\' );\\n\\n\\t\\t\\t} else if ( next === MAT_ADDITIVE ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Additive Blending\\' );\\n\\t\\t\\t\\tmaterial.blending = THREE.AdditiveBlending;\\n\\n\\t\\t\\t} else if ( next === MAT_DIFFUSE ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Diffuse Color\\' );\\n\\t\\t\\t\\tmaterial.color = this.readColor( data );\\n\\n\\t\\t\\t} else if ( next === MAT_SPECULAR ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Specular Color\\' );\\n\\t\\t\\t\\tmaterial.specular = this.readColor( data );\\n\\n\\t\\t\\t} else if ( next === MAT_AMBIENT ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Ambient color\\' );\\n\\t\\t\\t\\tmaterial.color = this.readColor( data );\\n\\n\\t\\t\\t} else if ( next === MAT_SHININESS ) {\\n\\n\\t\\t\\t\\tvar shininess = this.readWord( data );\\n\\t\\t\\t\\tmaterial.shininess = shininess;\\n\\t\\t\\t\\tthis.debugMessage( \\'   Shininess : \\' + shininess );\\n\\n\\t\\t\\t} else if ( next === MAT_TEXMAP ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   ColorMap\\' );\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tmaterial.map = this.readMap( data, path );\\n\\n\\t\\t\\t} else if ( next === MAT_BUMPMAP ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   BumpMap\\' );\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tmaterial.bumpMap = this.readMap( data, path );\\n\\n\\t\\t\\t} else if ( next === MAT_OPACMAP ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   OpacityMap\\' );\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tmaterial.alphaMap = this.readMap( data, path );\\n\\n\\t\\t\\t} else if ( next === MAT_SPECMAP ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   SpecularMap\\' );\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tmaterial.specularMap = this.readMap( data, path );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Unknown material chunk: \\' + next.toString( 16 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnext = this.nextChunk( data, chunk );\\n\\n\\t\\t}\\n\\n\\t\\tthis.endChunk( chunk );\\n\\n\\t\\tthis.materials[ material.name ] = material;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read mesh data chunk.\\n\\t *\\n\\t * @method readMesh\\n\\t * @param {Dataview} data Dataview in use.\\n\\t */\\n\\treadMesh: function ( data ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar next = this.nextChunk( data, chunk );\\n\\n\\t\\tvar useBufferGeometry = false;\\n\\t\\tvar geometry = null;\\n\\t\\tvar uvs = [];\\n\\n\\t\\tif ( useBufferGeometry ) {\\n\\n\\t\\t\\tgeometry = new THREE.BufferGeometry();\\n\\n\\t\\t}\\telse {\\n\\n\\t\\t\\tgeometry = new THREE.Geometry();\\n\\n\\t\\t}\\n\\n\\t\\tvar material = new THREE.MeshPhongMaterial();\\n\\t\\tvar mesh = new THREE.Mesh( geometry, material );\\n\\t\\tmesh.name = \\'mesh\\';\\n\\n\\t\\twhile ( next !== 0 ) {\\n\\n\\t\\t\\tif ( next === POINT_ARRAY ) {\\n\\n\\t\\t\\t\\tvar points = this.readWord( data );\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Vertex: \\' + points );\\n\\n\\t\\t\\t\\t//BufferGeometry\\n\\n\\t\\t\\t\\tif ( useBufferGeometry )\\t{\\n\\n\\t\\t\\t\\t\\tvar vertices = [];\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < points; i ++ )\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tvertices.push( this.readFloat( data ) );\\n\\t\\t\\t\\t\\t\\tvertices.push( this.readFloat( data ) );\\n\\t\\t\\t\\t\\t\\tvertices.push( this.readFloat( data ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgeometry.addAttribute( \\'position\\', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );\\n\\n\\t\\t\\t\\t} else\\t{ //Geometry\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < points; i ++ )\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( this.readFloat( data ), this.readFloat( data ), this.readFloat( data ) ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( next === FACE_ARRAY ) {\\n\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\t\\t\\t\\tthis.readFaceArray( data, mesh );\\n\\n\\t\\t\\t} else if ( next === TEX_VERTS ) {\\n\\n\\t\\t\\t\\tvar texels = this.readWord( data );\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   UV: \\' + texels );\\n\\n\\t\\t\\t\\t//BufferGeometry\\n\\n\\t\\t\\t\\tif ( useBufferGeometry )\\t{\\n\\n\\t\\t\\t\\t\\tvar uvs = [];\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < texels; i ++ )\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tuvs.push( this.readFloat( data ) );\\n\\t\\t\\t\\t\\t\\tuvs.push( this.readFloat( data ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgeometry.addAttribute( \\'uv\\', new THREE.BufferAttribute( new Float32Array( uvs ), 2 ) );\\n\\n\\t\\t\\t\\t} else { //Geometry\\n\\n\\t\\t\\t\\t\\tuvs = [];\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < texels; i ++ )\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tuvs.push( new THREE.Vector2( this.readFloat( data ), this.readFloat( data ) ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( next === MESH_MATRIX ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Tranformation Matrix (TODO)\\' );\\n\\n\\t\\t\\t\\tvar values = [];\\n\\t\\t\\t\\tfor ( var i = 0; i < 12; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvalues[ i ] = this.readFloat( data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar matrix = new THREE.Matrix4();\\n\\n\\t\\t\\t\\t//X Line\\n\\t\\t\\t\\tmatrix.elements[ 0 ] = values[ 0 ];\\n\\t\\t\\t\\tmatrix.elements[ 1 ] = values[ 6 ];\\n\\t\\t\\t\\tmatrix.elements[ 2 ] = values[ 3 ];\\n\\t\\t\\t\\tmatrix.elements[ 3 ] = values[ 9 ];\\n\\n\\t\\t\\t\\t//Y Line\\n\\t\\t\\t\\tmatrix.elements[ 4 ] = values[ 2 ];\\n\\t\\t\\t\\tmatrix.elements[ 5 ] = values[ 8 ];\\n\\t\\t\\t\\tmatrix.elements[ 6 ] = values[ 5 ];\\n\\t\\t\\t\\tmatrix.elements[ 7 ] = values[ 11 ];\\n\\n\\t\\t\\t\\t//Z Line\\n\\t\\t\\t\\tmatrix.elements[ 8 ] = values[ 1 ];\\n\\t\\t\\t\\tmatrix.elements[ 9 ] = values[ 7 ];\\n\\t\\t\\t\\tmatrix.elements[ 10 ] = values[ 4 ];\\n\\t\\t\\t\\tmatrix.elements[ 11 ] = values[ 10 ];\\n\\n\\t\\t\\t\\t//W Line\\n\\t\\t\\t\\tmatrix.elements[ 12 ] = 0;\\n\\t\\t\\t\\tmatrix.elements[ 13 ] = 0;\\n\\t\\t\\t\\tmatrix.elements[ 14 ] = 0;\\n\\t\\t\\t\\tmatrix.elements[ 15 ] = 1;\\n\\n\\t\\t\\t\\tmatrix.transpose();\\n\\n\\t\\t\\t\\tvar inverse = new THREE.Matrix4();\\n\\t\\t\\t\\tinverse.getInverse( matrix, true );\\n\\t\\t\\t\\tgeometry.applyMatrix( inverse );\\n\\n\\t\\t\\t\\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'   Unknown mesh chunk: \\' + next.toString( 16 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnext = this.nextChunk( data, chunk );\\n\\n\\t\\t}\\n\\n\\t\\tthis.endChunk( chunk );\\n\\n\\t\\tif ( ! useBufferGeometry ) {\\n\\n\\t\\t\\t//geometry.faceVertexUvs[0][faceIndex][vertexIndex]\\n\\n\\t\\t\\tif ( uvs.length > 0 ) {\\n\\n\\t\\t\\t\\tvar faceUV = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < geometry.faces.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tfaceUV.push( [ uvs[ geometry.faces[ i ].a ], uvs[ geometry.faces[ i ].b ], uvs[ geometry.faces[ i ].c ] ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.faceVertexUvs[ 0 ] = faceUV;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.computeVertexNormals();\\n\\n\\t\\t}\\n\\n\\t\\treturn mesh;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read face array data chunk.\\n\\t *\\n\\t * @method readFaceArray\\n\\t * @param {Dataview} data Dataview in use.\\n\\t * @param {Mesh} mesh Mesh to be filled with the data read.\\n\\t */\\n\\treadFaceArray: function ( data, mesh ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar faces = this.readWord( data );\\n\\n\\t\\tthis.debugMessage( \\'   Faces: \\' + faces );\\n\\n\\t\\tfor ( var i = 0; i < faces; ++ i ) {\\n\\n\\t\\t\\tmesh.geometry.faces.push( new THREE.Face3( this.readWord( data ), this.readWord( data ), this.readWord( data ) ) );\\n\\n\\t\\t\\tvar visibility = this.readWord( data );\\n\\n\\t\\t}\\n\\n\\t\\t//The rest of the FACE_ARRAY chunk is subchunks\\n\\n\\t\\twhile ( this.position < chunk.end ) {\\n\\n\\t\\t\\tvar chunk = this.readChunk( data );\\n\\n\\t\\t\\tif ( chunk.id === MSH_MAT_GROUP ) {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'      Material Group\\' );\\n\\n\\t\\t\\t\\tthis.resetPosition( data );\\n\\n\\t\\t\\t\\tvar group = this.readMaterialGroup( data );\\n\\n\\t\\t\\t\\tvar material = this.materials[ group.name ];\\n\\n\\t\\t\\t\\tif ( material !== undefined )\\t{\\n\\n\\t\\t\\t\\t\\tmesh.material = material;\\n\\n\\t\\t\\t\\t\\tif ( material.name === \\'\\' )\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tmaterial.name = mesh.name;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'      Unknown face array chunk: \\' + chunk.toString( 16 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.endChunk( chunk );\\n\\n\\t\\t}\\n\\n\\t\\tthis.endChunk( chunk );\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read texture map data chunk.\\n\\t *\\n\\t * @method readMap\\n\\t * @param {Dataview} data Dataview in use.\\n\\t * @return {Texture} Texture read from this data chunk.\\n\\t */\\n\\treadMap: function ( data, path ) {\\n    if (this.skipMaps) return null;\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar next = this.nextChunk( data, chunk );\\n\\t\\tvar texture = {};\\n\\n\\t\\tvar loader = new THREE.TextureLoader( this.manager );\\n\\t\\tloader.setPath( path );\\n\\n\\t\\twhile ( next !== 0 ) {\\n\\n\\t\\t\\tif ( next === MAT_MAPNAME ) {\\n\\n\\t\\t\\t\\tvar name = this.readString( data, 128 );\\n\\t\\t\\t\\ttexture = loader.load( name );\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'      File: \\' + path + name );\\n\\n\\t\\t\\t} else if ( next === MAT_MAP_UOFFSET ) {\\n\\n\\t\\t\\t\\ttexture.offset.x = this.readFloat( data );\\n\\t\\t\\t\\tthis.debugMessage( \\'      OffsetX: \\' + texture.offset.x );\\n\\n\\t\\t\\t} else if ( next === MAT_MAP_VOFFSET ) {\\n\\n\\t\\t\\t\\ttexture.offset.y = this.readFloat( data );\\n\\t\\t\\t\\tthis.debugMessage( \\'      OffsetY: \\' + texture.offset.y );\\n\\n\\t\\t\\t} else if ( next === MAT_MAP_USCALE ) {\\n\\n\\t\\t\\t\\ttexture.repeat.x = this.readFloat( data );\\n\\t\\t\\t\\tthis.debugMessage( \\'      RepeatX: \\' + texture.repeat.x );\\n\\n\\t\\t\\t} else if ( next === MAT_MAP_VSCALE ) {\\n\\n\\t\\t\\t\\ttexture.repeat.y = this.readFloat( data );\\n\\t\\t\\t\\tthis.debugMessage( \\'      RepeatY: \\' + texture.repeat.y );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.debugMessage( \\'      Unknown map chunk: \\' + next.toString( 16 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnext = this.nextChunk( data, chunk );\\n\\n\\t\\t}\\n\\n\\t\\tthis.endChunk( chunk );\\n\\n\\t\\treturn texture;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read material group data chunk.\\n\\t *\\n\\t * @method readMaterialGroup\\n\\t * @param {Dataview} data Dataview in use.\\n\\t * @return {Object} Object with name and index of the object.\\n\\t */\\n\\treadMaterialGroup: function ( data ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar name = this.readString( data, 64 );\\n\\t\\tvar numFaces = this.readWord( data );\\n\\n\\t\\tthis.debugMessage( \\'         Name: \\' + name );\\n\\t\\tthis.debugMessage( \\'         Faces: \\' + numFaces );\\n\\n\\t\\tvar index = [];\\n\\t\\tfor ( var i = 0; i < numFaces; ++ i ) {\\n\\n\\t\\t\\tindex.push( this.readWord( data ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn { name: name, index: index };\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read a color value.\\n\\t *\\n\\t * @method readColor\\n\\t * @param {DataView} data Dataview.\\n\\t * @return {Color} Color value read..\\n\\t */\\n\\treadColor: function ( data ) {\\n\\n\\t\\tvar chunk = this.readChunk( data );\\n\\t\\tvar color = new THREE.Color();\\n\\n\\t\\tif ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {\\n\\n\\t\\t\\tvar r = this.readByte( data );\\n\\t\\t\\tvar g = this.readByte( data );\\n\\t\\t\\tvar b = this.readByte( data );\\n\\n\\t\\t\\tcolor.setRGB( r / 255, g / 255, b / 255 );\\n\\n\\t\\t\\tthis.debugMessage( \\'      Color: \\' + color.r + \\', \\' + color.g + \\', \\' + color.b );\\n\\n\\t\\t}\\telse if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {\\n\\n\\t\\t\\tvar r = this.readFloat( data );\\n\\t\\t\\tvar g = this.readFloat( data );\\n\\t\\t\\tvar b = this.readFloat( data );\\n\\n\\t\\t\\tcolor.setRGB( r, g, b );\\n\\n\\t\\t\\tthis.debugMessage( \\'      Color: \\' + color.r + \\', \\' + color.g + \\', \\' + color.b );\\n\\n\\t\\t}\\telse {\\n\\n\\t\\t\\tthis.debugMessage( \\'      Unknown color chunk: \\' + chunk.toString( 16 ) );\\n\\n\\t\\t}\\n\\n\\t\\tthis.endChunk( chunk );\\n\\t\\treturn color;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read next chunk of data.\\n\\t *\\n\\t * @method readChunk\\n\\t * @param {DataView} data Dataview.\\n\\t * @return {Object} Chunk of data read.\\n\\t */\\n\\treadChunk: function ( data ) {\\n\\n\\t\\tvar chunk = {};\\n\\n\\t\\tchunk.cur = this.position;\\n\\t\\tchunk.id = this.readWord( data );\\n\\t\\tchunk.size = this.readDWord( data );\\n\\t\\tchunk.end = chunk.cur + chunk.size;\\n\\t\\tchunk.cur += 6;\\n\\n\\t\\treturn chunk;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Set position to the end of the current chunk of data.\\n\\t *\\n\\t * @method endChunk\\n\\t * @param {Object} chunk Data chunk.\\n\\t */\\n\\tendChunk: function ( chunk ) {\\n\\n\\t\\tthis.position = chunk.end;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Move to the next data chunk.\\n\\t *\\n\\t * @method nextChunk\\n\\t * @param {DataView} data Dataview.\\n\\t * @param {Object} chunk Data chunk.\\n\\t */\\n\\tnextChunk: function ( data, chunk ) {\\n\\n\\t\\tif ( chunk.cur >= chunk.end ) {\\n\\n\\t\\t\\treturn 0;\\n\\n\\t\\t}\\n\\n\\t\\tthis.position = chunk.cur;\\n\\n\\t\\ttry {\\n\\n\\t\\t\\tvar next = this.readChunk( data );\\n\\t\\t\\tchunk.cur += next.size;\\n\\t\\t\\treturn next.id;\\n\\n\\t\\t}\\tcatch ( e ) {\\n\\n\\t\\t\\tthis.debugMessage( \\'Unable to read chunk at \\' + this.position );\\n\\t\\t\\treturn 0;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t/**\\n\\t * Reset dataview position.\\n\\t *\\n\\t * @method resetPosition\\n\\t * @param {DataView} data Dataview.\\n\\t */\\n\\tresetPosition: function () {\\n\\n\\t\\tthis.position -= 6;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read byte value.\\n\\t *\\n\\t * @method readByte\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @return {Number} Data read from the dataview.\\n\\t */\\n\\treadByte: function ( data ) {\\n\\n\\t\\tvar v = data.getUint8( this.position, true );\\n\\t\\tthis.position += 1;\\n\\t\\treturn v;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read 32 bit float value.\\n\\t *\\n\\t * @method readFloat\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @return {Number} Data read from the dataview.\\n\\t */\\n\\treadFloat: function ( data ) {\\n\\n\\t\\ttry {\\n\\n\\t\\t\\tvar v = data.getFloat32( this.position, true );\\n\\t\\t\\tthis.position += 4;\\n\\t\\t\\treturn v;\\n\\n\\t\\t}\\tcatch ( e ) {\\n\\n\\t\\t\\tthis.debugMessage( e + \\' \\' + this.position + \\' \\' + data.byteLength );\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read 32 bit signed integer value.\\n\\t *\\n\\t * @method readInt\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @return {Number} Data read from the dataview.\\n\\t */\\n\\treadInt: function ( data ) {\\n\\n\\t\\tvar v = data.getInt32( this.position, true );\\n\\t\\tthis.position += 4;\\n\\t\\treturn v;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read 16 bit signed integer value.\\n\\t *\\n\\t * @method readShort\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @return {Number} Data read from the dataview.\\n\\t */\\n\\treadShort: function ( data ) {\\n\\n\\t\\tvar v = data.getInt16( this.position, true );\\n\\t\\tthis.position += 2;\\n\\t\\treturn v;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read 64 bit unsigned integer value.\\n\\t *\\n\\t * @method readDWord\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @return {Number} Data read from the dataview.\\n\\t */\\n\\treadDWord: function ( data ) {\\n\\n\\t\\tvar v = data.getUint32( this.position, true );\\n\\t\\tthis.position += 4;\\n\\t\\treturn v;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read 32 bit unsigned integer value.\\n\\t *\\n\\t * @method readWord\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @return {Number} Data read from the dataview.\\n\\t */\\n\\treadWord: function ( data ) {\\n\\n\\t\\tvar v = data.getUint16( this.position, true );\\n\\t\\tthis.position += 2;\\n\\t\\treturn v;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Read string value.\\n\\t *\\n\\t * @method readString\\n\\t * @param {DataView} data Dataview to read data from.\\n\\t * @param {Number} maxLength Max size of the string to be read.\\n\\t * @return {String} Data read from the dataview.\\n\\t */\\n\\treadString: function ( data, maxLength ) {\\n\\n\\t\\tvar s = \\'\\';\\n\\n\\t\\tfor ( var i = 0; i < maxLength; i ++ ) {\\n\\n\\t\\t\\tvar c = this.readByte( data );\\n\\t\\t\\tif ( ! c ) {\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ts += String.fromCharCode( c );\\n\\n\\t\\t}\\n\\n\\t\\treturn s;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Set resource path used to determine the file path to attached resources.\\n\\t *\\n\\t * @method setPath\\n\\t * @param {String} path Path to resources.\\n\\t * @return Self for chaining.\\n\\t */\\n\\tsetPath: function ( path ) {\\n\\n\\t\\tthis.path = path;\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\t/**\\n\\t * Print debug message to the console.\\n\\t *\\n\\t * Is controlled by a flag to show or hide debug messages.\\n\\t *\\n\\t * @method debugMessage\\n\\t * @param {Object} message Debug message to print to the console.\\n\\t */\\n\\tdebugMessage: function ( message ) {\\n\\n\\t\\tif ( this.debug ) {\\n\\n\\t\\t\\tconsole.log( message );\\n\\n\\t\\t}\\n\\n\\t}\\n};\\n\\nvar NULL_CHUNK = 0x0000;\\nvar M3DMAGIC = 0x4D4D;\\nvar SMAGIC = 0x2D2D;\\nvar LMAGIC = 0x2D3D;\\nvar MLIBMAGIC = 0x3DAA;\\nvar MATMAGIC = 0x3DFF;\\nvar CMAGIC = 0xC23D;\\nvar M3D_VERSION = 0x0002;\\nvar M3D_KFVERSION = 0x0005;\\nvar COLOR_F = 0x0010;\\nvar COLOR_24 = 0x0011;\\nvar LIN_COLOR_24 = 0x0012;\\nvar LIN_COLOR_F = 0x0013;\\nvar INT_PERCENTAGE = 0x0030;\\nvar FLOAT_PERCENTAGE = 0x0031;\\nvar MDATA = 0x3D3D;\\nvar MESH_VERSION = 0x3D3E;\\nvar MASTER_SCALE = 0x0100;\\nvar LO_SHADOW_BIAS = 0x1400;\\nvar HI_SHADOW_BIAS = 0x1410;\\nvar SHADOW_MAP_SIZE = 0x1420;\\nvar SHADOW_SAMPLES = 0x1430;\\nvar SHADOW_RANGE = 0x1440;\\nvar SHADOW_FILTER = 0x1450;\\nvar RAY_BIAS = 0x1460;\\nvar O_CONSTS = 0x1500;\\nvar AMBIENT_LIGHT = 0x2100;\\nvar BIT_MAP = 0x1100;\\nvar SOLID_BGND = 0x1200;\\nvar V_GRADIENT = 0x1300;\\nvar USE_BIT_MAP = 0x1101;\\nvar USE_SOLID_BGND = 0x1201;\\nvar USE_V_GRADIENT = 0x1301;\\nvar FOG = 0x2200;\\nvar FOG_BGND = 0x2210;\\nvar LAYER_FOG = 0x2302;\\nvar DISTANCE_CUE = 0x2300;\\nvar DCUE_BGND = 0x2310;\\nvar USE_FOG = 0x2201;\\nvar USE_LAYER_FOG = 0x2303;\\nvar USE_DISTANCE_CUE = 0x2301;\\nvar MAT_ENTRY = 0xAFFF;\\nvar MAT_NAME = 0xA000;\\nvar MAT_AMBIENT = 0xA010;\\nvar MAT_DIFFUSE = 0xA020;\\nvar MAT_SPECULAR = 0xA030;\\nvar MAT_SHININESS = 0xA040;\\nvar MAT_SHIN2PCT = 0xA041;\\nvar MAT_TRANSPARENCY = 0xA050;\\nvar MAT_XPFALL = 0xA052;\\nvar MAT_USE_XPFALL = 0xA240;\\nvar MAT_REFBLUR = 0xA053;\\nvar MAT_SHADING = 0xA100;\\nvar MAT_USE_REFBLUR = 0xA250;\\nvar MAT_SELF_ILLUM = 0xA084;\\nvar MAT_TWO_SIDE = 0xA081;\\nvar MAT_DECAL = 0xA082;\\nvar MAT_ADDITIVE = 0xA083;\\nvar MAT_WIRE = 0xA085;\\nvar MAT_FACEMAP = 0xA088;\\nvar MAT_TRANSFALLOFF_IN = 0xA08A;\\nvar MAT_PHONGSOFT = 0xA08C;\\nvar MAT_WIREABS = 0xA08E;\\nvar MAT_WIRE_SIZE = 0xA087;\\nvar MAT_TEXMAP = 0xA200;\\nvar MAT_SXP_TEXT_DATA = 0xA320;\\nvar MAT_TEXMASK = 0xA33E;\\nvar MAT_SXP_TEXTMASK_DATA = 0xA32A;\\nvar MAT_TEX2MAP = 0xA33A;\\nvar MAT_SXP_TEXT2_DATA = 0xA321;\\nvar MAT_TEX2MASK = 0xA340;\\nvar MAT_SXP_TEXT2MASK_DATA = 0xA32C;\\nvar MAT_OPACMAP = 0xA210;\\nvar MAT_SXP_OPAC_DATA = 0xA322;\\nvar MAT_OPACMASK = 0xA342;\\nvar MAT_SXP_OPACMASK_DATA = 0xA32E;\\nvar MAT_BUMPMAP = 0xA230;\\nvar MAT_SXP_BUMP_DATA = 0xA324;\\nvar MAT_BUMPMASK = 0xA344;\\nvar MAT_SXP_BUMPMASK_DATA = 0xA330;\\nvar MAT_SPECMAP = 0xA204;\\nvar MAT_SXP_SPEC_DATA = 0xA325;\\nvar MAT_SPECMASK = 0xA348;\\nvar MAT_SXP_SPECMASK_DATA = 0xA332;\\nvar MAT_SHINMAP = 0xA33C;\\nvar MAT_SXP_SHIN_DATA = 0xA326;\\nvar MAT_SHINMASK = 0xA346;\\nvar MAT_SXP_SHINMASK_DATA = 0xA334;\\nvar MAT_SELFIMAP = 0xA33D;\\nvar MAT_SXP_SELFI_DATA = 0xA328;\\nvar MAT_SELFIMASK = 0xA34A;\\nvar MAT_SXP_SELFIMASK_DATA = 0xA336;\\nvar MAT_REFLMAP = 0xA220;\\nvar MAT_REFLMASK = 0xA34C;\\nvar MAT_SXP_REFLMASK_DATA = 0xA338;\\nvar MAT_ACUBIC = 0xA310;\\nvar MAT_MAPNAME = 0xA300;\\nvar MAT_MAP_TILING = 0xA351;\\nvar MAT_MAP_TEXBLUR = 0xA353;\\nvar MAT_MAP_USCALE = 0xA354;\\nvar MAT_MAP_VSCALE = 0xA356;\\nvar MAT_MAP_UOFFSET = 0xA358;\\nvar MAT_MAP_VOFFSET = 0xA35A;\\nvar MAT_MAP_ANG = 0xA35C;\\nvar MAT_MAP_COL1 = 0xA360;\\nvar MAT_MAP_COL2 = 0xA362;\\nvar MAT_MAP_RCOL = 0xA364;\\nvar MAT_MAP_GCOL = 0xA366;\\nvar MAT_MAP_BCOL = 0xA368;\\nvar NAMED_OBJECT = 0x4000;\\nvar N_DIRECT_LIGHT = 0x4600;\\nvar DL_OFF = 0x4620;\\nvar DL_OUTER_RANGE = 0x465A;\\nvar DL_INNER_RANGE = 0x4659;\\nvar DL_MULTIPLIER = 0x465B;\\nvar DL_EXCLUDE = 0x4654;\\nvar DL_ATTENUATE = 0x4625;\\nvar DL_SPOTLIGHT = 0x4610;\\nvar DL_SPOT_ROLL = 0x4656;\\nvar DL_SHADOWED = 0x4630;\\nvar DL_LOCAL_SHADOW2 = 0x4641;\\nvar DL_SEE_CONE = 0x4650;\\nvar DL_SPOT_RECTANGULAR = 0x4651;\\nvar DL_SPOT_ASPECT = 0x4657;\\nvar DL_SPOT_PROJECTOR = 0x4653;\\nvar DL_SPOT_OVERSHOOT = 0x4652;\\nvar DL_RAY_BIAS = 0x4658;\\nvar DL_RAYSHAD = 0x4627;\\nvar N_CAMERA = 0x4700;\\nvar CAM_SEE_CONE = 0x4710;\\nvar CAM_RANGES = 0x4720;\\nvar OBJ_HIDDEN = 0x4010;\\nvar OBJ_VIS_LOFTER = 0x4011;\\nvar OBJ_DOESNT_CAST = 0x4012;\\nvar OBJ_DONT_RECVSHADOW = 0x4017;\\nvar OBJ_MATTE = 0x4013;\\nvar OBJ_FAST = 0x4014;\\nvar OBJ_PROCEDURAL = 0x4015;\\nvar OBJ_FROZEN = 0x4016;\\nvar N_TRI_OBJECT = 0x4100;\\nvar POINT_ARRAY = 0x4110;\\nvar POINT_FLAG_ARRAY = 0x4111;\\nvar FACE_ARRAY = 0x4120;\\nvar MSH_MAT_GROUP = 0x4130;\\nvar SMOOTH_GROUP = 0x4150;\\nvar MSH_BOXMAP = 0x4190;\\nvar TEX_VERTS = 0x4140;\\nvar MESH_MATRIX = 0x4160;\\nvar MESH_COLOR = 0x4165;\\nvar MESH_TEXTURE_INFO = 0x4170;\\nvar KFDATA = 0xB000;\\nvar KFHDR = 0xB00A;\\nvar KFSEG = 0xB008;\\nvar KFCURTIME = 0xB009;\\nvar AMBIENT_NODE_TAG = 0xB001;\\nvar OBJECT_NODE_TAG = 0xB002;\\nvar CAMERA_NODE_TAG = 0xB003;\\nvar TARGET_NODE_TAG = 0xB004;\\nvar LIGHT_NODE_TAG = 0xB005;\\nvar L_TARGET_NODE_TAG = 0xB006;\\nvar SPOTLIGHT_NODE_TAG = 0xB007;\\nvar NODE_ID = 0xB030;\\nvar NODE_HDR = 0xB010;\\nvar PIVOT = 0xB013;\\nvar INSTANCE_NAME = 0xB011;\\nvar MORPH_SMOOTH = 0xB015;\\nvar BOUNDBOX = 0xB014;\\nvar POS_TRACK_TAG = 0xB020;\\nvar COL_TRACK_TAG = 0xB025;\\nvar ROT_TRACK_TAG = 0xB021;\\nvar SCL_TRACK_TAG = 0xB022;\\nvar MORPH_TRACK_TAG = 0xB026;\\nvar FOV_TRACK_TAG = 0xB023;\\nvar ROLL_TRACK_TAG = 0xB024;\\nvar HOT_TRACK_TAG = 0xB027;\\nvar FALL_TRACK_TAG = 0xB028;\\nvar HIDE_TRACK_TAG = 0xB029;\\nvar POLY_2D = 0x5000;\\nvar SHAPE_OK = 0x5010;\\nvar SHAPE_NOT_OK = 0x5011;\\nvar SHAPE_HOOK = 0x5020;\\nvar PATH_3D = 0x6000;\\nvar PATH_MATRIX = 0x6005;\\nvar SHAPE_2D = 0x6010;\\nvar M_SCALE = 0x6020;\\nvar M_TWIST = 0x6030;\\nvar M_TEETER = 0x6040;\\nvar M_FIT = 0x6050;\\nvar M_BEVEL = 0x6060;\\nvar XZ_CURVE = 0x6070;\\nvar YZ_CURVE = 0x6080;\\nvar INTERPCT = 0x6090;\\nvar DEFORM_LIMIT = 0x60A0;\\nvar USE_CONTOUR = 0x6100;\\nvar USE_TWEEN = 0x6110;\\nvar USE_SCALE = 0x6120;\\nvar USE_TWIST = 0x6130;\\nvar USE_TEETER = 0x6140;\\nvar USE_FIT = 0x6150;\\nvar USE_BEVEL = 0x6160;\\nvar DEFAULT_VIEW = 0x3000;\\nvar VIEW_TOP = 0x3010;\\nvar VIEW_BOTTOM = 0x3020;\\nvar VIEW_LEFT = 0x3030;\\nvar VIEW_RIGHT = 0x3040;\\nvar VIEW_FRONT = 0x3050;\\nvar VIEW_BACK = 0x3060;\\nvar VIEW_USER = 0x3070;\\nvar VIEW_CAMERA = 0x3080;\\nvar VIEW_WINDOW = 0x3090;\\nvar VIEWPORT_LAYOUT_OLD = 0x7000;\\nvar VIEWPORT_DATA_OLD = 0x7010;\\nvar VIEWPORT_LAYOUT = 0x7001;\\nvar VIEWPORT_DATA = 0x7011;\\nvar VIEWPORT_DATA_3 = 0x7012;\\nvar VIEWPORT_SIZE = 0x7020;\\nvar NETWORK_VIEW = 0x7030;\\n\\n/* harmony default export */ var TDSLoader = (THREE.TDSLoader);\\n\\n// EXTERNAL MODULE: ./models/wjj.js\\nvar wjj = __webpack_require__(8);\\nvar wjj_default = /*#__PURE__*/__webpack_require__.n(wjj);\\n\\n// CONCATENATED MODULE: ./js/objects/CarObject.js\\n\\n\\n\\n\\nconst CAR_COLOR = 0x0088ff;\\nconst WHEEL_COLOR = 0xff8800;\\n\\nclass CarObject_CarObject extends THREE.Object3D {\\n  constructor(car) {\\n    super();\\n\\n    this.car = car;\\n\\n    this.buildCar2D();\\n    this.buildCar3D();\\n  }\\n\\n  buildCar2D() {\\n    const carMesh = new THREE.Mesh(\\n      new THREE.PlaneGeometry(Car[\"a\" /* default */].HALF_CAR_LENGTH * 2, Car[\"a\" /* default */].HALF_CAR_WIDTH * 2),\\n      new THREE.MeshBasicMaterial({ color: CAR_COLOR, depthTest: false, transparent: true, opacity: 0.7 })\\n    );\\n    carMesh.rotation.x = -Math.PI / 2;\\n    carMesh.layers.set(2);\\n    this.add(carMesh);\\n\\n    const wheelGeometry = new THREE.PlaneGeometry(Car[\"a\" /* default */].HALF_WHEEL_LENGTH * 2, Car[\"a\" /* default */].HALF_WHEEL_WIDTH * 2);\\n    const wheelMaterial = new THREE.MeshBasicMaterial({ color: WHEEL_COLOR, depthTest: false, transparent: true, opacity: 0.7 })\\n\\n    this.lfWheel2D = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    this.lfWheel2D.renderOrder = 1;\\n    this.lfWheel2D.position.set(Car[\"a\" /* default */].FRONT_AXLE_POS, 0, Car[\"a\" /* default */].WHEEL_LATERAL_POS);\\n    this.lfWheel2D.rotation.x = -Math.PI / 2;\\n    this.lfWheel2D.layers.set(2);\\n    this.add(this.lfWheel2D);\\n\\n    this.rfWheel2D = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    this.rfWheel2D.renderOrder = 1;\\n    this.rfWheel2D.position.set(Car[\"a\" /* default */].FRONT_AXLE_POS, 0, -Car[\"a\" /* default */].WHEEL_LATERAL_POS);\\n    this.rfWheel2D.rotation.x = -Math.PI / 2;\\n    this.rfWheel2D.layers.set(2);\\n    this.add(this.rfWheel2D);\\n\\n    const lrWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    lrWheel.renderOrder = 1;\\n    lrWheel.position.set(Car[\"a\" /* default */].REAR_AXLE_POS, 0, Car[\"a\" /* default */].WHEEL_LATERAL_POS);\\n    lrWheel.rotation.x = -Math.PI / 2;\\n    lrWheel.layers.set(2);\\n    this.add(lrWheel);\\n\\n    const rrWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    rrWheel.renderOrder = 1;\\n    rrWheel.position.set(Car[\"a\" /* default */].REAR_AXLE_POS, 0, -Car[\"a\" /* default */].WHEEL_LATERAL_POS);\\n    rrWheel.rotation.x = -Math.PI / 2;\\n    rrWheel.layers.set(2);\\n    this.add(rrWheel);\\n  }\\n\\n  buildCar3D() {\\n    const loader = new TDSLoader();\\n    loader.skipMaps = true;\\n\\n    loader.load(wjj_default.a, object => {\\n      object.layers.set(3);\\n      object.rotation.z = Math.PI / 2;\\n      object.rotation.x = -Math.PI / 2;\\n\\n      const box = (new THREE.Box3()).setFromObject(object);\\n      const scaleLength = Car[\"a\" /* default */].HALF_CAR_LENGTH * 2 / (box.max.x - box.min.x);\\n      const scaleWidth = Car[\"a\" /* default */].HALF_CAR_WIDTH * 2 / (box.max.z - box.min.z);\\n      object.scale.set(scaleWidth, scaleLength, (scaleWidth + scaleLength) / 2);\\n\\n      box.setFromObject(object);\\n      object.position.setX(-(box.max.x + box.min.x) / 2);\\n      object.position.setY(-box.min.y);\\n\\n      this.add(object);\\n\\n      const carMaterial = new THREE.MeshToonMaterial({ color: 0x0088ff });\\n      const wheelMaterial = new THREE.MeshToonMaterial({ color: 0xff8800 });\\n\\n      object.traverse(child => {\\n        if (child instanceof THREE.Mesh) {\\n          child.layers.set(3);\\n          child.material = [\\'Toyota_RA7\\', \\'Toyota_RA8\\', \\'Toyota_RA9\\', \\'Toyota_R10\\'].includes(child.name) ? wheelMaterial : carMaterial;\\n\\n          if (child.name == \\'Toyota_RA7\\')\\n            this.lfWheel3D = child;\\n          else if (child.name == \\'Toyota_RA8\\')\\n            this.rfWheel3D = child;\\n        }\\n      });\\n\\n      [this.lfWheel3D, this.rfWheel3D].forEach(wheel => {\\n        wheel.geometry.computeBoundingBox();\\n        wheel.geometry.center();\\n        wheel.position.setY(wheel.position.y - 36);\\n        wheel.position.setZ(wheel.position.z + 36);\\n      });\\n    });\\n  }\\n\\n  updateMatrix() {\\n    this.updateCar();\\n    super.updateMatrix();\\n  }\\n\\n  updateCar() {\\n    const carPosition = this.car.position;\\n    this.position.set(carPosition.x, 0, carPosition.y);\\n    this.rotation.y = -this.car.rotation;\\n\\n    const wheelAngle = this.car.wheelAngle;\\n\\n    // Adding the wheels to the car object can trigger this function in some browsers\\n    // before the other wheels are added, so check them first.\\n    if (this.lfWheel2D) this.lfWheel2D.rotation.z = -wheelAngle;\\n    if (this.rfWheel2D) this.rfWheel2D.rotation.z = -wheelAngle;\\n    if (this.lfWheel3D) this.lfWheel3D.rotation.y = wheelAngle;\\n    if (this.rfWheel3D) this.rfWheel3D.rotation.y = wheelAngle;\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/objects/StaticObstacleObject.js\\nconst COLOR = 0xdd0000;\\nconst HEIGHT = 5;\\n\\nclass StaticObstacleObject extends THREE.Object3D {\\n  constructor(staticObstacle) {\\n    super();\\n\\n    const mesh2D = new THREE.Mesh(\\n      new THREE.PlaneGeometry(staticObstacle.width, staticObstacle.height),\\n      new THREE.MeshBasicMaterial({ color: COLOR, depthTest: false, transparent: true, opacity: 0.5 })\\n    );\\n    mesh2D.rotation.x = -Math.PI / 2;\\n    mesh2D.layers.set(2);\\n    this.add(mesh2D);\\n\\n    const mesh3D = new THREE.Mesh(\\n      new THREE.BoxBufferGeometry(staticObstacle.width, HEIGHT, staticObstacle.height),\\n      new THREE.MeshToonMaterial({ color: COLOR, transparent: true, opacity: 0.5 })\\n    );\\n    mesh3D.position.setY(HEIGHT / 2);\\n    mesh3D.layers.set(3);\\n    this.add(mesh3D);\\n\\n    this.rotation.y = -staticObstacle.rot;\\n    this.position.set(staticObstacle.pos.x, 0, staticObstacle.pos.y);\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/objects/DynamicObstacleObject.js\\nclass DynamicObstacleObject extends THREE.Object3D {\\n  constructor(dynamicObstacle, lanePath) {\\n    super();\\n\\n    this.dynamicObstacle = dynamicObstacle;\\n    this.lanePath = lanePath;\\n\\n    const colors = {\\n      vehicle: 0xff8800,  //0xff8800\\n      cyclist: 0x00ccff,\\n      pedestrian: 0xffdd00\\n    };\\n\\n    const heights = {\\n      vehicle: 2.0,\\n      cyclist: 1.8,\\n      pedestrian: 1.8\\n    };\\n\\n    const mesh2D = new THREE.Mesh(\\n      new THREE.PlaneGeometry(dynamicObstacle.size.w * 2, dynamicObstacle.size.h * 2),\\n      new THREE.MeshBasicMaterial({ color: colors[dynamicObstacle.type] || 0xff8800, depthTest: false, transparent: true, opacity: 0.7 })\\n    );\\n    mesh2D.rotation.x = -Math.PI / 2;\\n    mesh2D.layers.set(2);\\n    this.add(mesh2D);\\n\\n    const mesh3D = new THREE.Mesh(\\n      new THREE.BoxBufferGeometry(dynamicObstacle.size.w * 2, heights[dynamicObstacle.type] || 1.5, dynamicObstacle.size.h * 2),\\n      new THREE.MeshToonMaterial({ color: colors[dynamicObstacle.type] || 0xff8800, transparent: true, opacity: 0.7 })\\n    );\\n    mesh3D.position.setY((heights[dynamicObstacle.type] || 1.5) / 2);\\n    mesh3D.layers.set(3);\\n    this.add(mesh3D);\\n  }\\n\\n  update(time) {\\n    const slPos = this.dynamicObstacle.positionAtTime(time);\\n\\n    // Sample just the station this dynamic obstacle is at\\n    const [sample] = this.lanePath.sampleStations(slPos.x, 1, 0);\\n\\n    if (sample === undefined) {\\n      this.visible = false;\\n      return;\\n    }\\n\\n    const rot = sample.rot;\\n    const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(slPos.y).add(sample.pos);\\n\\n    this.position.set(pos.x, 0, pos.y);\\n    this.rotation.y = -rot;\\n\\n    super.updateMatrix();\\n\\n    this.visible = slPos.x >= 0;\\n  }\\n}\\n\\n// EXTERNAL MODULE: ./js/autonomy/LanePath.js\\nvar LanePath = __webpack_require__(3);\\n\\n// EXTERNAL MODULE: ./js/autonomy/StaticObstacle.js\\nvar StaticObstacle = __webpack_require__(1);\\n\\n// EXTERNAL MODULE: ./js/autonomy/DynamicObstacle.js\\nvar DynamicObstacle = __webpack_require__(5);\\n\\n// CONCATENATED MODULE: ./js/simulator/PathPlannerConfigEditor.js\\n\\n\\nconst LOCAL_STORAGE_KEY = \\'dash_PathPlannerConfig\\';\\n\\nconst internalConfig = {\\n  lattice: {\\n    numStations: 8,\\n    numLatitudes: 17,\\n    stationConnectivity: 3,\\n    latitudeConnectivity: 7\\n  },\\n\\n  roadWidth: 3.7 * 2, // meters\\n\\n  numDynamicFrames: 20,\\n  numDynamicSubframes: 4,\\n\\n  dCurvatureMax: Car[\"a\" /* default */].MAX_STEER_SPEED / Car[\"a\" /* default */].WHEEL_BASE,\\n  rearAxleToCenter: -Car[\"a\" /* default */].REAR_AXLE_POS\\n};\\n\\nconst defaultConfig = {\\n  \\n  //  spatialHorizon: 120, // meters\\n  // centerlineStationInterval: 0.5, // meters\\n\\n  // xyGridCellSize: 0.3, // meters\\n  // slGridCellSize: 0.15, // meters\\n  // gridMargin: 20, // meters\\n  // pathSamplingStep: 1, // meters\\n\\n  // cubicPathPenalty: 0,\\n\\n  // collisionDilationS: Car.HALF_CAR_LENGTH + 2, // meters\\n  // hazardDilationS: 8, // meters\\n  // collisionDilationL: Car.HALF_CAR_WIDTH + 0.5, //meters\\n  // hazardDilationL: 0.5, // meters\\n\\n  // dynamicHazardDilationS: 16,\\n  // dynamicHazardDilationL: 0.5,\\n\\n  // obstacleHazardCost: 200,\\n\\n  // laneCenterLatitude: internalConfig.roadWidth / 4,\\n  // laneShoulderLatitude: internalConfig.roadWidth / 2 * 1.1 - Car.HALF_CAR_WIDTH,\\n  // laneCostSlope: 20, // cost / meter\\n  // lanePreferenceDiscount: 55,\\n\\n  // stationReachDiscount: 400,\\n  // extraTimePenalty: 1000,\\n\\n  // hysteresisDiscount: 50,\\n\\n  // speedLimitPenalty: 200,\\n\\n  // hardAccelerationPenalty: 70,\\n  // hardDecelerationPenalty: 50,\\n\\n  // softLateralAccelerationLimit: 4, // m/s^2\\n  // softLateralAccelerationPenalty: 100,\\n  // linearLateralAccelerationPenalty: 10,\\n\\n  // accelerationChangePenalty: 10,\\n  x: 0.3,\\n  x: 0,\\n  : 0.2,\\n  :0,\\n\\n  x:0.1,\\n  :0.1,\\n};\\n\\nclass PathPlannerConfigEditor {\\n  constructor() {\\n    this._config = Object.assign({}, defaultConfig);\\n\\n    this.showConfigBox = document.getElementById(\\'show-config-box\\');\\n    this.configBox = document.getElementById(\\'config-box-content\\');\\n    this.configForm = document.getElementById(\\'config-form\\');\\n\\n    this._setUpButtons();\\n\\n    let storedConfig = {};\\n    try {\\n      storedConfig = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY)) || {};\\n    } catch (e) {}\\n\\n    for (const key of Object.keys(this._config).sort()) {\\n      if (storedConfig[key] !== undefined) this._config[key] = storedConfig[key];\\n      this.configForm.appendChild(this._createConfigField(key, this._config[key]));\\n    }\\n  }\\n\\n  get config() {\\n    return Object.assign({}, this._config, internalConfig);\\n  }\\n\\n  _setUpButtons() {\\n    document.getElementById(\\'show-config-button\\').addEventListener(\\'click\\', e => {\\n      this.showConfigBox.classList.add(\\'is-hidden\\');\\n      this.configBox.classList.remove(\\'is-hidden\\');\\n    });\\n\\n    document.getElementById(\\'hide-config-button\\').addEventListener(\\'click\\', e => {\\n      this.showConfigBox.classList.remove(\\'is-hidden\\');\\n      this.configBox.classList.add(\\'is-hidden\\');\\n    });\\n\\n    document.getElementById(\\'save-config-button\\').addEventListener(\\'click\\', this._saveConfigFields.bind(this));\\n    document.getElementById(\\'restore-defaults-config-button\\').addEventListener(\\'click\\', this._restoreDefaults.bind(this));\\n  }\\n\\n  _createConfigField(key, value) {\\n    const html =\\n      `<div class=\"field is-horizontal\">\\n          <div class=\"field-label is-small\" style=\"flex-grow: 100;\">\\n              <label class=\"label has-text-grey-light\" for=\"config-field-${key}\">${key}</label>\\n          </div>\\n          <div class=\"field-body\">\\n              <div class=\"field\">\\n                  <div class=\"control\" style=\"margin-right: 16px;\">\\n                      <input id=\"config-field-${key}\" name=\"${key}\" class=\"input is-small ${value !== defaultConfig[key] ? \\'is-danger\\' : \\'\\'}\" type=\"text\" style=\"width: 60px; border-width: 2px;\" value=\"${value}\" />\\n                  </div>\\n              </div>\\n          </div>\\n      </div>`;\\n\\n    const template = document.createElement(\\'template\\');\\n    template.innerHTML = html;\\n    return template.content.firstChild;\\n  }\\n\\n  _saveConfigFields() {\\n    const formData = new FormData(this.configForm);\\n\\n    for (const [k, v] of formData.entries()) {\\n      const parsedValue = Number.parseFloat(v);\\n      this._config[k] = parsedValue\\n\\n      const fieldDom = document.getElementById(`config-field-${k}`);\\n      if (parsedValue === defaultConfig[k])\\n        fieldDom.classList.remove(\\'is-danger\\');\\n      else\\n        fieldDom.classList.add(\\'is-danger\\');\\n    }\\n\\n    try {\\n      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(this._config));\\n    } catch (e) {}\\n  }\\n\\n  _restoreDefaults() {\\n    this._config = Object.assign({}, defaultConfig);\\n\\n    try {\\n      window.localStorage.removeItem(LOCAL_STORAGE_KEY);\\n    } catch (e) {}\\n\\n    while (this.configForm.firstChild)\\n      this.configForm.removeChild(this.configForm.firstChild);\\n\\n    for (const key of Object.keys(this._config).sort())\\n      this.configForm.appendChild(this._createConfigField(key, this._config[key]));\\n  }\\n}\\n\\nPathPlannerConfigEditor.internalConfig = internalConfig;\\n\\n// CONCATENATED MODULE: ./js/simulator/DynamicObstacleEditor.js\\n\\n\\n\\nclass DynamicObstacleEditor_DynamicObstacleEditor {\\n  constructor() {\\n    this.editorDom = document.getElementById(\\'editor-dynamic-obstacles-box\\');\\n    this.formsContainer = document.getElementById(\\'editor-dynamic-obstacle-forms\\');\\n    this.statsDynamicObstacles = document.getElementById(\\'editor-stats-dynamic-obstacles\\');\\n\\n    document.getElementById(\\'editor-add-dynamic-obstacle\\').addEventListener(\\'click\\', this.addDynamicObstacle.bind(this));\\n  }\\n\\n  enable() {\\n    this.editorDom.classList.remove(\\'is-hidden\\');\\n  }\\n\\n  disable() {\\n    this.editorDom.classList.add(\\'is-hidden\\');\\n  }\\n\\n  toJSON() {\\n    const forms = this.formsContainer.getElementsByTagName(\\'form\\');\\n    const obstacles = [];\\n\\n    for (let i = 0; i < forms.length; i++) {\\n      const formData = new FormData(forms[i]);\\n      const params = { parallel: false };\\n\\n      for (const [k, v] of formData.entries())\\n        params[k] = v;\\n\\n      let type = 0;\\n      if (params.type == \\'cyclist\\')\\n        type = 1;\\n      else if (params.type == \\'pedestrian\\')\\n        type = 2;\\n\\n      obstacles.push({\\n        p: [params.sPos, params.lPos],\\n        v: [params.sVel, params.lVel],\\n        l: !!params.parallel ? 1 : 0,\\n        t: type\\n      });\\n    }\\n\\n    return obstacles;\\n  }\\n\\n  loadJSON(json) {\\n    this.clearDynamicObstacles();\\n\\n    json.forEach(o => {\\n      const form = this.addDynamicObstacle();\\n\\n      form[\\'sPos\\'].value = o.p[0];\\n      form[\\'lPos\\'].value = o.p[1];\\n      form[\\'sVel\\'].value = o.v[0];\\n      form[\\'lVel\\'].value = o.v[1];\\n      form[\\'parallel\\'].checked = !!o.l;\\n      form[\\'type\\'].selectedIndex = o.t;\\n    });\\n  }\\n\\n  collectDynamicObstacles() {\\n    const forms = this.formsContainer.getElementsByTagName(\\'form\\');\\n    const obstacles = [];\\n\\n    for (let i = 0; i < forms.length; i++) {\\n      const formData = new FormData(forms[i]);\\n      const params = { parallel: false };\\n\\n      for (const [k, v] of formData.entries())\\n        params[k] = v;\\n\\n      const pos = new THREE.Vector2(Number(params.sPos) || 0, (Number(params.lPos) || 0) * PathPlannerConfigEditor.internalConfig.roadWidth / 2);\\n      const vel = new THREE.Vector2(Number(params.sVel) || 0, Number(params.lVel) || 0);\\n      const parallel = !!params.parallel;\\n\\n      obstacles.push(new DynamicObstacle[\"a\" /* default */](params.type, pos, vel, parallel));\\n    }\\n\\n    return obstacles;\\n  }\\n\\n  addDynamicObstacle() {\\n    const index = this.formsContainer.getElementsByTagName(\\'form\\').length + 1;\\n    const form = this.buildForm(index);\\n\\n    this.formsContainer.appendChild(form);\\n    this.statsDynamicObstacles.textContent = this.formsContainer.getElementsByTagName(\\'form\\').length;\\n\\n    return form;\\n  }\\n\\n  removeDynamicObstacle(form) {\\n    this.formsContainer.removeChild(form);\\n    this.reindexForms();\\n    this.statsDynamicObstacles.textContent = this.formsContainer.getElementsByTagName(\\'form\\').length;\\n  }\\n\\n  clearDynamicObstacles() {\\n    this.formsContainer.innerHTML = \\'\\';\\n    this.statsDynamicObstacles.textContent = 0;\\n  }\\n\\n  reindexForms() {\\n    const forms = this.formsContainer.getElementsByTagName(\\'form\\');\\n\\n    for (let i = 0; i < forms.length; i++) {\\n      forms[i].getElementsByClassName(\\'dynamic-obstacle-index\\')[0].textContent = i + 1;\\n    }\\n  }\\n\\n  buildForm(index) {\\n    const html =\\n      `<form class=\"editor-dynamic-obstacle-form\">\\n          <div class=\"columns is-gapless\">\\n              <div class=\"column is-1\">\\n                  <div class=\"field\">\\n                      <div class=\"field-label is-normal is-size-7 has-text-grey-lighter has-text-weight-bold dynamic-obstacle-index\">${index}</div>\\n                  </div>\\n              </div>\\n              <div class=\"column is-3\">\\n                  <div class=\"field\">\\n                      <div class=\"control\">\\n                          <div class=\"select is-small\">\\n                              <select name=\"type\">\\n                                  <option value=\"vehicle\">Vehicle</option>\\n                                  <option value=\"cyclist\">Cyclist</option>\\n                                  <option value=\"pedestrian\">Pedestrian</option>\\n                              </select>\\n                          </div>\\n                      </div>\\n                  </div>\\n              </div>\\n              <div class=\"column is-1\">\\n                  <div class=\"field\">\\n                      <div class=\"control has-text-centered\">\\n                          <label class=\"checkbox\">\\n                              <input type=\"checkbox\" name=\"parallel\" checked />&nbsp;\\n                          </label>\\n                      </div>\\n                  </div>\\n              </div>\\n              <div class=\"column is-3\">\\n                  <div class=\"field has-addons editor-field-center\">\\n                      <div class=\"control\">\\n                          <input class=\"input is-small\" type=\"text\" name=\"sPos\" style=\"width: 50px;\" value=\"0\" />\\n                      </div>\\n                      <div class=\"control\">\\n                          <input class=\"input is-small\" type=\"text\" name=\"lPos\" style=\"width: 50px;\" value=\"0\" />\\n                      </div>\\n                  </div>\\n              </div>\\n              <div class=\"column is-3\">\\n                  <div class=\"field has-addons editor-field-center\">\\n                      <div class=\"control\">\\n                          <input class=\"input is-small\" type=\"text\" name=\"sVel\" style=\"width: 50px;\" value=\"0\" />\\n                      </div>\\n                      <div class=\"control\">\\n                          <input class=\"input is-small\" type=\"text\" name=\"lVel\" style=\"width: 50px;\" value=\"0\" />\\n                      </div>\\n                  </div>\\n              </div>\\n              <div class=\"column is-1\">\\n                  <div class=\"field has-text-right\">\\n                      <div class=\"button is-small is-danger editor-remove-dynamic-obstacle\" title=\"Remove Dynamic Obstacle\">\\n                          <span class=\"icon is-small\">\\n                              <i class=\"fas fa-lg fa-trash-alt\"></i>\\n                          </span>\\n                      </div>\\n                  </div>\\n              </div>\\n          </div>\\n      </form>`;\\n\\n    const template = document.createElement(\\'template\\');\\n    template.innerHTML = html;\\n    const form = template.content.firstChild;\\n\\n    form.getElementsByClassName(\\'editor-remove-dynamic-obstacle\\')[0].addEventListener(\\'click\\', e => this.removeDynamicObstacle(form));\\n\\n    return form;\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/Helpers.js\\nfunction formatDate(date) {\\n  return date && date.toLocaleDateString(undefined, {month: \\'short\\', day: \\'numeric\\', year: \\'numeric\\', hour: \\'numeric\\', minute: \\'numeric\\', hour12: true});\\n}\\n\\n\\n\\n// CONCATENATED MODULE: ./js/simulator/examples.js\\n/* harmony default export */ var examples = ([\\n  { name: \"One-car overtake\", data: {\"p\":[-298.12979,357.51057,7.55497,136.89255,255.45446,-186.65063,586.66288,-494.5808],\"s\":[],\"d\":[{\"p\":[\"150\",\"0.5\"],\"v\":[\"15\",\"0\"],\"l\":1,\"t\":0}],\"l\":1238.129,\"c\":{\"s\":\"25\",\"sl\":\"25\",\"lp\":1},\"v\":1} },\\n\\n  { name: \"Two-car overtake\", data: {\"p\":[-276.4674,303.00865,44.88593,120.86712,305.10729,-435.99728],\"s\":[],\"d\":[{\"p\":[\"100\",\"0.5\"],\"v\":[\"5\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"100\",\"-0.5\"],\"v\":[\"6\",\"0\"],\"l\":1,\"t\":0}],\"l\":990.576,\"c\":{\"s\":\"20\",\"sl\":\"20\",\"lp\":1},\"v\":1} },\\n\\n  { name: \"Rough road\", data: {\"p\":[-102.46078,26.38513,-68.69821,25.79776,-55.94913,19.50427,-25.32284,12.6183,-16.6024,10.7739,-6.708,11.78013,31.36054,12.11554,47.04057,14.7988,56.85048,23.26776,56.84979,35.25828,46.95511,43.89463,25.48979,43.55924,8.13326,52.2799,-15.34437,64.10242],\"s\":[{\"p\":[-54.96429,21.2553],\"r\":-0.27612,\"w\":2.7671,\"h\":1.67703},{\"p\":[-36.09254,12.36963],\"r\":0.14726,\"w\":3.43791,\"h\":1.84475},{\"p\":[-13.41625,14.2537],\"r\":0.11658,\"w\":4.69568,\"h\":1.42549},{\"p\":[44.00931,18.38166],\"r\":0.25771,\"w\":4.94713,\"h\":4.27642},{\"p\":[62.74669,29.41331],\"r\":0,\"w\":4.10855,\"h\":5.86952},{\"p\":[46.71119,38.74469],\"r\":1.14742,\"w\":4.52775,\"h\":6.70794},{\"p\":[-14.26275,63.60006],\"r\":2.67526,\"w\":10.14584,\"h\":12.24173},{\"p\":[19.7351,9.40621],\"r\":0.65041,\"w\":1.97177,\"h\":1.07553},{\"p\":[28.99679,9.71727],\"r\":0.20862,\"w\":1.97175,\"h\":1.03072},{\"p\":[24.15205,9.93872],\"r\":-0.31907,\"w\":1.25476,\"h\":0.9859}],\"d\":[],\"l\":259.088,\"c\":{\"s\":\"10\",\"sl\":\"10\",\"lp\":1},\"v\":1} },\\n\\n  { name: \"Dodging a speeder\", data: {\"p\":[-226.14066,275.34941,21.32194,-6.2654,266.99958,-174.39559,466.42449,-427.95124],\"s\":[],\"d\":[{\"p\":[\"-250\",\"-0.5\"],\"v\":[\"40\",\"0\"],\"l\":1,\"t\":0}],\"l\":996.572,\"c\":{\"s\":\"25\",\"sl\":\"25\",\"lp\":-1},\"v\":1} },\\n\\n  { name: \"Lane blockage with oncoming traffic\", data: {\"p\":[-84.96318,-14.94973,374.91044,-14.7168],\"s\":[{\"p\":[-34.91024,-12.51359],\"r\":0,\"w\":2.76711,\"h\":2.68324}],\"d\":[{\"p\":[\"40\",\"-0.5\"],\"v\":[\"-10\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"150\",\"-0.5\"],\"v\":[\"-10\",\"0\"],\"l\":1,\"t\":0}],\"l\":459.874,\"c\":{\"s\":\"20\",\"sl\":\"20\",\"lp\":1},\"v\":1} },\\n\\n  { name: \"Merging into slower traffic\", data: {\"p\":[-629.09464,16.31589,281.97162,14.81565],\"s\":[{\"p\":[-440.00152,11.62602],\"r\":0,\"w\":3.1379,\"h\":3.13801},{\"p\":[-259.74036,11.98013],\"r\":0,\"w\":2.51556,\"h\":4.4441},{\"p\":[93.71013,11.27032],\"r\":0,\"w\":4.07947,\"h\":7.84501},{\"p\":[-94.72208,11.28172],\"r\":0,\"w\":3.76609,\"h\":7.53122}],\"d\":[{\"p\":[\"320\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"280\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"240\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"200\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"160\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"120\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"80\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"40\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"0\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"-40\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"-80\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"-120\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"-160\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0},{\"p\":[\"-200\",\"0.5\"],\"v\":[\"12\",\"0\"],\"l\":1,\"t\":0}],\"l\":911.067,\"c\":{\"s\":\"25\",\"sl\":\"25\",\"lp\":-1},\"v\":1} },\\n\\n  { name: \"Negotiating crosswalks\", data: {\"p\":[-144.73574,55.4495,-104.89441,31.62755,-33.87479,61.57811,54.60631,46.34858,152.3728,-41.4335,219.90258,-113.95225],\"s\":[],\"d\":[{\"p\":[\"51\",\"-2\"],\"v\":[\"0\",\"1.5\"],\"l\":1,\"t\":2},{\"p\":[\"52\",\"+2\"],\"v\":[\"0\",\"-1.6\"],\"l\":1,\"t\":2},{\"p\":[\"53\",\"-2\"],\"v\":[\"0\",\"1.5\"],\"l\":1,\"t\":2},{\"p\":[\"54\",\"+2\"],\"v\":[\"0\",\"-1.4\"],\"l\":1,\"t\":2},{\"p\":[\"55\",\"-2\"],\"v\":[\"0\",\"1.5\"],\"l\":1,\"t\":2},{\"p\":[\"50\",\"+3\"],\"v\":[\"0\",\"-1.5\"],\"l\":1,\"t\":2},{\"p\":[\"51\",\"-3\"],\"v\":[\"0\",\"1.7\"],\"l\":1,\"t\":2},{\"p\":[\"52\",\"+3\"],\"v\":[\"0\",\"-1.5\"],\"l\":1,\"t\":2},{\"p\":[\"53\",\"-3\"],\"v\":[\"0\",\"1.3\"],\"l\":1,\"t\":2},{\"p\":[\"50\",\"-4\"],\"v\":[\"0\",\"1.6\"],\"l\":1,\"t\":2},{\"p\":[\"51\",\"-4\"],\"v\":[\"0\",\"1.2\"],\"l\":1,\"t\":2},{\"p\":[\"52\",\"-5\"],\"v\":[\"0\",\"1.5\"],\"l\":1,\"t\":2},{\"p\":[\"53\",\"-5\"],\"v\":[\"0\",\"1.4\"],\"l\":1,\"t\":2},{\"p\":[\"50\",\"4.5\"],\"v\":[\"0\",\"-1.6\"],\"l\":1,\"t\":2},{\"p\":[\"51\",\"5\"],\"v\":[\"0\",\"-1.4\"],\"l\":1,\"t\":2},{\"p\":[\"52\",\"4\"],\"v\":[\"0\",\"-1.5\"],\"l\":1,\"t\":2},{\"p\":[\"53\",\"4.5\"],\"v\":[\"0\",\"-1.4\"],\"l\":1,\"t\":2},{\"p\":[\"49\",\"5.5\"],\"v\":[\"0\",\"-1.2\"],\"l\":1,\"t\":2},{\"p\":[\"50\",\"6\"],\"v\":[\"0\",\"-1.6\"],\"l\":1,\"t\":2},{\"p\":[\"51\",\"5.75\"],\"v\":[\"0\",\"-1.5\"],\"l\":1,\"t\":2},{\"p\":[\"52\",\"5\"],\"v\":[\"0\",\"-1.5\"],\"l\":1,\"t\":2},{\"p\":[\"49\",\"-6\"],\"v\":[\"0\",\"1.5\"],\"l\":1,\"t\":2},{\"p\":[\"50\",\"-5.5\"],\"v\":[\"0\",\"1.7\"],\"l\":1,\"t\":2},{\"p\":[\"51\",\"-5\"],\"v\":[\"0\",\"0.9\"],\"l\":1,\"t\":2},{\"p\":[\"52\",\"-5.75\"],\"v\":[\"0\",\"1.2\"],\"l\":1,\"t\":2},{\"p\":[\"150\",\"-75\"],\"v\":[\"0\",\"9\"],\"l\":0,\"t\":1},{\"p\":[\"152\",\"-80\"],\"v\":[\"0\",\"10\"],\"l\":0,\"t\":1},{\"p\":[\"154\",\"-85\"],\"v\":[\"0\",\"9.5\"],\"l\":0,\"t\":1},{\"p\":[\"150\",\"75\"],\"v\":[\"0\",\"-10\"],\"l\":0,\"t\":1},{\"p\":[\"152\",\"80\"],\"v\":[\"0\",\"-9\"],\"l\":0,\"t\":1},{\"p\":[\"154\",\"85\"],\"v\":[\"0\",\"-9.5\"],\"l\":0,\"t\":1}],\"l\":447.535,\"c\":{\"s\":\"5\",\"sl\":\"20\",\"lp\":1},\"v\":1} },\\n\\n  { name: \"Chasing the peloton\", data: {\"p\":[-708.1093,561.67222,-657.73649,701.46772,-531.30212,736.41613,-332.91517,708.663,-201.34176,611.01215,-80.04523,477.38232,22.75082,341.69385,147.66174,176.73622,253.02371,-15.01574,448.31828,-335.71836,495.60932,-544.40048],\"s\":[],\"d\":[{\"p\":[\"50\",\"0.4\"],\"v\":[\"15.5\",\"-0.1\"],\"l\":1,\"t\":1},{\"p\":[\"52\",\"0.6\"],\"v\":[\"15.7\",\"-0.15\"],\"l\":1,\"t\":1},{\"p\":[\"54\",\"0.3\"],\"v\":[\"15.3\",\"-0.13\"],\"l\":1,\"t\":1},{\"p\":[\"56\",\"0.7\"],\"v\":[\"15.2\",\"-0.1\"],\"l\":1,\"t\":1},{\"p\":[\"58\",\"0.3\"],\"v\":[\"15.8\",\"-0.12\"],\"l\":1,\"t\":1},{\"p\":[\"60\",\"0.7\"],\"v\":[\"15.6\",\"-0.17\"],\"l\":1,\"t\":1},{\"p\":[\"62\",\"0.1\"],\"v\":[\"15.4\",\"-0.14\"],\"l\":1,\"t\":1},{\"p\":[\"64\",\"-0.1\"],\"v\":[\"15.5\",\"0.13\"],\"l\":1,\"t\":1},{\"p\":[\"66\",\"0.3\"],\"v\":[\"15.3\",\"-0.13\"],\"l\":1,\"t\":1},{\"p\":[\"68\",\"0\"],\"v\":[\"15.6\",\"0.15\"],\"l\":1,\"t\":1},{\"p\":[\"70\",\"-0.3\"],\"v\":[\"15.8\",\"0.17\"],\"l\":1,\"t\":1},{\"p\":[\"72\",\"-0.7\"],\"v\":[\"15.7\",\"0.12\"],\"l\":1,\"t\":1},{\"p\":[\"74\",\"-0.5\"],\"v\":[\"15.1\",\"0.15\"],\"l\":1,\"t\":1},{\"p\":[\"76\",\"-0.7\"],\"v\":[\"15.9\",\"0.11\"],\"l\":1,\"t\":1},{\"p\":[\"78\",\"-0.3\"],\"v\":[\"15.5\",\"0.16\"],\"l\":1,\"t\":1},{\"p\":[\"80\",\"-0.5\"],\"v\":[\"15.6\",\"0.13\"],\"l\":1,\"t\":1}],\"l\":2018.213,\"c\":{\"s\":\"15\",\"sl\":\"25\",\"lp\":1},\"v\":1} }\\n]);\\n\\n// CONCATENATED MODULE: ./js/simulator/ScenarioManager.js\\n\\n\\n\\nconst ScenarioManager_LOCAL_STORAGE_KEY = \\'dash_Scenarios\\';\\n\\nclass ScenarioManager_ScenarioManager {\\n  constructor(editor) {\\n    this.editor = editor;\\n    this.modal = document.getElementById(\\'scenarios-modal\\');\\n\\n    document.getElementById(\\'scenarios-modal-background\\').addEventListener(\\'click\\', this._closeModal.bind(this));\\n    document.getElementById(\\'scenarios-modal-close\\').addEventListener(\\'click\\', this._closeModal.bind(this));\\n\\n    this.examplesTab = document.getElementById(\\'scenarios-modal-examples-tab\\');\\n    this.savedTab = document.getElementById(\\'scenarios-modal-saved-tab\\');\\n    this.importTab = document.getElementById(\\'scenarios-modal-import-tab\\');\\n\\n    this.examplesTabButton = document.getElementById(\\'scenarios-modal-examples-tab-button\\');\\n    this.savedTabButton = document.getElementById(\\'scenarios-modal-saved-tab-button\\');\\n    this.importTabButton = document.getElementById(\\'scenarios-modal-import-tab-button\\');\\n    this.examplesTabButton.addEventListener(\\'click\\', e => this.switchTab(this.examplesTab));\\n    this.savedTabButton.addEventListener(\\'click\\', e => this.switchTab(this.savedTab));\\n    this.importTabButton.addEventListener(\\'click\\', e => this.switchTab(this.importTab));\\n\\n    this.itemsContainer = document.getElementById(\\'scenarios-modal-items\\');\\n\\n    this.sortName = document.getElementById(\\'scenarios-sort-name\\');\\n    this.sortName.addEventListener(\\'click\\', e => this._buildScenarioItems(\\'name\\'));\\n    this.sortSavedAt = document.getElementById(\\'scenarios-sort-saved-at\\');\\n    this.sortSavedAt.addEventListener(\\'click\\', e => this._buildScenarioItems(\\'savedAt\\'));\\n\\n    this.importBox = document.getElementById(\\'scenario-import-box\\');\\n    this.importInfo = document.getElementById(\\'scenario-import-info\\');\\n\\n    this.importBox.addEventListener(\\'input\\', this._importBoxChanged.bind(this));\\n\\n    for (let i = 0; i < examples.length; i++)\\n      document.getElementById(`example-${i}`).addEventListener(\\'click\\', e => this._loadScenario(examples[i]));\\n  }\\n\\n  switchTab(tab) {\\n    this.examplesTab.classList.add(\\'is-hidden\\')\\n    this.savedTab.classList.add(\\'is-hidden\\')\\n    this.importTab.classList.add(\\'is-hidden\\')\\n    this.examplesTabButton.classList.remove(\\'is-active\\');\\n    this.savedTabButton.classList.remove(\\'is-active\\');\\n    this.importTabButton.classList.remove(\\'is-active\\');\\n\\n    let button = this.savedTabButton;\\n    if (tab == this.examplesTab)\\n      button = this.examplesTabButton;\\n    else if (tab == this.importTab)\\n      button = this.importTabButton;\\n\\n    tab.classList.remove(\\'is-hidden\\');\\n    button.classList.add(\\'is-active\\');\\n\\n    if (tab == this.importTab)\\n      this.importBox.focus();\\n  }\\n\\n  saveScenario(name, data, force = false) {\\n    const scenarios = this.fetchScenarios();\\n    let scenario = scenarios[name];\\n    const now = new Date();\\n\\n    if (scenario) {\\n      if (!force) return [false, scenario.savedAt];\\n\\n      scenario.data = data;\\n      scenario.savedAt = now;\\n    } else {\\n       scenario = {\\n        name: name,\\n        data: data,\\n        savedAt: now\\n      };\\n      \\n      scenarios[name] = scenario;\\n    }\\n\\n    const json = JSON.stringify(scenarios);\\n    window.localStorage.setItem(ScenarioManager_LOCAL_STORAGE_KEY, json);\\n\\n    return [true, scenario.savedAt];\\n  }\\n\\n  fetchScenarios() {\\n    const scenarios = JSON.parse(window.localStorage.getItem(ScenarioManager_LOCAL_STORAGE_KEY)) || {};\\n\\n    for (const k in scenarios)\\n      scenarios[k].savedAt = new Date(scenarios[k].savedAt);\\n\\n    return scenarios;\\n  }\\n\\n  showModal(onLoadScenario = null) {\\n    this.onLoadScenario = onLoadScenario;\\n\\n    this.modal.classList.add(\\'is-active\\');\\n    this.switchTab(this.savedTab);\\n\\n    this._buildScenarioItems();\\n    this.itemsContainer.scrollTop = 0;\\n    \\n    this.importBox.value = \\'\\';\\n    this.importBox.dispatchEvent(new Event(\\'input\\'));\\n  }\\n\\n  _closeModal() {\\n    this.onLoadScenario = null;\\n    this.modal.classList.remove(\\'is-active\\');\\n  }\\n\\n  _buildScenarioItems(sort = \\'savedAt\\') {\\n    this.itemsContainer.innerHTML = \\'\\';\\n\\n    this.sortName.classList.remove(\\'is-underlined\\');\\n    this.sortSavedAt.classList.remove(\\'is-underlined\\');\\n    if (sort == \\'name\\')\\n      this.sortName.classList.add(\\'is-underlined\\');\\n    else if (sort == \\'savedAt\\')\\n      this.sortSavedAt.classList.add(\\'is-underlined\\');\\n\\n    const scenarios = Object.values(this.fetchScenarios());\\n\\n    if (scenarios.length == 0) {\\n      this._showEmptyMessage();\\n    } else {\\n      scenarios.sort((a, b) => {\\n        if (sort == \\'savedAt\\') {\\n          if (a.savedAt < b.savedAt) return +1;\\n          else if (b.savedAt < a.savedAt) return -1;\\n        }\\n\\n        const nameA = a.name.toLowerCase();\\n        const nameB = b.name.toLowerCase();\\n\\n        if (nameA < nameB) return -1;\\n        if (nameB < nameA) return +1;\\n        return 0;\\n      });\\n\\n      scenarios.forEach(s => this._addScenarioItem(s));\\n    }\\n  }\\n\\n  _showEmptyMessage() {\\n    this.itemsContainer.innerHTML = \"<i>You don\\'t have any saved scenarios.</i>\";\\n  }\\n\\n  _addScenarioItem(scenario) {\\n    const html =\\n      `<div class=\"columns\">\\n          <div class=\"column is-7 scenario-item-name scenario-item-load\" title=\"\"></div>\\n          <div class=\"column is-4 scenario-item-saved-at\"></div>\\n          <div class=\"column is-1\">\\n              <div class=\"field is-grouped is-pulled-right\">\\n                  <p class=\"control\" style=\"margin-right: 8px;\">\\n                      <span class=\"button is-small is-danger scenario-item-delete\" title=\"Delete\">\\n                          <span class=\"icon is-small\">\\n                              <i class=\"fas fa-lg fa-trash-alt\"></i>\\n                          </span>\\n                      </span>\\n                  </p>\\n              </div>\\n          </div>\\n      </div>`;\\n\\n    const template = document.createElement(\\'template\\');\\n    template.innerHTML = html;\\n    const item = template.content.firstChild;\\n\\n    const nameDom = item.getElementsByClassName(\\'scenario-item-name\\')[0];\\n    nameDom.textContent = scenario.name;\\n    nameDom.title = scenario.name;\\n\\n    item.getElementsByClassName(\\'scenario-item-saved-at\\')[0].textContent = formatDate(scenario.savedAt);\\n\\n    item.getElementsByClassName(\\'scenario-item-load\\')[0].addEventListener(\\'click\\', e => this._loadScenario(scenario));\\n\\n    item.getElementsByClassName(\\'scenario-item-delete\\')[0].addEventListener(\\'click\\', e => {\\n      if (window.confirm(`Are you sure you want to delete the scenario \"${scenario.name}\"?`)) {\\n        this._deleteScenario(scenario);\\n        this.itemsContainer.removeChild(item);\\n\\n        if (this.itemsContainer.children.length == 0)\\n          this._showEmptyMessage();\\n      }\\n    });\\n\\n    this.itemsContainer.appendChild(item);\\n  }\\n\\n  _loadScenario(scenario) {\\n    this.editor.loadJSON(scenario.data);\\n    this.editor.updateSavedInfo(scenario.name, formatDate(scenario.savedAt));\\n\\n    if (this.onLoadScenario) this.onLoadScenario();\\n\\n    this._closeModal();\\n  }\\n\\n  _deleteScenario(scenario) {\\n    const scenarios = this.fetchScenarios();\\n    delete scenarios[scenario.name];\\n\\n    const json = JSON.stringify(scenarios);\\n    window.localStorage.setItem(ScenarioManager_LOCAL_STORAGE_KEY, json);\\n  }\\n\\n  _importBoxChanged() {\\n    this.importBox.classList.remove(\\'is-danger\\');\\n    this.importInfo.classList.add(\\'is-hidden\\');\\n\\n    const encoded = this.importBox.value;\\n\\n    if (encoded != \\'\\') {\\n      try {\\n        const json = JSON.parse(atob(this.importBox.value));\\n\\n        if (json.s === undefined || json.d === undefined || json.p === undefined || json.p.length % 2 != 0)\\n          throw new Error();\\n\\n        this.importInfo.innerHTML = `\\n          <div class=\"button is-small is-static has-text-grey-light is-paddingless\" style=\"background: transparent; border: none;\">\\n              Road Length:&nbsp;<b>${json.l.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}</b>m\\n          </div>\\n          &nbsp;\\n          <div class=\"button is-small is-static has-text-grey-light is-paddingless\" style=\"background: transparent; border: none;\">\\n              Static Obstacles:&nbsp;<b>${json.s.length}</b>\\n          </div>\\n          &nbsp;\\n          <div class=\"button is-small is-static has-text-grey-light is-paddingless\" style=\"background: transparent; border: none;\">\\n              Dynamic Obstacles:&nbsp;<b>${json.d.length}</b>\\n          </div>\\n          <div class=\"button is-small is-success is-pulled-right scenario-import-button\">\\n            <span class=\"icon\">\\n              <i class=\"fas fa-check\"></i>\\n            </span>\\n            <span>Import</span>\\n          </div>\\n        `;\\n\\n        this.importInfo.getElementsByClassName(\\'scenario-import-button\\')[0].addEventListener(\\'click\\', e => this._loadScenario({ data: json }));\\n        this.importInfo.classList.remove(\\'is-hidden\\');\\n      } catch (e) {\\n        this.importBox.classList.add(\\'is-danger\\');\\n      }\\n    }\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/simulator/ShareManager.js\\nclass ShareManager {\\n  constructor() {\\n    this.modal = document.getElementById(\\'scenario-share-modal\\');\\n    this.linkDom = document.getElementById(\\'scenario-share-link\\');\\n    this.boxDom = document.getElementById(\\'scenario-share-box\\');\\n    this.clipboardButton = document.getElementById(\\'scenario-share-clipboard\\');\\n    this.clipboardIcon = document.getElementById(\\'scenario-share-clipboard-icon\\');\\n    this.clipboardSuccessIcon = document.getElementById(\\'scenario-share-clipboard-success-icon\\');\\n\\n    document.getElementById(\\'scenario-share-modal-background\\').addEventListener(\\'click\\', this._closeModal.bind(this));\\n    document.getElementById(\\'scenario-share-modal-close\\').addEventListener(\\'click\\', this._closeModal.bind(this));\\n    this.clipboardButton.addEventListener(\\'click\\', this._copyLinkToClipboard.bind(this));\\n\\n    this.linkDom.addEventListener(\\'focus\\', e => this.linkDom.select());\\n    this.boxDom.addEventListener(\\'focus\\', e => this.boxDom.select());\\n  }\\n\\n  showModal(scenario) {\\n    this.modal.classList.add(\\'is-active\\');\\n\\n    this.clipboardIcon.classList.remove(\\'is-hidden\\');\\n    this.clipboardSuccessIcon.classList.add(\\'is-hidden\\');\\n    this.clipboardButton.classList.remove(\\'is-success\\');\\n\\n    const code = btoa(JSON.stringify(scenario));\\n\\n    const url = new URL(window.location);\\n    url.search = \\'\\';\\n    url.hash = \\'/s/\\' + encodeURIComponent(code);\\n\\n    this.linkDom.value = url.href;\\n    this.boxDom.value = code;\\n  }\\n\\n  _closeModal() {\\n    this.modal.classList.remove(\\'is-active\\');\\n  }\\n\\n  _copyLinkToClipboard() {\\n    this.linkDom.focus();\\n    this.linkDom.select();\\n\\n    if (document.execCommand(\\'copy\\', false, null)) {\\n      this.clipboardIcon.classList.add(\\'is-hidden\\');\\n      this.clipboardSuccessIcon.classList.remove(\\'is-hidden\\');\\n      this.clipboardButton.classList.add(\\'is-success\\');\\n    }\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/simulator/Editor.js\\n\\n\\n\\n\\n\\n\\n\\nconst GROUND_PLANE = new THREE.Plane(new THREE.Vector3(0, 1, 0));\\n\\nconst NORMAL_OPACITY = 0.7;\\nconst HOVER_OPACITY = 1;\\nconst NORMAL_POINT_COLOR = 0x0088ff;\\nconst HOVER_POINT_COLOR = 0x33ccff;\\nconst NORMAL_STATIC_OBSTACLE_COLOR = 0xdd0000;\\nconst HOVER_STATIC_OBSTACLE_COLOR = 0xdd3333;\\nconst NORMAL_DYNAMIC_OBSTACLE_COLOR = 0xff8800;\\nconst HOVER_DYNAMIC_OBSTACLE_COLOR = 0xffcc33;\\n\\nconst INITIAL_SPEED_FALLBACK = 20;\\nconst SPEED_LIMIT_FALLBACK = 20;\\nconst LANE_PREFERENCE_FALLBACK = +1;\\n\\nclass Editor_Editor {\\n  constructor(canvas, camera, scene) {\\n    this.canvas = canvas;\\n    this.camera = camera;\\n\\n    this.isEnabled = false;\\n    this.raycaster = new THREE.Raycaster();\\n    this.mouse = new THREE.Vector2();\\n    this.dragOffset = new THREE.Vector3();\\n    this.draggingPoint = null;\\n    this.pointIndex = 0;\\n    this.obstacleIndex = 0;\\n    this.previousSavedName = null;\\n    this.scenarioManager = new ScenarioManager_ScenarioManager(this);\\n    this.shareManager = new ShareManager();\\n\\n    this.centerlineGeometry = new THREE.Geometry();\\n    this.leftBoundaryGeometry = new THREE.Geometry();\\n    this.rightBoundaryGeometry = new THREE.Geometry();\\n    this.draggingObstaclePreview = null;\\n\\n    this.group = new THREE.Group();\\n    this.group.renderOrder = 1;\\n    this.pointGroup = new THREE.Group();\\n    this.pointGroup.renderOrder = 2;\\n    this.obstacleGroup = new THREE.Group();\\n    this.obstacleGroup.renderOrder = 1;\\n    this.group.add(this.obstacleGroup);\\n    this.group.add(this.pointGroup);\\n    scene.add(this.group);\\n\\n    this.lanePath = new LanePath[\"a\" /* default */]();\\n    this.dynamicObstacleEditor = new DynamicObstacleEditor_DynamicObstacleEditor();\\n\\n    this.editorPathButton = document.getElementById(\\'editor-path\\');\\n    this.editorPathButton.addEventListener(\\'click\\', e => this.changeEditMode(\\'path\\'));\\n    this.editorObstaclesButton = document.getElementById(\\'editor-obstacles\\');\\n    this.editorObstaclesButton.addEventListener(\\'click\\', e => this.changeEditMode(\\'staticObstacles\\'));\\n    this.editorDynamicObstaclesButton = document.getElementById(\\'editor-dynamic-obstacles\\');\\n    this.editorDynamicObstaclesButton.addEventListener(\\'click\\', e => this.changeEditMode(\\'dynamicObstacles\\'));\\n\\n    this.editorRoadBox = document.getElementById(\\'editor-road-box\\');\\n    this.initialSpeedDom = document.getElementById(\\'editor-initial-speed\\');\\n    this.speedLimitDom = document.getElementById(\\'editor-speed-limit\\');\\n    this.laneLeftDom = document.getElementById(\\'editor-lane-left\\');\\n    this.laneRightDom = document.getElementById(\\'editor-lane-right\\');\\n\\n    this.laneLeftDom.addEventListener(\\'click\\', e => this._changeLanePreference(-1));\\n    this.laneRightDom.addEventListener(\\'click\\', e => this._changeLanePreference(+1));\\n\\n    this.initialSpeedDom.value = INITIAL_SPEED_FALLBACK;\\n    this.speedLimitDom.value = SPEED_LIMIT_FALLBACK;\\n    this._changeLanePreference(LANE_PREFERENCE_FALLBACK);\\n\\n    this.statsRoadLength = document.getElementById(\\'editor-stats-road-length\\');\\n    this.statsStaticObstacles = document.getElementById(\\'editor-stats-static-obstacles\\');\\n    this.statsStation = document.getElementById(\\'editor-stats-station\\');\\n    this.statsLatitude = document.getElementById(\\'editor-stats-latitude\\');\\n    this.scenarioNameDom = document.getElementById(\\'editor-scenario-name\\');\\n    this.scenarioSavedAtDom = document.getElementById(\\'editor-scenario-saved-at\\');\\n\\n    this.helpPath = document.getElementById(\\'editor-help-path\\');\\n    this.helpStaticObstacles = document.getElementById(\\'editor-help-static-obstacles\\');\\n    this.helpDynamicObstacles = document.getElementById(\\'editor-help-dynamic-obstacles\\');\\n\\n    this.changeEditMode(\\'path\\');\\n    this.removeMode = false;\\n\\n    canvas.addEventListener(\\'mousedown\\', this.mouseDown.bind(this));\\n    canvas.addEventListener(\\'mousemove\\', this.mouseMove.bind(this));\\n    canvas.addEventListener(\\'mouseup\\', this.mouseUp.bind(this));\\n    canvas.addEventListener(\\'contextmenu\\', e => this.isEnabled && e.preventDefault());\\n\\n    const editorClearOptions = document.getElementById(\\'editor-clear-options\\');\\n    document.getElementById(\\'editor-clear\\').addEventListener(\\'click\\', event => {\\n      event.stopPropagation();\\n      editorClearOptions.classList.toggle(\\'is-hidden\\');\\n    });\\n    document.addEventListener(\\'click\\', () => editorClearOptions.classList.add(\\'is-hidden\\'));\\n\\n    document.getElementById(\\'editor-clear-obstacles\\').addEventListener(\\'click\\', this.clearStaticObstacles.bind(this));\\n    document.getElementById(\\'editor-clear-dynamic-obstacles\\').addEventListener(\\'click\\', this.dynamicObstacleEditor.clearDynamicObstacles.bind(this.dynamicObstacleEditor));\\n    document.getElementById(\\'editor-clear-path\\').addEventListener(\\'click\\', this.clearPath.bind(this));\\n    document.getElementById(\\'editor-clear-all\\').addEventListener(\\'click\\', this.clearAll.bind(this));\\n\\n    document.getElementById(\\'editor-save\\').addEventListener(\\'click\\', this.saveClicked.bind(this));\\n    document.getElementById(\\'editor-load\\').addEventListener(\\'click\\', this.loadClicked.bind(this));\\n    document.getElementById(\\'editor-share\\').addEventListener(\\'click\\', this.shareClicked.bind(this));\\n\\n    document.addEventListener(\\'keydown\\', this.keyDown.bind(this));\\n    document.addEventListener(\\'keyup\\', this.keyUp.bind(this));\\n\\n    const resolution = new THREE.Vector2(this.canvas.clientWidth, this.canvas.clientHeight);\\n    this.centerlineObject = new THREE.Mesh(\\n      new THREE.Geometry(),\\n      new MeshLineMaterial({\\n        color: new THREE.Color(0x004488),\\n        lineWidth: 8,\\n        resolution: resolution,\\n        sizeAttenuation: false,\\n        near: camera.near,\\n        far: camera.far,\\n        depthWrite: false\\n      })\\n    );\\n    this.centerlineObject.rotation.x = Math.PI / 2;\\n    this.centerlineObject.renderOrder = 1;\\n    this.group.add(this.centerlineObject);\\n\\n    this.leftBoundaryObject = new THREE.Mesh(\\n      new THREE.Geometry(),\\n      new MeshLineMaterial({\\n        color: new THREE.Color(0xff40ff),\\n        lineWidth: 0.15,\\n        resolution: resolution,\\n        transparent: true,\\n        opacity: 0.7\\n      })\\n    );\\n    this.leftBoundaryObject.rotation.x = Math.PI / 2;\\n    this.leftBoundaryObject.renderOrder = 1;\\n    this.group.add(this.leftBoundaryObject);\\n\\n    this.rightBoundaryObject = new THREE.Mesh(\\n      new THREE.Geometry(),\\n      new MeshLineMaterial({\\n        color: new THREE.Color(0xff40ff),\\n        lineWidth: 0.15,\\n        resolution: resolution,\\n        transparent: true,\\n        opacity: 0.7\\n      })\\n    );\\n    this.rightBoundaryObject.rotation.x = Math.PI / 2;\\n    this.rightBoundaryObject.renderOrder = 1;\\n    this.group.add(this.rightBoundaryObject);\\n\\n    window.addEventListener(\\'resize\\', () => {\\n      // Use setTimeout to queue the resolution update after the canvas is reflowed.\\n      // This gets around some weirdness noticed when opening and closing Chrome Developer Tools.\\n      setTimeout(() => {\\n        const resolution = new THREE.Vector2(this.canvas.clientWidth, this.canvas.clientHeight);\\n        this.centerlineObject.material.uniforms.resolution.value = resolution;\\n        this.leftBoundaryObject.material.uniforms.resolution.value = resolution;\\n        this.rightBoundaryObject.material.uniforms.resolution.value = resolution;\\n      }, 0);\\n    });\\n  }\\n\\n  get enabled() {\\n    return this.isEnabled;\\n  }\\n\\n  set enabled(e) {\\n    this.isEnabled = e;\\n    this.pointGroup.visible = this.obstacleGroup.visible = !!this.isEnabled\\n  }\\n\\n  get staticObstacles() {\\n    return this.obstacleGroup.children.map(o => new StaticObstacle[\"a\" /* default */](new THREE.Vector2(o.position.x, o.position.z), -o.rotation.z, o.userData.width, o.userData.height));\\n  }\\n\\n  get dynamicObstacles() {\\n    return this.dynamicObstacleEditor.collectDynamicObstacles();\\n  }\\n\\n  get initialSpeed() {\\n    let speed = parseFloat(this.initialSpeedDom.value);\\n    if (Number.isNaN(speed) || speed < 0)\\n      speed = 0;\\n\\n    return Number.isNaN(speed) || speed < 0 ? INITIAL_SPEED_FALLBACK : speed;\\n  }\\n\\n  get speedLimit() {\\n    let limit = parseFloat(this.speedLimitDom.value);\\n    if (Number.isNaN(limit) || limit < 0)\\n      limit = 0;\\n\\n    return Number.isNaN(limit) || limit < 0 ? SPEED_LIMIT_FALLBACK : limit;\\n  }\\n\\n  scenarioToJSON() {\\n    const trunc = n => +n.toFixed(5);\\n\\n    const json = {\\n      p: Array.prototype.concat.apply([], this.lanePath.anchors.map(a => [trunc(a.x), trunc(a.y)])),\\n      s: this.staticObstacles.map(o => o.toJSON()),\\n      d: this.dynamicObstacleEditor.toJSON(),\\n      l: Number(this.lanePath.arcLength.toFixed(3)),\\n      c: {\\n        s: this.initialSpeedDom.value,\\n        sl: this.speedLimitDom.value,\\n        lp: this.lanePreference\\n      },\\n      v: 1\\n    };\\n\\n    return json;\\n  }\\n\\n  loadJSON(json) {\\n    if (json.p === undefined || json.p.length % 2 != 0) {\\n      throw new Error(\\'Incomplete lane path.\\');\\n    }\\n\\n    this.clearAll();\\n\\n    this.lanePath = new LanePath[\"a\" /* default */]();\\n    for (let i = 0; i < json.p.length; i += 2) {\\n      this.addPoint(new THREE.Vector2(json.p[i], json.p[i + 1]), false);\\n    }\\n    this.lanePath.resampleAll();\\n    this.rebuildPathGeometry();\\n\\n    json.s.forEach(o => {\\n      const staticObstacle = StaticObstacle[\"a\" /* default */].fromJSON(o);\\n      this.addStaticObstacle(new THREE.Vector3(staticObstacle.pos.x, 0, staticObstacle.pos.y), staticObstacle.width, staticObstacle.height, staticObstacle.rot)\\n    });\\n\\n    this.dynamicObstacleEditor.loadJSON(json.d);\\n\\n    let initialSpeed = INITIAL_SPEED_FALLBACK;\\n    let speedLimit = SPEED_LIMIT_FALLBACK;\\n    try { initialSpeed = json.c.s; } catch (e) { }\\n    try { speedLimit = json.c.sl; } catch (e) { }\\n\\n    this.initialSpeedDom.value = initialSpeed;\\n    this.speedLimitDom.value = speedLimit;\\n\\n    let lanePreference = LANE_PREFERENCE_FALLBACK;\\n    try {\\n      if (typeof(json.c.lp) === \\'number\\')\\n        lanePreference = Math.sign(json.c.lp) || LANE_PREFERENCE_FALLBACK;\\n    } catch (e) { }\\n\\n    this._changeLanePreference(lanePreference);\\n  }\\n\\n  update() {\\n    if (!this.isEnabled) return;\\n\\n    this.raycaster.setFromCamera(this.mouse, this.camera);\\n    const intersection = this.raycaster.ray.intersectPlane(GROUND_PLANE);\\n\\n    const [station, latitude, _around] = this.lanePath.stationLatitudeFromPosition(new THREE.Vector2(intersection.x, intersection.z));\\n    this.statsStation.textContent = (station || 0).toFixed(1);\\n    this.statsLatitude.textContent = (latitude || 0).toFixed(1);\\n\\n    if (this.draggingPoint) {\\n      if (intersection != null) {\\n        this.updatePoint(this.draggingPoint, intersection.clone().add(this.dragOffset));\\n        this.rebuildPathGeometry();\\n      }\\n    } else if (this.draggingObstacle) {\\n      if (intersection !== null) {\\n        if (this.draggingObstacle === true) {\\n          if (this.draggingObstaclePreview) this.group.remove(this.draggingObstaclePreview);\\n\\n          const [center, width, height] = this._dimensionsFromRect(this.dragOffset, intersection);\\n\\n          this.draggingObstaclePreview = new THREE.Mesh(\\n            new THREE.PlaneGeometry(width, height),\\n            new THREE.MeshBasicMaterial({ color: NORMAL_STATIC_OBSTACLE_COLOR, depthTest: false, transparent: true, opacity: 0.4 })\\n          );\\n          this.draggingObstaclePreview.rotation.x = -Math.PI / 2;\\n          this.draggingObstaclePreview.position.copy(center);\\n          this.group.add(this.draggingObstaclePreview);\\n        } else {\\n          this.draggingObstacle.position.copy(intersection.clone().add(this.dragOffset));\\n        }\\n      }\\n    } else if (this.rotatingObstacle) {\\n      const rotation = (this.dragOffset.x - this.mouse.x) * 2 *  Math.PI;\\n      this.rotatingObstacle.rotation.z = Math.wrapAngle(rotation + this.initialObstacleRotation);\\n    } else {\\n      this.pointGroup.children.forEach(p => {\\n        p.material.color.set(NORMAL_POINT_COLOR)\\n        p.material.opacity = NORMAL_OPACITY;\\n      });\\n\\n      this.obstacleGroup.children.forEach(o => {\\n        o.material.color.set(NORMAL_STATIC_OBSTACLE_COLOR)\\n        o.material.opacity = NORMAL_OPACITY;\\n      });\\n\\n      this.canvas.classList.remove(\\'editor-grab\\', \\'editor-grabbing\\', \\'editor-removing\\');\\n\\n      if (this.editMode == \\'path\\' && this.pointGroup.children.length > 0) {\\n        let picked = null;\\n        this.raycaster.intersectObjects(this.pointGroup.children).forEach(p => {\\n          if (picked === null || p.object.userData.index > picked.object.userData.index) picked = p;\\n        });\\n\\n        if (picked) {\\n          picked.object.material.color.set(HOVER_POINT_COLOR);\\n          picked.object.material.opacity = HOVER_OPACITY;\\n\\n          if (this.removeMode)\\n            this.canvas.classList.add(\\'editor-removing\\');\\n          else\\n            this.canvas.classList.add(\\'editor-grab\\');\\n        }\\n      } else if (this.editMode == \\'staticObstacles\\' && this.obstacleGroup.children.length > 0) {\\n        let picked = null;\\n        this.raycaster.intersectObjects(this.obstacleGroup.children).forEach(o => {\\n          if (picked === null || o.object.userData.index > picked.object.userData.index) picked = o;\\n        });\\n\\n        if (picked) {\\n          picked.object.material.color.set(HOVER_STATIC_OBSTACLE_COLOR);\\n          picked.object.material.opacity = HOVER_OPACITY;\\n\\n          if (this.removeMode)\\n            this.canvas.classList.add(\\'editor-removing\\');\\n          else\\n            this.canvas.classList.add(\\'editor-grab\\');\\n        }\\n      }\\n    }\\n  }\\n\\n  changeEditMode(mode) {\\n    this.editorPathButton.classList.add(\\'is-outlined\\');\\n    this.editorObstaclesButton.classList.add(\\'is-outlined\\');\\n    this.editorDynamicObstaclesButton.classList.add(\\'is-outlined\\');\\n    this.editorPathButton.classList.remove(\\'is-selected\\');\\n    this.editorObstaclesButton.classList.remove(\\'is-selected\\');\\n    this.editorDynamicObstaclesButton.classList.remove(\\'is-selected\\');\\n    this.editorRoadBox.classList.add(\\'is-hidden\\');\\n    this.helpPath.classList.add(\\'is-hidden\\');\\n    this.helpStaticObstacles.classList.add(\\'is-hidden\\');\\n    this.helpDynamicObstacles.classList.add(\\'is-hidden\\');\\n\\n    if (mode == \\'path\\') {\\n      this.editMode = \\'path\\';\\n      this.editorPathButton.classList.remove(\\'is-outlined\\');\\n      this.editorPathButton.classList.add(\\'is-selected\\');\\n      this.editorRoadBox.classList.remove(\\'is-hidden\\');\\n      this.helpPath.classList.remove(\\'is-hidden\\');\\n      this.dynamicObstacleEditor.disable();\\n    } else if (mode == \\'staticObstacles\\') {\\n      this.editMode = \\'staticObstacles\\';\\n      this.editorObstaclesButton.classList.remove(\\'is-outlined\\');\\n      this.editorObstaclesButton.classList.add(\\'is-selected\\');\\n      this.helpStaticObstacles.classList.remove(\\'is-hidden\\');\\n      this.dynamicObstacleEditor.disable();\\n    } else {\\n      this.editMode = \\'dynamicObstacles\\';\\n      this.editorDynamicObstaclesButton.classList.remove(\\'is-outlined\\');\\n      this.editorDynamicObstaclesButton.classList.add(\\'is-selected\\');\\n      this.helpDynamicObstacles.classList.remove(\\'is-hidden\\');\\n      this.dynamicObstacleEditor.enable();\\n    }\\n  }\\n\\n  addStaticObstacle(center, width, height, rotation = 0) {\\n    const obstacle = new THREE.Mesh(\\n      new THREE.PlaneGeometry(width, height),\\n      new THREE.MeshBasicMaterial({ color: NORMAL_STATIC_OBSTACLE_COLOR, depthTest: false, transparent: true, opacity: NORMAL_OPACITY })\\n    );\\n    obstacle.rotation.x = -Math.PI / 2;\\n    obstacle.rotation.z = -Math.wrapAngle(rotation);\\n    obstacle.position.copy(center);\\n    obstacle.userData = { index: this.obstacleIndex++, width: width, height: height };\\n\\n    this.obstacleGroup.add(obstacle);\\n    this.statsStaticObstacles.textContent = this.obstacleGroup.children.length;\\n  }\\n\\n  removeStaticObstacle(obstacle) {\\n    this.obstacleGroup.remove(obstacle);\\n    this.statsStaticObstacles.textContent = this.obstacleGroup.children.length;\\n  }\\n\\n  clearStaticObstacles() {\\n    this.group.remove(this.obstacleGroup);\\n    this.obstacleGroup = new THREE.Group();\\n    this.obstacleGroup.renderOrder = 1;\\n    this.group.add(this.obstacleGroup);\\n    this.obstacleIndex = 0;\\n    this.statsStaticObstacles.textContent = 0;\\n  }\\n\\n  clearAll() {\\n    this.clearPath();\\n    this.clearStaticObstacles();\\n    this.dynamicObstacleEditor.clearDynamicObstacles();\\n  }\\n\\n  rebuildPathGeometry() {\\n    if (this.lanePath.anchors.length > 1) {\\n      this.centerlineGeometry.setFromPoints(this.lanePath.centerline);\\n      const centerline = new MeshLine();\\n      centerline.setGeometry(this.centerlineGeometry);\\n      this.centerlineObject.geometry = centerline.geometry;\\n\\n      this.leftBoundaryGeometry.setFromPoints(this.lanePath.leftBoundary);\\n      const leftBoundary = new MeshLine();\\n      leftBoundary.setGeometry(this.leftBoundaryGeometry);\\n      this.leftBoundaryObject.geometry = leftBoundary.geometry;\\n\\n      this.rightBoundaryGeometry.setFromPoints(this.lanePath.rightBoundary);\\n      const rightBoundary = new MeshLine();\\n      rightBoundary.setGeometry(this.rightBoundaryGeometry);\\n      this.rightBoundaryObject.geometry = rightBoundary.geometry;\\n    } else {\\n      this.centerlineObject.geometry.dispose();\\n      this.centerlineObject.geometry = new THREE.Geometry();\\n\\n      this.leftBoundaryObject.geometry.dispose();\\n      this.leftBoundaryObject.geometry = new THREE.Geometry();\\n\\n      this.rightBoundaryObject.geometry.dispose();\\n      this.rightBoundaryObject.geometry = new THREE.Geometry();\\n    }\\n\\n    this.statsRoadLength.textContent = this.lanePath.arcLength.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });\\n  }\\n\\n  addPoint(pos, resample = true) {\\n    const point = new THREE.Mesh(\\n      new THREE.CircleGeometry(1, 32),\\n      new THREE.MeshBasicMaterial({\\n        color: NORMAL_POINT_COLOR,\\n        depthTest: false,\\n        transparent: true,\\n        opacity: NORMAL_OPACITY\\n      })\\n    );\\n    point.rotation.x = -Math.PI / 2;\\n    point.position.set(pos.x, 0, pos.y);\\n    point.userData = { index: this.pointIndex++ };\\n\\n    this.lanePath.addAnchor(pos, resample);\\n    this.pointGroup.add(point);\\n\\n    return point;\\n  }\\n\\n  updatePoint(object, pos) {\\n    object.position.copy(pos);\\n    this.lanePath.updateAnchor(object.userData.index, new THREE.Vector2(pos.x, pos.z));\\n  }\\n\\n  removePoint(object) {\\n    const index = object.userData.index;\\n\\n    this.pointGroup.remove(object);\\n    this.pointGroup.children.forEach(p => {\\n      if (p.userData.index > index) p.userData.index--;\\n    });\\n    this.pointIndex--;\\n\\n    this.lanePath.removeAnchor(index);\\n  }\\n\\n  clearPath() {\\n    this.group.remove(this.pointGroup);\\n    this.pointGroup = new THREE.Group();\\n    this.pointGroup.renderOrder = 2;\\n    this.group.add(this.pointGroup);\\n    this.pointIndex = 0;\\n\\n    this.lanePath = new LanePath[\"a\" /* default */]();\\n    this.rebuildPathGeometry();\\n\\n    this.initialSpeedDom.value = INITIAL_SPEED_FALLBACK;\\n    this.speedLimitDom.value = SPEED_LIMIT_FALLBACK;\\n  }\\n\\n  keyDown(event) {\\n    if (event.repeat || this.editMode != \\'path\\' && this.editMode != \\'staticObstacles\\') return;\\n\\n    if (event.key == \\'Shift\\') {\\n      this.removeMode = true;\\n      this.canvas.classList.add(\\'editor-pointing\\');\\n      event.preventDefault();\\n    } else if (event.key == \\'Control\\' && this.editMode == \\'staticObstacles\\') {\\n      this.rotateMode = true;\\n      this.canvas.classList.add(\\'editor-pointing\\');\\n      event.preventDefault();\\n    }\\n  }\\n\\n  keyUp(event) {\\n    if (event.key == \\'Shift\\') {\\n      this.removeMode = false;\\n      this.canvas.classList.remove(\\'editor-pointing\\', \\'editor-removing\\');\\n    } else if (event.key == \\'Control\\') {\\n      this.rotateMode = false;\\n      this.canvas.classList.remove(\\'editor-pointing\\', \\'editor-grabbing\\');\\n    }\\n  }\\n\\n  mouseDown(event) {\\n    if (!this.isEnabled || event.button != 0) return;\\n\\n    this.mouse.x = (event.offsetX / this.canvas.clientWidth) * 2 - 1;\\n    this.mouse.y = -(event.offsetY / this.canvas.clientHeight) * 2 + 1;\\n\\n    this.raycaster.setFromCamera(this.mouse, this.camera);\\n\\n    if (this.editMode == \\'path\\') {\\n      let picked = null;\\n      this.raycaster.intersectObjects(this.pointGroup.children).forEach(p => {\\n        if (picked === null || p.object.userData.index > picked.object.userData.index) picked = p;\\n      });\\n\\n      if (picked) {\\n        if (this.removeMode) {\\n          this.removePoint(picked.object);\\n          this.rebuildPathGeometry();\\n        } else {\\n          this.canvas.classList.remove(\\'editor-grab\\');\\n          this.canvas.classList.add(\\'editor-grabbing\\');\\n\\n          this.draggingPoint = picked.object;\\n          this.dragOffset.copy(picked.object.position).sub(picked.point);\\n        }\\n      } else if (!this.removeMode) {\\n        const intersection = this.raycaster.ray.intersectPlane(GROUND_PLANE);\\n        if (intersection != null) {\\n          this.addPoint(new THREE.Vector2(intersection.x, intersection.z));\\n          this.rebuildPathGeometry();\\n        }\\n      }\\n    } else if (this.editMode == \\'staticObstacles\\') {\\n      let picked = null;\\n      this.raycaster.intersectObjects(this.obstacleGroup.children).forEach(o => {\\n        if (picked === null || o.object.userData.index > picked.object.userData.index) picked = o;\\n      });\\n\\n      if (picked) {\\n        if (this.removeMode) {\\n          this.removeStaticObstacle(picked.object);\\n        } else {\\n          this.canvas.classList.remove(\\'editor-grab\\');\\n          this.canvas.classList.add(\\'editor-grabbing\\');\\n\\n          if (this.rotateMode) {\\n            this.rotatingObstacle = picked.object;\\n            this.initialObstacleRotation = picked.object.rotation.z;\\n            this.dragOffset.set(this.mouse.x, this.mouse.y, 0);\\n          } else {\\n            this.draggingObstacle = picked.object;\\n            this.dragOffset.copy(picked.object.position).sub(picked.point);\\n          }\\n        }\\n      } else if (!this.removeMode && !this.rotateMode) {\\n        const intersection = this.raycaster.ray.intersectPlane(GROUND_PLANE);\\n        if (intersection != null) {\\n          this.draggingObstacle = true;\\n          this.dragOffset.copy(intersection);\\n        }\\n      }\\n    }\\n  }\\n\\n  mouseMove(event) {\\n    this.mouse.x = (event.offsetX / this.canvas.clientWidth) * 2 - 1;\\n    this.mouse.y = -(event.offsetY / this.canvas.clientHeight) * 2 + 1;\\n  }\\n\\n  mouseUp(event) {\\n    if (!this.isEnabled || event.button != 0) return;\\n\\n    if (this.draggingObstacle === true) {\\n      this.group.remove(this.draggingObstaclePreview);\\n      this.draggingObstaclePreview = null;\\n\\n      this.mouse.x = (event.offsetX / this.canvas.clientWidth) * 2 - 1;\\n      this.mouse.y = -(event.offsetY / this.canvas.clientHeight) * 2 + 1;\\n\\n      this.raycaster.setFromCamera(this.mouse, this.camera);\\n\\n      const intersection = this.raycaster.ray.intersectPlane(GROUND_PLANE);\\n      if (intersection != null) {\\n        const [center, width, height] = this._dimensionsFromRect(this.dragOffset, intersection);\\n        this.addStaticObstacle(center, width, height);\\n      }\\n    }\\n\\n    this.draggingPoint = null;\\n    this.draggingObstacle = null;\\n    this.rotatingObstacle = null;\\n    this.canvas.classList.remove(\\'editor-grab\\', \\'editor-grabbing\\');\\n  }\\n\\n  updateSavedInfo(name, savedAt) {\\n    this.previousSavedName = name || null;\\n\\n    name = name || \\'Untitled\\';\\n    savedAt = savedAt || \\'Unsaved\\';\\n\\n    this.scenarioNameDom.textContent = name;\\n    this.scenarioNameDom.title = name;\\n    this.scenarioSavedAtDom.textContent = savedAt;\\n  }\\n\\n  _changeLanePreference(pref) {\\n    this.lanePreference = pref;\\n\\n    if (pref > 0) {\\n      this.laneLeftDom.classList.add(\\'is-outlined\\');\\n      this.laneLeftDom.classList.remove(\\'is-selected\\');\\n      this.laneRightDom.classList.remove(\\'is-outlined\\');\\n      this.laneRightDom.classList.add(\\'is-selected\\');\\n    } else {\\n      this.laneRightDom.classList.add(\\'is-outlined\\');\\n      this.laneRightDom.classList.remove(\\'is-selected\\');\\n      this.laneLeftDom.classList.remove(\\'is-outlined\\');\\n      this.laneLeftDom.classList.add(\\'is-selected\\');\\n    }\\n  }\\n\\n  saveClicked() {\\n    const name = window.prompt(\\'Name your scenario:\\', this.previousSavedName || \\'\\');\\n    if (name === null) return;\\n    if (name === \\'\\') {\\n      window.alert(\\'The scenario name cannot be blank.\\');\\n      return;\\n    }\\n\\n    let [success, savedAt] = this.scenarioManager.saveScenario(name, this.scenarioToJSON(), name === this.previousSavedName);\\n    const formattedSavedAt = formatDate(savedAt);\\n\\n    if (success) {\\n      this.updateSavedInfo(name, formattedSavedAt);\\n    } else if (confirm(`A scenario named \"${name}\" already exists, last saved ${formattedSavedAt}. Do you want to overwrite it?`)) {\\n      [success, savedAt] = this.scenarioManager.saveScenario(name, this.scenarioToJSON(), true);\\n      this.updateSavedInfo(name, formatDate(savedAt));\\n    }\\n  }\\n\\n  loadClicked() {\\n    this.scenarioManager.showModal();\\n  }\\n\\n  shareClicked() {\\n    this.shareManager.showModal(this.scenarioToJSON());\\n  }\\n\\n  _dimensionsFromRect(from, to) {\\n    const center = from.clone().add(to).divideScalar(2);\\n    const width = Math.max(0.5, Math.abs(from.x - to.x));\\n    const height = Math.max(0.5, Math.abs(from.z - to.z));\\n    return [center, width, height];\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/simulator/OrbitControls.js\\n/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author erich666 / http://erichaines.com\\n */\\n\\n// This set of controls performs orbiting, dollying (zooming), and panning.\\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\\n//\\n//    Orbit - left mouse / touch: one finger move\\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\\n\\nconst OrbitControls = function ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// Set to false to disable this control\\n\\tthis.enabled = true;\\n\\n\\t// \"target\" sets the location of focus, where the object orbits around\\n\\tthis.target = new THREE.Vector3();\\n\\n\\t// How far you can dolly in and out ( PerspectiveCamera only )\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\t// How far you can zoom in and out ( OrthographicCamera only )\\n\\tthis.minZoom = 0;\\n\\tthis.maxZoom = Infinity;\\n\\n\\t// How far you can orbit vertically, upper and lower limits.\\n\\t// Range is 0 to Math.PI radians.\\n\\tthis.minPolarAngle = 0; // radians\\n\\tthis.maxPolarAngle = Math.PI; // radians\\n\\n\\t// How far you can orbit horizontally, upper and lower limits.\\n\\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\\n\\tthis.minAzimuthAngle = - Infinity; // radians\\n\\tthis.maxAzimuthAngle = Infinity; // radians\\n\\n\\t// Set to true to enable damping (inertia)\\n\\t// If damping is enabled, you must call controls.update() in your animation loop\\n\\tthis.enableDamping = false;\\n\\tthis.dampingFactor = 0.25;\\n\\n\\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\\n\\t// Set to false to disable zooming\\n\\tthis.enableZoom = true;\\n\\tthis.zoomSpeed = 1.0;\\n\\n\\t// Set to false to disable rotating\\n\\tthis.enableRotate = true;\\n\\tthis.rotateSpeed = 1.0;\\n\\n\\t// Set to false to disable panning\\n\\tthis.enablePan = true;\\n\\tthis.keyPanSpeed = 7.0;\\t// pixels moved per arrow key push\\n\\n\\t// Set to true to automatically rotate around the target\\n\\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\\n\\tthis.autoRotate = false;\\n\\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\\n\\n\\t// Set to false to disable use of the keys\\n\\tthis.enableKeys = true;\\n\\n\\t// The four arrow keys\\n\\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\\n\\n\\t// Mouse buttons\\n\\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\\n\\n\\t// for reset\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\tthis.zoom0 = this.object.zoom;\\n\\n\\t//\\n\\t// public methods\\n\\t//\\n\\n\\tthis.getPolarAngle = function () {\\n\\n\\t\\treturn spherical.phi;\\n\\n\\t};\\n\\n\\tthis.getAzimuthalAngle = function () {\\n\\n\\t\\treturn spherical.theta;\\n\\n\\t};\\n\\n\\tthis.saveState = function () {\\n\\n\\t\\tscope.target0.copy( scope.target );\\n\\t\\tscope.position0.copy( scope.object.position );\\n\\t\\tscope.zoom0 = scope.object.zoom;\\n\\n\\t};\\n\\n\\tthis.reset = function () {\\n\\n\\t\\tscope.target.copy( scope.target0 );\\n\\t\\tscope.object.position.copy( scope.position0 );\\n\\t\\tscope.object.zoom = scope.zoom0;\\n\\n\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\tscope.update();\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t};\\n\\n  this.rotateLeft = function(angle) {\\n    rotateLeft(angle);\\n  }\\n\\n\\t// this method is exposed, but perhaps it would be better if we can make it private...\\n\\tthis.update = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\t// so camera.up is the orbit axis\\n\\t\\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\\n\\t\\tvar quatInverse = quat.clone().inverse();\\n\\n\\t\\tvar lastPosition = new THREE.Vector3();\\n\\t\\tvar lastQuaternion = new THREE.Quaternion();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar position = scope.object.position;\\n\\n\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\n\\t\\t\\t// rotate offset to \"y-axis-is-up\" space\\n\\t\\t\\toffset.applyQuaternion( quat );\\n\\n\\t\\t\\t// angle from z-axis around y-axis\\n\\t\\t\\tspherical.setFromVector3( offset );\\n\\n\\t\\t\\tif ( scope.autoRotate && state === STATE.NONE ) {\\n\\n\\t\\t\\t\\trotateLeft( getAutoRotationAngle() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tspherical.theta += sphericalDelta.theta;\\n\\t\\t\\tspherical.phi += sphericalDelta.phi;\\n\\n\\t\\t\\t// restrict theta to be between desired limits\\n\\t\\t\\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\\n\\n\\t\\t\\t// restrict phi to be between desired limits\\n\\t\\t\\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\\n\\n\\t\\t\\tspherical.makeSafe();\\n\\n\\n\\t\\t\\tspherical.radius *= scale;\\n\\n\\t\\t\\t// restrict radius to be between desired limits\\n\\t\\t\\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\\n\\n\\t\\t\\t// move target to panned location\\n\\t\\t\\tscope.target.add( panOffset );\\n\\n\\t\\t\\toffset.setFromSpherical( spherical );\\n\\n\\t\\t\\t// rotate offset back to \"camera-up-vector-is-up\" space\\n\\t\\t\\toffset.applyQuaternion( quatInverse );\\n\\n\\t\\t\\tposition.copy( scope.target ).add( offset );\\n\\n\\t\\t\\tscope.object.lookAt( scope.target );\\n\\n\\t\\t\\tif ( scope.enableDamping === true ) {\\n\\n\\t\\t\\t\\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\\n\\t\\t\\t\\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tsphericalDelta.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscale = 1;\\n\\t\\t\\tpanOffset.set( 0, 0, 0 );\\n\\n\\t\\t\\t// update condition is:\\n\\t\\t\\t// min(camera displacement, camera rotation in radians)^2 > EPS\\n\\t\\t\\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\\n\\n\\t\\t\\tif ( zoomChanged ||\\n\\t\\t\\t\\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\\n\\t\\t\\t\\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\\n\\n\\t\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t\\t\\tlastPosition.copy( scope.object.position );\\n\\t\\t\\t\\tlastQuaternion.copy( scope.object.quaternion );\\n\\t\\t\\t\\tzoomChanged = false;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tthis.dispose = function () {\\n\\n\\t\\tscope.domElement.removeEventListener( \\'contextmenu\\', onContextMenu, false );\\n\\t\\tscope.domElement.removeEventListener( \\'mousedown\\', onMouseDown, false );\\n\\t\\tscope.domElement.removeEventListener( \\'wheel\\', onMouseWheel, false );\\n\\n\\t\\tscope.domElement.removeEventListener( \\'touchstart\\', onTouchStart, false );\\n\\t\\tscope.domElement.removeEventListener( \\'touchend\\', onTouchEnd, false );\\n\\t\\tscope.domElement.removeEventListener( \\'touchmove\\', onTouchMove, false );\\n\\n\\t\\tdocument.removeEventListener( \\'mousemove\\', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( \\'mouseup\\', onMouseUp, false );\\n\\n\\t\\twindow.removeEventListener( \\'keydown\\', onKeyDown, false );\\n\\n\\t\\t//scope.dispatchEvent( { type: \\'dispose\\' } ); // should this be added here?\\n\\n\\t};\\n\\n\\t//\\n\\t// internals\\n\\t//\\n\\n\\tvar scope = this;\\n\\n\\tvar changeEvent = { type: \\'change\\' };\\n\\tvar startEvent = { type: \\'start\\' };\\n\\tvar endEvent = { type: \\'end\\' };\\n\\n\\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\\n\\n\\tvar state = STATE.NONE;\\n\\n\\tvar EPS = 0.000001;\\n\\n\\t// current position in spherical coordinates\\n\\tvar spherical = new THREE.Spherical();\\n\\tvar sphericalDelta = new THREE.Spherical();\\n\\n\\tvar scale = 1;\\n\\tvar panOffset = new THREE.Vector3();\\n\\tvar zoomChanged = false;\\n\\n\\tvar rotateStart = new THREE.Vector2();\\n\\tvar rotateEnd = new THREE.Vector2();\\n\\tvar rotateDelta = new THREE.Vector2();\\n\\n\\tvar panStart = new THREE.Vector2();\\n\\tvar panEnd = new THREE.Vector2();\\n\\tvar panDelta = new THREE.Vector2();\\n\\n\\tvar dollyStart = new THREE.Vector2();\\n\\tvar dollyEnd = new THREE.Vector2();\\n\\tvar dollyDelta = new THREE.Vector2();\\n\\n\\tfunction getAutoRotationAngle() {\\n\\n\\t\\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\\n\\n\\t}\\n\\n\\tfunction getZoomScale() {\\n\\n\\t\\treturn Math.pow( 0.95, scope.zoomSpeed );\\n\\n\\t}\\n\\n\\tfunction rotateLeft( angle ) {\\n\\n\\t\\tsphericalDelta.theta -= angle;\\n\\n\\t}\\n\\n\\tfunction rotateUp( angle ) {\\n\\n\\t\\tsphericalDelta.phi -= angle;\\n\\n\\t}\\n\\n\\tvar panLeft = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panLeft( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( - distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tvar panUp = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panUp( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t// deltaX and deltaY are in pixels; right and down are positive\\n\\tvar pan = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\treturn function pan( deltaX, deltaY ) {\\n\\n\\t\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t\\tif ( scope.object.isPerspectiveCamera ) {\\n\\n\\t\\t\\t\\t// perspective\\n\\t\\t\\t\\tvar position = scope.object.position;\\n\\t\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\t\\t\\t\\tvar targetDistance = offset.length();\\n\\n\\t\\t\\t\\t// half of the fov is center to top of screen\\n\\t\\t\\t\\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\\n\\n\\t\\t\\t\\t// we actually don\\'t use screenWidth, since perspective camera is fixed to screen height\\n\\t\\t\\t\\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else if ( scope.object.isOrthographicCamera ) {\\n\\n\\t\\t\\t\\t// orthographic\\n\\t\\t\\t\\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// camera neither orthographic nor perspective\\n\\t\\t\\t\\tconsole.warn( \\'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\\' );\\n\\t\\t\\t\\tscope.enablePan = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tfunction dollyIn( dollyScale ) {\\n\\n\\t\\tif ( scope.object.isPerspectiveCamera ) {\\n\\n\\t\\t\\tscale /= dollyScale;\\n\\n\\t\\t} else if ( scope.object.isOrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( \\'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\\' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction dollyOut( dollyScale ) {\\n\\n\\t\\tif ( scope.object.isPerspectiveCamera ) {\\n\\n\\t\\t\\tscale *= dollyScale;\\n\\n\\t\\t} else if ( scope.object.isOrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( \\'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\\' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t//\\n\\t// event callbacks - update the object state\\n\\t//\\n\\n\\tfunction handleMouseDownRotate( event ) {\\n\\n\\t\\t//console.log( \\'handleMouseDownRotate\\' );\\n\\n\\t\\trotateStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownDolly( event ) {\\n\\n\\t\\t//console.log( \\'handleMouseDownDolly\\' );\\n\\n\\t\\tdollyStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownPan( event ) {\\n\\n\\t\\t//console.log( \\'handleMouseDownPan\\' );\\n\\n\\t\\tpanStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveRotate( event ) {\\n\\n\\t\\t//console.log( \\'handleMouseMoveRotate\\' );\\n\\n\\t\\trotateEnd.set( event.clientX, event.clientY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveDolly( event ) {\\n\\n\\t\\t//console.log( \\'handleMouseMoveDolly\\' );\\n\\n\\t\\tdollyEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMovePan( event ) {\\n\\n\\t\\t//console.log( \\'handleMouseMovePan\\' );\\n\\n\\t\\tpanEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseUp( event ) {\\n\\n\\t\\t// console.log( \\'handleMouseUp\\' );\\n\\n\\t}\\n\\n\\tfunction handleMouseWheel( event ) {\\n\\n\\t\\t// console.log( \\'handleMouseWheel\\' );\\n\\n\\t\\tif ( event.deltaY < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( event.deltaY > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleKeyDown( event ) {\\n\\n\\t\\t//console.log( \\'handleKeyDown\\' );\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase scope.keys.UP:\\n\\t\\t\\t\\tpan( 0, scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.BOTTOM:\\n\\t\\t\\t\\tpan( 0, - scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.LEFT:\\n\\t\\t\\t\\tpan( scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.RIGHT:\\n\\t\\t\\t\\tpan( - scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction handleTouchStartRotate( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchStartRotate\\' );\\n\\n\\t\\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartDolly( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchStartDolly\\' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyStart.set( 0, distance );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartPan( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchStartPan\\' );\\n\\n\\t\\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveRotate( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchMoveRotate\\' );\\n\\n\\t\\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveDolly( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchMoveDolly\\' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyEnd.set( 0, distance );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMovePan( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchMovePan\\' );\\n\\n\\t\\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchEnd( event ) {\\n\\n\\t\\t//console.log( \\'handleTouchEnd\\' );\\n\\n\\t}\\n\\n\\t//\\n\\t// event handlers - FSM: listen for events and reset state\\n\\t//\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\tcase scope.mouseButtons.ORBIT:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.ZOOM:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tdocument.addEventListener( \\'mousemove\\', onMouseMove, false );\\n\\t\\t\\tdocument.addEventListener( \\'mouseup\\', onMouseUp, false );\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( state ) {\\n\\n\\t\\t\\tcase STATE.ROTATE:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.DOLLY:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseUp( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleMouseUp( event );\\n\\n\\t\\tdocument.removeEventListener( \\'mousemove\\', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( \\'mouseup\\', onMouseUp, false );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\thandleMouseWheel( event );\\n\\n\\t\\tscope.dispatchEvent( startEvent ); // not sure why these are here...\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction onKeyDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\\n\\n\\t\\thandleKeyDown( event );\\n\\n\\t}\\n\\n\\tfunction onTouchStart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\t// one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\t// two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1: // one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2: // two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchEnd( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleTouchEnd( event );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onContextMenu( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t}\\n\\n\\t//\\n\\n\\tscope.domElement.addEventListener( \\'contextmenu\\', onContextMenu, false );\\n\\n\\tscope.domElement.addEventListener( \\'mousedown\\', onMouseDown, false );\\n\\tscope.domElement.addEventListener( \\'wheel\\', onMouseWheel, false );\\n\\n\\tscope.domElement.addEventListener( \\'touchstart\\', onTouchStart, false );\\n\\tscope.domElement.addEventListener( \\'touchend\\', onTouchEnd, false );\\n\\tscope.domElement.addEventListener( \\'touchmove\\', onTouchMove, false );\\n\\n\\twindow.addEventListener( \\'keydown\\', onKeyDown, false );\\n\\n\\t// force an update at start\\n\\n\\tthis.update();\\n\\n};\\n\\nOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\nOrbitControls.prototype.constructor = OrbitControls;\\n\\nObject.defineProperties( OrbitControls.prototype, {\\n\\n\\tcenter: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .center has been renamed to .target\\' );\\n\\t\\t\\treturn this.target;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// backward compatibility\\n\\n\\tnoZoom: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.\\' );\\n\\t\\t\\treturn ! this.enableZoom;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.\\' );\\n\\t\\t\\tthis.enableZoom = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoRotate: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.\\' );\\n\\t\\t\\treturn ! this.enableRotate;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.\\' );\\n\\t\\t\\tthis.enableRotate = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoPan: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noPan has been deprecated. Use .enablePan instead.\\' );\\n\\t\\t\\treturn ! this.enablePan;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noPan has been deprecated. Use .enablePan instead.\\' );\\n\\t\\t\\tthis.enablePan = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoKeys: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.\\' );\\n\\t\\t\\treturn ! this.enableKeys;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.\\' );\\n\\t\\t\\tthis.enableKeys = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tstaticMoving: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.\\' );\\n\\t\\t\\treturn ! this.enableDamping;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.\\' );\\n\\t\\t\\tthis.enableDamping = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tdynamicDampingFactor: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.\\' );\\n\\t\\t\\treturn this.dampingFactor;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( \\'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.\\' );\\n\\t\\t\\tthis.dampingFactor = value;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n} );\\n\\n/* harmony default export */ var simulator_OrbitControls = (OrbitControls);\\n\\n// CONCATENATED MODULE: ./js/simulator/TopDownCameraControls.js\\nconst groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0));\\nlet panning = false;\\n\\nclass TopDownCameraControls {\\n  constructor(domElement, camera) {\\n    this.domElement = domElement;\\n    this.camera = camera;\\n    this.enablePanning = false;\\n    this.enabled = true;\\n\\n    this.minAltitude = Number.NEGATIVE_INFINITY;\\n    this.maxAltitude = Number.POSITIVE_INFINITY;\\n\\n    this.mouseDown = this.mouseDown.bind(this);\\n    this.mouseMove = this.mouseMove.bind(this);\\n    this.mouseUp = this.mouseUp.bind(this);\\n    this.wheel = this.wheel.bind(this);\\n\\n    this.domElement.addEventListener(\\'mousedown\\', this.mouseDown);\\n    this.domElement.addEventListener(\\'mousemove\\', this.mouseMove);\\n    this.domElement.addEventListener(\\'mouseup\\', this.mouseUp);\\n    this.domElement.addEventListener(\\'wheel\\', this.wheel);\\n  }\\n\\n  reset(prevCamera) {\\n    const lookAt = new THREE.Vector3(0, 0, -1);\\n    lookAt.applyQuaternion(prevCamera.quaternion);\\n\\n    const ray = new THREE.Ray(prevCamera.position, lookAt);\\n    const intersection = ray.intersectPlane(groundPlane);\\n\\n    if (intersection) {\\n      this.camera.position.set(intersection.x, 50, intersection.z);\\n    } else {\\n      this.camera.position.y = 50;\\n    }\\n\\n    this.camera.rotation.set(-Math.PI / 2, 0, 0);\\n  }\\n\\n  mouseDown(event) {\\n    if (!this.enabled || !this.enablePanning || event.button != 2) return;\\n    panning = true;\\n  }\\n\\n  mouseMove(event) {\\n    if (panning) {\\n      const distance = 2 * this.camera.position.y * Math.tan((this.camera.fov / 2) * Math.PI / 180) / this.domElement.clientHeight;\\n      this.camera.position.x -= distance * event.movementX;\\n      this.camera.position.z -= distance * event.movementY;\\n    }\\n  }\\n\\n  mouseUp(event) {\\n    if (event.button != 2) return;\\n    panning = false;\\n  }\\n\\n  wheel(event) {\\n    if (!this.enabled) return;\\n\\n    event.preventDefault();\\n\\n    this.camera.position.y = Math.max(this.minAltitude, Math.min(this.maxAltitude, this.camera.position.y * Math.pow(0.995, -event.deltaY)));\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/simulator/Dashboard.js\\n\\n\\nconst MPS_TO_MPH = 2.23694;\\nconst METERS_TO_FEET = 3.28084;\\n\\nclass Dashboard_Dashboard {\\n  constructor(car) {\\n    this.car = car;\\n    this.units = \\'metric\\';\\n\\n    if (document.readyState == \\'complete\\') {\\n      this.fetchDomElements.call(this);\\n    } else {\\n      document.addEventListener(\\'readystatechange\\', event => {\\n        if (event.target.readyState == \\'complete\\')\\n          this.fetchDomElements.call(this);\\n      });\\n    }\\n  }\\n\\n  fetchDomElements() {\\n    this.wheelDom = document.getElementById(\\'wheel\\');\\n    this.wheelPieDom = document.getElementById(\\'wheel-pie\\');\\n    this.wheelPieLeftDom = document.getElementById(\\'wheel-pie-left\\');\\n    this.wheelPieRightDom = document.getElementById(\\'wheel-pie-right\\');\\n    this.gearDom = document.getElementById(\\'gear\\');\\n    this.gasDom = document.getElementById(\\'gas\\');\\n    this.brakeDom = document.getElementById(\\'brake\\');\\n    this.speedDom = document.getElementById(\\'speed\\');\\n    this.stationDom = document.getElementById(\\'station\\');\\n    this.latitudeDom = document.getElementById(\\'latitude\\');\\n    this.planTimeDom = document.getElementById(\\'plan-time\\');\\n    this.elapsedTimeDom = document.getElementById(\\'elapsed-time\\');\\n\\n    this.speedUnitsDom = document.getElementById(\\'speed-units\\');\\n    this.stationUnitsDom = document.getElementById(\\'station-units\\');\\n    this.latitudeUnitsDom = document.getElementById(\\'latitude-units\\');\\n\\n    [this.speedUnitsDom, this.stationUnitsDom, this.latitudeUnitsDom].forEach(el => {\\n      el.addEventListener(\\'click\\', event => {\\n        this.toggleUnits();\\n      });\\n    });\\n  }\\n\\n  toggleUnits() {\\n    let speedUnits;\\n    let distanceUnits;\\n\\n    if (this.units == \\'metric\\') {\\n      this.units = \\'imperial\\';\\n      speedUnits = \\'mph\\';\\n      distanceUnits = \\'feet\\';\\n    } else {\\n      this.units = \\'metric\\';\\n      speedUnits = \\'m/s\\';\\n      distanceUnits = \\'meters\\';\\n    }\\n\\n    // this.speedUnitsDom.textContent = speedUnits;\\n    // this.stationUnitsDom.textContent = distanceUnits;\\n    // this.latitudeUnitsDom.textContent = distanceUnits;\\n  }\\n\\n  updatePlanTime(planTime) {\\n    if (!this.wheelDom) return;\\n\\n    //this.planTimeDom.textContent = planTime !== null ? (planTime * 1000).toLocaleString(undefined, { maximumFractionDigits: 0 }) : \\'\\';\\n  }\\n\\n  update(controls, speed, station, latitude, elapsedTime, planTime) {\\n    if (!this.wheelDom) return;\\n\\n    const wheelTurn = Math.clamp(this.car.wheelAngle / Car[\"a\" /* default */].MAX_WHEEL_ANGLE * 0.95, -1, +1);\\n\\n    this.wheelDom.style.transform = `rotate(${wheelTurn}turn)`;\\n\\n    if (wheelTurn >= 0) {\\n      this.wheelPieRightDom.style.transform = `rotate(${wheelTurn}turn)`;\\n\\n      if (wheelTurn <= 0.5) {\\n        this.wheelPieDom.style.clipPath = \"inset(0 0 0 50%)\";\\n        this.wheelPieLeftDom.style.transform = \"rotate(0)\";\\n      } else {\\n        this.wheelPieDom.style.clipPath = \"inset(0 0 0 0)\";\\n        this.wheelPieLeftDom.style.transform = \"rotate(0.5turn)\";\\n      }\\n    } else {\\n      this.wheelPieRightDom.style.transform = `rotate(${0.5 + wheelTurn}turn)`;\\n\\n      if (wheelTurn >= -0.5) {\\n        this.wheelPieDom.style.clipPath = \"inset(0 50% 0 0)\";\\n        this.wheelPieLeftDom.style.transform = \"rotate(0.5turn)\";\\n      } else {\\n        this.wheelPieDom.style.clipPath = \"inset(0 0 0 0)\";\\n        this.wheelPieLeftDom.style.transform = \"rotate(0)\";\\n      }\\n    }\\n\\n    this.gearDom.innerText = controls.gas < 0 ? \\'R\\' : \\'D\\';\\n    this.brakeDom.style.clipPath = `inset(50% 50% 0 ${50 - controls.brake * 25}%)`;\\n    this.gasDom.style.clipPath = `inset(50% ${50 - Math.abs(controls.gas) * 25}% 0 50%)`;\\n\\n    if (this.units == \\'imperial\\') {\\n      speed *= MPS_TO_MPH;\\n      station = station !== null ? station * METERS_TO_FEET : null;\\n      latitude = latitude !== null ? latitude * METERS_TO_FEET : null;\\n    }\\n\\n    let latitudeText = latitude !== null ? latitude.toFixed(2) : \\'\\';\\n    if (latitudeText == \\'-0.00\\') latitudeText = \\'0.00\\';\\n\\n    this.speedDom.textContent = speed.toFixed(1);\\n    this.stationDom.textContent = station !== null ? station.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) : \\'\\';\\n    this.latitudeDom.textContent = latitudeText;\\n    this.updatePlanTime(planTime);\\n\\n    let mins = Math.floor(elapsedTime / 60);\\n    let seconds = elapsedTime % 60;\\n\\n    if (mins == 0) {\\n      this.elapsedTimeDom.textContent = seconds.toFixed(1);\\n    } else {\\n      if (seconds < 10)\\n        seconds = \\'0\\' + seconds.toFixed(1);\\n      else\\n        seconds = seconds.toFixed(1);\\n\\n      this.elapsedTimeDom.textContent = `${mins}:${seconds}`;\\n    }\\n  }\\n}\\n\\n// EXTERNAL MODULE: ./js/GPGPU.js\\nvar GPGPU = __webpack_require__(4);\\n\\n// CONCATENATED MODULE: ./js/autonomy/path-planning/RoadLattice.js\\nclass RoadLattice {\\n  constructor(lanePath, latticeStartStation, config) {\\n    const stationInterval = config.spatialHorizon / config.lattice.numStations;\\n    const centerline = lanePath.sampleStations(latticeStartStation, config.lattice.numStations, stationInterval);\\n    const lattice = new Array(centerline.length);\\n    const offset = Math.floor(config.lattice.numLatitudes / 2);\\n\\n    for (let s = 0; s < centerline.length; s++) {\\n      const sample = centerline[s];\\n      const latitudes = lattice[s] = new Array(config.lattice.numLatitudes);\\n\\n      for (let l = 0; l < config.lattice.numLatitudes; l++) {\\n        const latitude = (l - offset) / offset * config.roadWidth / 2;\\n        const rot = sample.rot;\\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos);\\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\\n\\n        latitudes[l] = { pos, rot, curv };\\n      }\\n    }\\n\\n    this.lattice = lattice;\\n  }\\n}\\n\\n// EXTERNAL MODULE: ./js/autonomy/path-planning/PathPlanner.js + 12 modules\\nvar PathPlanner = __webpack_require__(6);\\n\\n// CONCATENATED MODULE: ./js/autonomy/MovingAverage.js\\nclass MovingAverage {\\n  constructor(maxSamples) {\\n    this.samples = new Array(maxSamples);\\n    this.numSamples = 0;\\n    this.nextIndex = 0;\\n    this.average = null;\\n  }\\n\\n  addSample(sample) {\\n    this.samples[this.nextIndex++] = sample;\\n    this.nextIndex = this.nextIndex % this.samples.length;\\n    this.numSamples = Math.min(this.numSamples + 1, this.samples.length);\\n\\n    const k = 2 / (this.numSamples + 1);\\n    let curr = this.nextIndex % this.numSamples;\\n    let newAverage = this.samples[curr];\\n\\n    for (let i = 1; i < this.numSamples; i++) {\\n      curr = (curr + 1) % this.numSamples;\\n      newAverage = this.samples[curr] * k + newAverage * (1 - k);\\n    }\\n\\n    this.average = newAverage;\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/Simulator.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst WELCOME_MODAL_KEY = \\'dash_WelcomeModal\\';\\n\\nclass Simulator_Simulator {\\n  constructor(domElement) {\\n    this.pathPlannerWorker = new Worker(URL.createObjectURL(new Blob([`(${dash_initPathPlannerWorker.toString()})()`], { type: \\'text/javascript\\' })));\\n    this.pathPlannerWorker.onmessage = this.receivePlannedPath.bind(this);\\n    this.pathPlannerConfigEditor = new PathPlannerConfigEditor();\\n\\n    this.physics = new Physics_Physics();\\n    this.car = this.physics.createCar();\\n\\n    this.renderer = new THREE.WebGLRenderer({ antialias: true });\\n    this.renderer.setPixelRatio(window.devicePixelRatio);\\n    this.renderer.setSize(domElement.clientWidth, domElement.clientHeight);\\n    this.renderer.shadowMap.enabled = true;\\n    domElement.appendChild(this.renderer.domElement);\\n\\n    this.lastPlanParams = null;\\n    this.renderer.context.canvas.addEventListener(\\'webglcontextlost\\', event => {\\n      console.log(\\'Simulator: webgl context lost\\');\\n      console.log(event);\\n      console.log(this.lastPlanParams);\\n    });\\n\\n    this._setUpCameras(this.renderer.domElement);\\n\\n    this.scene = new THREE.Scene();\\n    this.sceneFog = null;//new THREE.FogExp2(0x111111, 0.0025);\\n    this.scene.fog = this.sceneFog;\\n    this.scene.background = new THREE.Color(0x111111); //0x111111\\n\\n    this.editor = new Editor_Editor(this.renderer.domElement, this.editorCamera, this.scene);\\n\\n    const geolocation = null;//[33.523900, -111.908756];\\n    const map = new MapObject(geolocation);\\n    this.scene.add(map);\\n\\n    this.carObject = new CarObject_CarObject(this.car);\\n    this.scene.add(this.carObject);\\n\\n    this.scene.add(new THREE.AmbientLight(0x666666));\\n    const light = new THREE.DirectionalLight(0xffffff, 0.75);\\n    light.position.set(1, 1, 1).normalize();\\n    this.scene.add(light);\\n\\n    this.manualCarController = new ManualController();\\n    this.autonomousCarController = null;\\n\\n    this.dashboard = new Dashboard_Dashboard(this.car);\\n\\n    this.plannerReady = false;\\n    this.plannerRunning = false;\\n    this.plannerReset = false;\\n    this.carStation = null;\\n    this.plannedPathGroup = new THREE.Group();\\n    this.scene.add(this.plannedPathGroup);\\n\\n    this.staticObstaclesGroup = new THREE.Group();\\n    this.scene.add(this.staticObstaclesGroup);\\n    this.dynamicObstaclesGroup = new THREE.Group();\\n    this.scene.add(this.dynamicObstaclesGroup);\\n\\n    this.paused = false;\\n    this.prevTimestamp = null;\\n    this.frameCounter = 0;\\n    this.fpsTime = 0;\\n    this.fps = 0;\\n    this.simulatedTime = 0;\\n    this.lastPlanTime = null;\\n    this.averagePlanTime = new MovingAverage(20);\\n\\n    window.addEventListener(\\'resize\\', e => {\\n      this._updateCameraAspects(domElement.clientWidth / domElement.clientHeight);\\n      this.renderer.setSize(domElement.clientWidth, domElement.clientHeight);\\n    });\\n\\n    window.addEventListener(\\'hashchange\\', e => {\\n      if (window.location.hash.startsWith(\\'#/s/\\'))\\n        window.location.reload();\\n    });\\n\\n    this.manualModeButton = document.getElementById(\\'mode-manual\\');\\n    this.manualModeButton.addEventListener(\\'click\\', this.enableManualMode.bind(this));\\n    this.autonomousModeButton = document.getElementById(\\'mode-autonomous\\');\\n    this.autonomousModeButton.addEventListener(\\'click\\', this.enableAutonomousMode.bind(this));\\n\\n    document.getElementById(\\'editor-enable\\').addEventListener(\\'click\\', this.enableEditor.bind(this));\\n    document.getElementById(\\'editor-finalize\\').addEventListener(\\'click\\', this.finalizeEditor.bind(this));\\n    document.getElementById(\\'simulator-load\\').addEventListener(\\'click\\', this.loadScenario.bind(this));\\n\\n    this.scenarioPlayButton = document.getElementById(\\'scenario-play\\');\\n    this.scenarioPlayButton.addEventListener(\\'click\\', this.playScenario.bind(this));\\n    this.scenarioPauseButton = document.getElementById(\\'scenario-pause\\');\\n    this.scenarioPauseButton.addEventListener(\\'click\\', this.pauseScenario.bind(this));\\n    this.scenarioRestartButton = document.getElementById(\\'scenario-restart\\');\\n    this.scenarioRestartButton.addEventListener(\\'click\\', this.restartScenario.bind(this));\\n\\n    this.welcomeModal = document.getElementById(\\'welcome-modal\\');\\n    document.getElementById(\\'show-welcome-modal\\').addEventListener(\\'click\\', e => this.welcomeModal.classList.add(\\'is-active\\'));\\n\\n    if (window.localStorage.getItem(WELCOME_MODAL_KEY) !== \\'hide\\') {\\n      this.welcomeModal.classList.add(\\'is-active\\');\\n    }\\n\\n    document.getElementById(\\'welcome-modal-background\\').addEventListener(\\'click\\', this.hideWelcomeModal.bind(this));\\n    document.getElementById(\\'welcome-modal-close\\').addEventListener(\\'click\\', this.hideWelcomeModal.bind(this));\\n\\n    document.getElementById(\\'welcome-modal-examples\\').addEventListener(\\'click\\', e => {\\n      this.welcomeModal.classList.remove(\\'is-active\\');\\n      this.loadScenario();\\n      this.editor.scenarioManager.switchTab(this.editor.scenarioManager.examplesTab);\\n    });\\n\\n    document.getElementById(\\'welcome-modal-create\\').addEventListener(\\'click\\', e => {\\n      this.welcomeModal.classList.remove(\\'is-active\\');\\n      this.enableEditor();\\n    });\\n\\n    this.simModeBoxes = Array.prototype.slice.call(document.getElementsByClassName(\\'sim-mode-box\\'), 0);\\n    this.editModeBoxes = Array.prototype.slice.call(document.getElementsByClassName(\\'edit-mode-box\\'), 0);\\n\\n    this.fpsBox = document.getElementById(\\'fps\\');\\n\\n    this.enableManualMode();\\n    this.changeCamera(\\'chase\\');\\n\\n    this.aroundAnchorIndex = null;\\n    this.staticObstacles = [];\\n    this.dynamicObstacles = [];\\n\\n    this._checkHashScenario();\\n\\n    requestAnimationFrame(this.step.bind(this));\\n  }\\n\\n  toss() {\\n    const pose = this.car.pose;\\n    const rotVec = THREE.Vector2.fromAngle(pose.rot);\\n    const pos = rotVec.clone().multiplyScalar(50).add(new THREE.Vector2(rotVec.y, rotVec.x)).add(pose.pos);\\n    const obstacle = new StaticObstacle[\"a\" /* default */](pos, 0, 1.0, 1.0);\\n\\n    const obsGeom = new THREE.PlaneGeometry(obstacle.width, obstacle.height);\\n    const obsMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, depthTest: false, transparent: true, opacity: 0.5 });\\n    const obsObj = new THREE.Mesh(obsGeom, obsMat);\\n    obsObj.rotation.x = -Math.PI / 2;\\n    obsObj.rotation.z = -obstacle.rot;\\n    obsObj.position.set(obstacle.pos.x, 0, obstacle.pos.y);\\n    this.scene.add(obsObj);\\n\\n    this.staticObstacles.push(obstacle);\\n  }\\n\\n  _checkHashScenario() {\\n    if (!window.location.hash.startsWith(\\'#/s/\\')) return;\\n\\n    const [_hash, _s, code] = window.location.hash.split(\\'/\\');\\n\\n    try {\\n      const json = JSON.parse(atob(decodeURIComponent(code)));\\n      this.editor.loadJSON(json);\\n      this.finalizeEditor();\\n      this.welcomeModal.classList.remove(\\'is-active\\');\\n      window.location.hash = \\'\\';\\n    } catch (e) {\\n      console.log(\\'Error importing scenario code:\\');\\n      console.log(code);\\n      console.log(e);\\n    }\\n  }\\n\\n  _setUpCameras(domElement) {\\n    this.chaseCamera = new THREE.PerspectiveCamera(55, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.chaseCameraControls = new simulator_OrbitControls(this.chaseCamera, domElement);\\n    this.chaseCameraControls.minDistance = 4;\\n    this.chaseCameraControls.maxDistance = 5000;\\n    this.chaseCameraControls.maxPolarAngle = Math.PI / 2.02;\\n    this.chaseCameraControls.enablePan = false;\\n    this.chaseCameraControls.enabled = false;\\n    this._resetChaseCamera();\\n\\n    this.freeCamera = new THREE.PerspectiveCamera(55, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.freeCameraControls = new simulator_OrbitControls(this.freeCamera, domElement);\\n    this.freeCameraControls.minDistance = 5;\\n    this.freeCameraControls.maxDistance = 5000;\\n    this.freeCameraControls.maxPolarAngle = Math.PI / 2.02;\\n    this.freeCameraControls.enabled = true;\\n    this._resetFreeCamera();\\n\\n    this.topDownCamera = new THREE.PerspectiveCamera(55, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.topDownCamera.position.set(0, 50, 0);\\n    this.topDownCamera.lookAt(0, 0, 0);\\n    this.topDownControls = new TopDownCameraControls(domElement, this.topDownCamera);\\n    this.topDownControls.enabled = false;\\n    this.topDownControls.minAltitude = 5;\\n    this.topDownControls.maxAltitude = 10000;\\n\\n    this.editorCamera = new THREE.PerspectiveCamera(45, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.editorCamera.layers.enable(2);\\n    this.editorCamera.position.set(0, 200, 0);\\n    this.editorCamera.lookAt(0, 0, 0);\\n    this.editorCameraControls = new TopDownCameraControls(domElement, this.editorCamera);\\n    this.editorCameraControls.enabled = false;\\n    this.editorCameraControls.enablePanning = true;\\n    this.editorCameraControls.minAltitude = 10;\\n    this.editorCameraControls.maxAltitude = 10000;\\n\\n    this.cameraButtons = {};\\n\\n    [\\'free\\', \\'chase\\', \\'topDown\\'].forEach(c => {\\n      const cameraButton = document.getElementById(`camera-${c}`);\\n      cameraButton.addEventListener(\\'click\\', () => this.changeCamera(c));\\n      this.cameraButtons[c] = cameraButton;\\n    });\\n\\n    this.switchTo2DButton = document.getElementById(\\'camera-2D\\');\\n    this.switchTo2DButton.addEventListener(\\'click\\', this.switchTo2D.bind(this));\\n    this.switchTo3DButton = document.getElementById(\\'camera-3D\\');\\n    this.switchTo3DButton.addEventListener(\\'click\\', this.switchTo3D.bind(this));\\n\\n    this.switchTo3D();\\n  }\\n\\n  _resetFreeCamera() {\\n    this.freeCameraControls.position0.copy(this.chaseCamera.position);\\n    const carPosition = this.car.position;\\n    this.freeCameraControls.target0.set(carPosition.x, 0, carPosition.y);\\n    this.freeCameraControls.reset();\\n  }\\n\\n  _resetChaseCamera() {\\n    const pos = this.car.position;\\n    const dirVector = THREE.Vector2.fromAngle(this.car.rotation).multiplyScalar(-20);\\n    this.chaseCamera.position.set(pos.x + dirVector.x, 8, pos.y + dirVector.y);\\n    this.chaseCamera.lookAt(pos.x, 0, pos.y);\\n  }\\n\\n  _resetTopDownCamera() {\\n    const carPosition = this.car.position;\\n    this.topDownCamera.position.set(carPosition.x, 50, carPosition.y);\\n    this.topDownCamera.rotation.z = -this.car.rotation - Math.PI / 2\\n  }\\n\\n  _updateCameraAspects(aspect) {\\n    this.freeCamera.aspect = aspect;\\n    this.freeCamera.updateProjectionMatrix();\\n    this.chaseCamera.aspect = aspect;\\n    this.chaseCamera.updateProjectionMatrix();\\n    this.topDownCamera.aspect = aspect;\\n    this.topDownCamera.updateProjectionMatrix();\\n    this.editorCamera.aspect = aspect;\\n    this.editorCamera.updateProjectionMatrix();\\n  }\\n\\n  enableEditor() {\\n    this.editor.enabled = true;\\n    this.plannerRunning = false;\\n\\n    this.previousCamera = this.camera;\\n    this.camera = this.editorCamera;\\n    this.editorCameraControls.enabled = true;\\n    this.chaseCameraControls.enabled = false;\\n    this.topDownControls.enabled = false;\\n    this.freeCameraControls.enabled = false;\\n\\n    this.scene.fog = null;\\n    this.carObject.visible = false;\\n    if (this.plannedPathGroup) this.plannedPathGroup.visible = false;\\n    this.staticObstaclesGroup.visible = false;\\n    this.dynamicObstaclesGroup.visible = false;\\n\\n    this.simModeBoxes.forEach(el => el.classList.add(\\'is-hidden\\'));\\n    this.editModeBoxes.forEach(el => el.classList.remove(\\'is-hidden\\'));\\n  }\\n\\n  finalizeEditor(replaceCamera = true) {\\n    this.editor.enabled = false;\\n    this.editorCameraControls.enabled = false;\\n\\n    this.scene.fog = this.sceneFog;\\n    this.carObject.visible = true;\\n\\n    this.simModeBoxes.forEach(el => el.classList.remove(\\'is-hidden\\'));\\n    this.editModeBoxes.forEach(el => el.classList.add(\\'is-hidden\\'));\\n\\n    if (this.editor.lanePath.anchors.length > 1) {\\n      const centerline = this.editor.lanePath.centerline;\\n      const pos = centerline[0].clone();\\n      const dir = centerline[1].clone().sub(centerline[0]);\\n      const rot = Math.atan2(dir.y, dir.x);\\n      const perpindicular = rot + Math.PI / 2 * (Math.sign(this.editor.lanePreference) || 0);\\n      const latitude = this.pathPlannerConfigEditor.config.roadWidth / 4;\\n\\n      this.car.setPose(pos.x + Math.cos(perpindicular) * latitude, pos.y + Math.sin(perpindicular) * latitude, rot);\\n      this.car.velocity = this.editor.initialSpeed;\\n\\n      this.dynamicObstacles = this.editor.dynamicObstacles;\\n\\n      // The `false` value means the controller is waiting to be created after the first planning cycle.\\n      // This signals the simulator to use neutral controls instead of the hard brake used for the `null` value.\\n      this.autonomousCarController = false;\\n      this.enableAutonomousMode();\\n\\n      if (!this.plannerRunning) {\\n        this.plannerReady = true;\\n        this.plannerRunning = true;\\n      }\\n      this.plannerReset = true;\\n      this.simulatedTime = 0;\\n      this.carStation = 0;\\n      this.aroundAnchorIndex = null;\\n\\n      this.pauseScenario();\\n      this.autonomousModeButton.classList.add(\\'is-loading\\');\\n      this.waitingForFirstPlan = true;\\n    } else {\\n      this.dynamicObstacles = [];\\n    }\\n\\n    this.staticObstacles = this.editor.staticObstacles;\\n    this.recreateStaticObstacleObjects();\\n    this.recreateDynamicObstacleObjects();\\n\\n    //this.dashboard.update({ steer: 0, brake: 0, gas: 0 }, this.car.velocity, null, null, 0, this.averagePlanTime.average);\\n\\n    if (replaceCamera) {\\n      this.camera = this.previousCamera;\\n\\n      if (this.previousCamera == this.chaseCamera)\\n        this.chaseCameraControls.enabled = true;\\n      else if (this.previousCamera == this.topDownCamera)\\n        this.topDownControls.enabled = true;\\n      else if (this.previousCamera == this.freeCamera)\\n        this.freeCameraControls.enabled = true;\\n      else\\n        this.changeCamera(\\'chase\\');\\n    }\\n\\n    this._resetFreeCamera();\\n    this._resetChaseCamera();\\n    this._resetTopDownCamera();\\n  }\\n\\n  recreateStaticObstacleObjects() {\\n    this.scene.remove(this.staticObstaclesGroup);\\n    this.staticObstaclesGroup = new THREE.Group();\\n    this.scene.add(this.staticObstaclesGroup);\\n\\n    this.staticObstacles.forEach(o => {\\n      const obstacleObject = new StaticObstacleObject(o);\\n      this.staticObstaclesGroup.add(obstacleObject);\\n    });\\n  }\\n\\n  recreateDynamicObstacleObjects() {\\n    this.scene.remove(this.dynamicObstaclesGroup);\\n    this.dynamicObstaclesGroup = new THREE.Group();\\n    this.scene.add(this.dynamicObstaclesGroup);\\n\\n    this.dynamicObstacles.forEach(o => {\\n      const obstacleObject = new DynamicObstacleObject(o, this.editor.lanePath);\\n      this.dynamicObstaclesGroup.add(obstacleObject);\\n    });\\n\\n    this.updateDynamicObjects(this.simulatedTime);\\n  }\\n\\n  updateDynamicObjects(time) {\\n    //this.dynamicObstaclesGroup.children.forEach(o => o.update(time));\\n  }\\n\\n  playScenario() {\\n    this.paused = false;\\n    this.scenarioPlayButton.classList.add(\\'is-hidden\\');\\n    this.scenarioPauseButton.classList.remove(\\'is-hidden\\');\\n  }\\n\\n  pauseScenario() {\\n    this.paused = true;\\n    this.scenarioPlayButton.classList.remove(\\'is-hidden\\');\\n    this.scenarioPauseButton.classList.add(\\'is-hidden\\');\\n  }\\n\\n  restartScenario() {\\n    if (this.editor.enabled) return;\\n\\n    if (this.plannedPathGroup)\\n      this.scene.remove(this.plannedPathGroup);\\n\\n    this.finalizeEditor(false);\\n  }\\n\\n  loadScenario() {\\n    if (this.editor.enabled) return;\\n\\n    this.editor.scenarioManager.showModal(this.finalizeEditor.bind(this));\\n  }\\n\\n  enableManualMode() {\\n    this.manualModeButton.classList.remove(\\'is-outlined\\');\\n    this.manualModeButton.classList.add(\\'is-selected\\');\\n    this.autonomousModeButton.classList.add(\\'is-outlined\\', \\'is-inverted\\');\\n    this.autonomousModeButton.classList.remove(\\'is-selected\\', \\'is-link\\');\\n\\n    this.carControllerMode = \\'manual\\';\\n  }\\n\\n  enableAutonomousMode() {\\n    this.autonomousModeButton.classList.remove(\\'is-outlined\\', \\'is-inverted\\');\\n    this.autonomousModeButton.classList.add(\\'is-selected\\', \\'is-link\\');\\n    this.manualModeButton.classList.add(\\'is-outlined\\');\\n    this.manualModeButton.classList.remove(\\'is-selected\\');\\n\\n    this.carControllerMode = \\'autonomous\\';\\n  }\\n\\n  changeCamera(mode) {\\n    if (this.editor.enabled) return;\\n\\n    switch (mode) {\\n      case \"free\":\\n        this.chaseCameraControls.enabled = false;\\n        this.topDownControls.enabled = false;\\n        this.freeCameraControls.enabled = true;\\n\\n        if (this.camera == this.freeCamera)\\n          this._resetFreeCamera();\\n        else\\n          this.camera = this.freeCamera;\\n\\n        break;\\n      case \"chase\":\\n        this.freeCameraControls.enabled = false;\\n        this.topDownControls.enabled = false;\\n        this.chaseCameraControls.enabled = true;\\n\\n        if (this.camera == this.chaseCamera)\\n          this._resetChaseCamera();\\n        else\\n          this.camera = this.chaseCamera;\\n\\n        break;\\n      case \"topDown\":\\n        this.freeCameraControls.enabled = false;\\n        this.chaseCameraControls.enabled = false;\\n        this.topDownControls.enabled = true;\\n\\n        if (this.camera == this.topDownCamera)\\n          this._resetTopDownCamera();\\n        else\\n          this.camera = this.topDownCamera;\\n\\n        break;\\n      default:\\n        console.log(`Unknown camera mode: ${mode}`);\\n        return;\\n    }\\n\\n    for (const c in this.cameraButtons) {\\n      const classes = this.cameraButtons[c].classList;\\n      if (c == mode) {\\n        classes.remove(\\'is-outlined\\');\\n        classes.add(\\'is-selected\\');\\n      } else {\\n        classes.add(\\'is-outlined\\');\\n        classes.remove(\\'is-selected\\');\\n      }\\n    }\\n  }\\n\\n  switchTo2D() {\\n    this.switchTo2DButton.classList.remove(\\'is-outlined\\');\\n    this.switchTo2DButton.classList.add(\\'is-selected\\');\\n    this.switchTo3DButton.classList.add(\\'is-outlined\\');\\n    this.switchTo3DButton.classList.remove(\\'is-selected\\');\\n\\n    this.chaseCamera.layers.enable(2);\\n    this.topDownCamera.layers.enable(2);\\n    this.freeCamera.layers.enable(2);\\n    this.chaseCamera.layers.disable(3);\\n    this.topDownCamera.layers.disable(3);\\n    this.freeCamera.layers.disable(3);\\n  }\\n\\n  switchTo3D() {\\n    this.switchTo3DButton.classList.remove(\\'is-outlined\\');\\n    this.switchTo3DButton.classList.add(\\'is-selected\\');\\n    this.switchTo2DButton.classList.add(\\'is-outlined\\');\\n    this.switchTo2DButton.classList.remove(\\'is-selected\\');\\n\\n    this.chaseCamera.layers.enable(3);\\n    this.topDownCamera.layers.enable(3);\\n    this.freeCamera.layers.enable(3);\\n    this.chaseCamera.layers.disable(2);\\n    this.topDownCamera.layers.disable(2);\\n    this.freeCamera.layers.disable(2);\\n  }\\n\\n  hideWelcomeModal() {\\n    this.welcomeModal.classList.remove(\\'is-active\\');\\n    window.localStorage.setItem(WELCOME_MODAL_KEY, \\'hide\\');\\n  }\\n\\n  startPlanner(pose, station) {\\n    this.plannerReady = false;\\n    this.lastPlanTime = performance.now();\\n\\n    // In order to create a stable trajectory between successive planning\\n    // cycles, we must compensate for the latency between when a planning cycle\\n    // starts and when it ends. The average planning time is used to forward\\n    // simulate the vehicle to the pose it is expected to have when the\\n    // planning actually finishes.\\n\\n    let predictedPose = pose;\\n    let predictedStation = station;\\n    let startTime = this.simulatedTime;\\n\\n    if (!this.plannerReset && !this.paused && this.autonomousCarController && this.carControllerMode == \\'autonomous\\') {\\n      const latency = this.averagePlanTime.average;\\n      predictedPose = this.autonomousCarController.predictPoseAfterTime(pose, latency);\\n      let [predictedStation] = this.editor.lanePath.stationLatitudeFromPosition(predictedPose.pos, this.aroundAnchorIndex);\\n      startTime += latency;\\n    }\\n\\n    const reset = this.plannerReset;\\n    this.plannerReset = false;\\n\\n    this.lastPlanParams =  {\\n      config: Object.assign({}, this.pathPlannerConfigEditor.config, { speedLimit: this.editor.speedLimit, lanePreference: this.editor.lanePreference }),\\n      vehiclePose: predictedPose,\\n      vehicleStation: predictedStation,\\n      lanePath: this.editor.lanePath,\\n      startTime: startTime,\\n      staticObstacles: this.staticObstacles,\\n      dynamicObstacles: this.dynamicObstacles.filter(o => o.positionAtTime(startTime).x >= 0),\\n      reset: reset\\n    };\\n\\n    this.pathPlannerWorker.postMessage(this.lastPlanParams);\\n  }\\n\\n  receivePlannedPath(event) {\\n    if (event.data.error) {\\n      document.getElementById(\\'planner-error\\').classList.remove(\\'is-hidden\\');\\n      return;\\n    }\\n\\n    if (this.waitingForFirstPlan && !this.plannerReset) {\\n      this.waitingForFirstPlan = false;\\n      this.autonomousModeButton.classList.remove(\\'is-loading\\');\\n      this.playScenario();\\n    }\\n\\n    if (this.editor.enabled) return;\\n\\n    const { fromVehicleParams, vehiclePose, vehicleStation, latticeStartStation, config, dynamicObstacleGrid } = event.data;\\n    let { path, fromVehicleSegment } = event.data;\\n\\n    this.averagePlanTime.addSample((performance.now() - this.lastPlanTime) / 1000);\\n    this.plannerReady = true;\\n\\n    if (this.plannerReset) return;\\n\\n    if (this.plannedPathGroup)\\n      this.scene.remove(this.plannedPathGroup);\\n    this.plannedPathGroup = new THREE.Group();\\n    this.scene.add(this.plannedPathGroup);\\n\\n    const circleGeom = new THREE.CircleGeometry(0.1, 32);\\n    const circleMat = new THREE.MeshBasicMaterial({ color: 0x00ff80, transparent: true, opacity: 0.7 });\\n\\n    const lattice = new RoadLattice(this.editor.lanePath, latticeStartStation, config);\\n    lattice.lattice.forEach(cells => {\\n      cells.forEach(c => {\\n        const circle = new THREE.Mesh(circleGeom, circleMat);\\n        circle.position.set(c.pos.x, 0, c.pos.y);\\n        circle.rotation.x = -Math.PI / 2;\\n        this.plannedPathGroup.add(circle);\\n      });\\n    });\\n\\n    // TODO: clear this up or just remove it\\n    if (false) {}\\n\\n    if (path === null) {\\n      this.autonomousCarController = null;\\n      return;\\n    }\\n\\n    if (fromVehicleParams.type == \\'cubic\\') {\\n      const start = this.car.pose;\\n      const end = fromVehicleSegment[fromVehicleSegment.length - 1];\\n\\n      const pathBuilder = new CubicPath[\"a\" /* default */](start, end, fromVehicleParams.params);\\n\\n      if (pathBuilder.optimize()) {\\n        fromVehicleSegment = pathBuilder.buildPath(Math.ceil(pathBuilder.params.sG / 0.25));\\n\\n        const prevVelocitySq = this.car.velocity * this.car.velocity;\\n        const accel = (end.velocity * end.velocity - prevVelocitySq) / 2 / pathBuilder.params.sG;\\n        const ds = pathBuilder.params.sG / (fromVehicleSegment.length - 1);\\n        let s = 0;\\n\\n        for (let p = 0; p < fromVehicleSegment.length; p++) {\\n          fromVehicleSegment[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\\n          fromVehicleSegment[p].acceleration = accel;\\n          s += ds;\\n        }\\n      }\\n    }\\n\\n    path = fromVehicleSegment.concat(path);\\n\\n    path.forEach(p => Object.setPrototypeOf(p.pos, THREE.Vector2.prototype));\\n    const followPath = new Path_Path(path);\\n\\n    if (this.autonomousCarController)\\n      this.autonomousCarController.replacePath(followPath);\\n    else\\n      this.autonomousCarController = new FollowController_FollowController(followPath, this.car);\\n\\n    const pathGeometry = new THREE.Geometry();\\n    pathGeometry.setFromPoints(path.map(p => new THREE.Vector3(p.pos.x, 0, p.pos.y)));\\n    const pathLine = new MeshLine();\\n    pathLine.setGeometry(pathGeometry);\\n\\n    const color = fromVehicleParams.type == \\'cubic\\' ? new THREE.Color(0xff8800) : new THREE.Color(0xffff40);\\n    const pathObject = new THREE.Mesh(\\n      pathLine.geometry,\\n      new MeshLineMaterial({\\n        color: color,\\n        lineWidth: 0.15,\\n        resolution: new THREE.Vector2(this.renderer.domElement.clientWidth, this.renderer.domElement.clientHeight)\\n      })\\n    );\\n    pathObject.renderOrder = 1;\\n    this.plannedPathGroup.add(pathObject);\\n  }\\n\\n  step(timestamp) {\\n    if (this.prevTimestamp == null) {\\n      this.prevTimestamp = timestamp;\\n      requestAnimationFrame(this.step.bind(this));\\n      return;\\n    }\\n\\n    const dt = (timestamp - this.prevTimestamp) / 1000;\\n\\n    this.editor.update();\\n\\n    if (!this.editor.enabled && !this.paused) {\\n      this.simulatedTime += dt;\\n\\n      const prevCarPosition = this.car.position;\\n      const prevCarRotation = this.car.rotation;\\n\\n      const manualControls = this.manualCarController.control(this.car.pose, this.car.wheelAngle, this.car.velocity, dt);\\n      if (manualControls.steer != 0 || manualControls.brake != 0 || manualControls.gas != 0)\\n        this.enableManualMode();\\n\\n      let autonomousControls = { steer: 0, brake: 0, gas: 0};\\n      if (this.autonomousCarController)\\n        autonomousControls = this.autonomousCarController.control(this.car.pose, this.car.wheelAngle, this.car.velocity, dt, this.carControllerMode == \\'autonomous\\') ;\\n      else if (this.autonomousCarController === null)\\n        autonomousControls = { steer: 0, brake: 1, gas: 0 };\\n\\n      const controls = this.carControllerMode == \\'autonomous\\' ? autonomousControls : manualControls;\\n\\n      this.car.update(controls, dt);\\n      this.physics.step(dt);\\n\\n      this.updateDynamicObjects(this.simulatedTime);\\n\\n      const carPosition = this.car.position;\\n      const carRotation = this.car.rotation;\\n      const carRearAxle = this.car.rearAxlePosition;\\n      const carVelocity = this.car.velocity;\\n\\n      const positionOffset = { x: carPosition.x - prevCarPosition.x, y: 0, z: carPosition.y - prevCarPosition.y };\\n      this.chaseCamera.position.add(positionOffset);\\n      this.chaseCameraControls.target.set(carPosition.x, 0, carPosition.y);\\n      this.chaseCameraControls.rotateLeft(carRotation - prevCarRotation);\\n      this.chaseCameraControls.update();\\n\\n      this.topDownCamera.position.setX(carPosition.x);\\n      this.topDownCamera.position.setZ(carPosition.y);\\n      this.topDownCamera.rotation.z = -carRotation - Math.PI / 2\\n\\n      let latitude = null;\\n\\n      if (this.editor.lanePath.anchors.length > 1) {\\n        const [s, l, aroundAnchorIndex] = this.editor.lanePath.stationLatitudeFromPosition(carRearAxle, this.aroundAnchorIndex);\\n        this.aroundAnchorIndex = aroundAnchorIndex;\\n\\n        this.carStation = s;\\n        latitude = l;\\n      }\\n      //this.dashboard.update(controls, carVelocity, this.carStation, latitude, this.simulatedTime, this.averagePlanTime.average);\\n    }\\n\\n    if (!this.editor.enabled && this.plannerReady) {\\n      this.startPlanner(this.car.pose, this.carStation || 0);\\n      this.dashboard.updatePlanTime(this.averagePlanTime.average);\\n    }\\n\\n    this.frameCounter++;\\n    this.fpsTime += dt;\\n    if (this.fpsTime >= 1) {\\n      this.fps = this.frameCounter / this.fpsTime;\\n      this.frameCounter = 0;\\n      this.fpsTime = 0;\\n      this.fpsBox.textContent = this.fps.toFixed(1);\\n    }\\n\\n    this.renderer.render(this.scene, this.camera);\\n\\n    this.prevTimestamp = timestamp;\\n\\n    requestAnimationFrame(this.step.bind(this));\\n  }\\n}\\n\\n// CONCATENATED MODULE: ./js/Dash.js\\n\\n\\n\\ndocument.addEventListener(\\'DOMContentLoaded\\', e => {\\n  window.simulator = new Simulator_Simulator(document.getElementById(\\'container\\'));\\n});\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9waHlzaWNzL1BoeXNpY3MuanM/NGZlMSIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9QYXRoLmpzP2Q5ZjgiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvY29udHJvbC9BdXRvbm9tb3VzQ29udHJvbGxlci5qcz9lZTdjIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L2NvbnRyb2wvRm9sbG93Q29udHJvbGxlci5qcz85MTc5Iiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L2NvbnRyb2wvTWFudWFsQ29udHJvbGxlci5qcz8zNDUxIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvTWFwT2JqZWN0LmpzPzQzNGIiLCJ3ZWJwYWNrOi8vLy4vanMvb2JqZWN0cy9URFNMb2FkZXIuanM/OWU1NCIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL0Nhck9iamVjdC5qcz84NGNjIiwid2VicGFjazovLy8uL2pzL29iamVjdHMvU3RhdGljT2JzdGFjbGVPYmplY3QuanM/YTI0NyIsIndlYnBhY2s6Ly8vLi9qcy9vYmplY3RzL0R5bmFtaWNPYnN0YWNsZU9iamVjdC5qcz9lNTU1Iiwid2VicGFjazovLy8uL2pzL3NpbXVsYXRvci9QYXRoUGxhbm5lckNvbmZpZ0VkaXRvci5qcz85NDZmIiwid2VicGFjazovLy8uL2pzL3NpbXVsYXRvci9EeW5hbWljT2JzdGFjbGVFZGl0b3IuanM/MTlkZCIsIndlYnBhY2s6Ly8vLi9qcy9IZWxwZXJzLmpzPzkyOWIiLCJ3ZWJwYWNrOi8vLy4vanMvc2ltdWxhdG9yL2V4YW1wbGVzLmpzPzFkY2UiLCJ3ZWJwYWNrOi8vLy4vanMvc2ltdWxhdG9yL1NjZW5hcmlvTWFuYWdlci5qcz9iNGI3Iiwid2VicGFjazovLy8uL2pzL3NpbXVsYXRvci9TaGFyZU1hbmFnZXIuanM/NjA4ZiIsIndlYnBhY2s6Ly8vLi9qcy9zaW11bGF0b3IvRWRpdG9yLmpzP2E3ZDAiLCJ3ZWJwYWNrOi8vLy4vanMvc2ltdWxhdG9yL09yYml0Q29udHJvbHMuanM/ZTE3NyIsIndlYnBhY2s6Ly8vLi9qcy9zaW11bGF0b3IvVG9wRG93bkNhbWVyYUNvbnRyb2xzLmpzP2NmZjciLCJ3ZWJwYWNrOi8vLy4vanMvc2ltdWxhdG9yL0Rhc2hib2FyZC5qcz85NjMzIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvUm9hZExhdHRpY2UuanM/ODFhOCIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9Nb3ZpbmdBdmVyYWdlLmpzP2ZiY2MiLCJ3ZWJwYWNrOi8vLy4vanMvU2ltdWxhdG9yLmpzPzFkNzEiLCJ3ZWJwYWNrOi8vLy4vanMvRGFzaC5qcz81MTk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkI7O0FBRVosTUFBTSxlQUFPO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0JBQUc7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOzs7QUNqQm1DOztBQUVuQyxnQkFBZ0I7QUFDaEIsVUFBVTtBQUNLLE1BQU0sU0FBSTtBQUN6QjtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFHO0FBQ3pCLHFCQUFxQixzQkFBRztBQUN4QjtBQUNBO0FBQ0E7Ozs7OztBQy9Cc0M7O0FBRXZCLE1BQU0seUNBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixzQkFBRztBQUM1QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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bkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHdCQUF3Qjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFD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O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkJBQVE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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OztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7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QUFDQTs7O0FDdHZCdUM7QUFDbUI7O0FBRTFEO0FBQ0EseUJBQXlCLG1CQUFTO0FBQ2xDLENBQUMiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FyIGZyb20gXCIuL0Nhci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaHlzaWNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYXJzID0gW107XG4gIH1cblxuICBzdGVwKGR0KSB7XG4gICAgdGhpcy5jYXJzLmZvckVhY2goYyA9PiBjLnN0ZXAoZHQpKTtcbiAgfVxuXG4gIGNyZWF0ZUNhcigpIHtcbiAgICBjb25zdCBuZXdDYXIgPSBuZXcgQ2FyKCk7XG4gICAgdGhpcy5jYXJzLnB1c2gobmV3Q2FyKTtcblxuICAgIHJldHVybiBuZXdDYXI7XG4gIH1cbn07XG4iLCJpbXBvcnQgQ2FyIGZyb20gXCIuLi9waHlzaWNzL0Nhci5qc1wiXG5cbi8vIGlucHV0IHBvc2U6IHsgcG9zOiBWZWN0b3IyIFssIHJvdDogcmFkaWFuc10gfVxuLy8gcG9zZTogeyBwb3M6IFZlY3RvcjIsIGZyb250UG9zOiBWZWN0b3IyLCBmYWtlUG9zOiBWZWN0b3IyLCByb3Q6IHJhZGlhbnMgfVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBvc2VzLCBzdGFydFJvdGF0aW9uID0gMCwgZ29hbFJvdGF0aW9uID0gMCkge1xuICAgIHRoaXMucG9zZXMgPSBwb3NlcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc2UgPSBwb3Nlc1tpXTtcblxuICAgICAgaWYgKHBvc2Uucm90ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJvdDtcblxuICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgcm90ID0gc3RhcnRSb3RhdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChpID09IHBvc2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByb3QgPSBnb2FsUm90YXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHBvc2VzW2kgLSAxXS5wb3M7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHBvc2VzW2kgKyAxXS5wb3M7XG4gICAgICAgICAgcm90ID0gTWF0aC5hdGFuMihuZXh0LnkgLSBwcmV2LnksIG5leHQueCAtIHByZXYueCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NlLnJvdCA9IHJvdDtcbiAgICAgIH1cblxuICAgICAgcG9zZS5mcm9udFBvcyA9IENhci5nZXRGcm9udEF4bGVQb3NpdGlvbihwb3NlLnBvcywgcG9zZS5yb3QpO1xuICAgICAgcG9zZS5mYWtlUG9zID0gQ2FyLmdldEZha2VBeGxlUG9zaXRpb24ocG9zZS5wb3MsIHBvc2Uucm90KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBDYXIgZnJvbSBcIi4uLy4uL3BoeXNpY3MvQ2FyLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b25vbW91c0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm5leHRJbmRleCA9IDE7XG4gICAgdGhpcy5wcmV2UGhpRXJyb3IgPSAwO1xuICAgIHRoaXMucHJldlZlbG9jaXR5ID0gMDtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucHJldlZlbG9jaXR5ID0gMDtcbiAgfVxuXG4gIHJlcGxhY2VQYXRoKHBhdGgpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubmV4dEluZGV4ID0gMTtcbiAgfVxuXG4gIHByZWRpY3RQb3NlQWZ0ZXJUaW1lKGN1cnJlbnRQb3NlLCBwcmVkaWN0aW9uVGltZSkge1xuICAgIGNvbnN0IHBhdGhQb3NlcyA9IHRoaXMucGF0aC5wb3NlcztcbiAgICBjb25zdCBmcm9udEF4bGVQb3MgPSBDYXIuZ2V0RnJvbnRBeGxlUG9zaXRpb24oY3VycmVudFBvc2UucG9zLCBjdXJyZW50UG9zZS5yb3QpO1xuICAgIGxldCBbbmV4dEluZGV4LCBwcm9ncmVzc10gPSB0aGlzLmZpbmROZXh0SW5kZXgoZnJvbnRBeGxlUG9zKTtcbiAgICBsZXQgY3VycmVudFZlbG9jaXR5ID0gY3VycmVudFBvc2UudmVsb2NpdHk7XG5cbiAgICBpZiAoY3VycmVudFZlbG9jaXR5IDw9IDAuMDEpIHJldHVybiBjdXJyZW50UG9zZTtcblxuICAgIHdoaWxlIChwcmVkaWN0aW9uVGltZSA+IDApIHtcbiAgICAgIGNvbnN0IHByZXZQb3NlID0gcGF0aFBvc2VzW25leHRJbmRleCAtIDFdO1xuICAgICAgY29uc3QgbmV4dFBvc2UgPSBwYXRoUG9zZXNbbmV4dEluZGV4XTtcblxuICAgICAgY29uc3Qgc2VnbWVudERpc3QgPSBuZXh0UG9zZS5wb3MuZGlzdGFuY2VUbyhwcmV2UG9zZS5wb3MpO1xuICAgICAgY29uc3QgZGlzdExlZnQgPSBzZWdtZW50RGlzdCAqICgxIC0gcHJvZ3Jlc3MpO1xuICAgICAgY29uc3Qgc3VtViA9IGN1cnJlbnRWZWxvY2l0eSArIG5leHRQb3NlLnZlbG9jaXR5O1xuICAgICAgY29uc3QgdGltZVRvTmV4dEluZGV4ID0gMiAqIGRpc3RMZWZ0IC8gKHN1bVYgPT0gMCA/IDAuMDEgOiBzdW1WKTtcbiAgICAgIC8vY29uc3QgdGltZVRvTmV4dEluZGV4ID0gZGlzdExlZnQgLyBjdXJyZW50VmVsb2NpdHk7XG5cbiAgICAgIGlmICh0aW1lVG9OZXh0SW5kZXggPj0gcHJlZGljdGlvblRpbWUgfHwgbmV4dEluZGV4ICsgMSA+PSBwYXRoUG9zZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBzdW1WIC8gMiAqIHByZWRpY3Rpb25UaW1lO1xuICAgICAgICBjb25zdCBuZXdQcm9ncmVzcyA9IHByb2dyZXNzICsgZGlzdCAvIHNlZ21lbnREaXN0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zOiBuZXh0UG9zZS5wb3MuY2xvbmUoKS5zdWIocHJldlBvc2UucG9zKS5tdWx0aXBseVNjYWxhcihuZXdQcm9ncmVzcykuYWRkKG5leHRQb3NlLnBvcyksXG4gICAgICAgICAgcm90OiBwcmV2UG9zZS5yb3QgKyAobmV4dFBvc2Uucm90IC0gcHJldlBvc2Uucm90KSAqIG5ld1Byb2dyZXNzLFxuICAgICAgICAgIGN1cnY6IHByZXZQb3NlLmN1cnYgKyAobmV4dFBvc2UuY3VydiAtIHByZXZQb3NlLmN1cnYpICogbmV3UHJvZ3Jlc3MsXG4gICAgICAgICAgZEN1cnY6IDAsXG4gICAgICAgICAgZGRDdXJ2OiAwLFxuICAgICAgICAgIHZlbG9jaXR5OiBuZXh0UG9zZS52ZWxvY2l0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vY3VycmVudFZlbG9jaXR5ID0gbmV4dFBvc2UudmVsb2NpdHk7XG4gICAgICBwcmVkaWN0aW9uVGltZSAtPSB0aW1lVG9OZXh0SW5kZXg7XG4gICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBjb250cm9sKHBvc2UsIHdoZWVsQW5nbGUsIHZlbG9jaXR5LCBkdCkge1xuICAgIGNvbnN0IHBhdGhQb3NlcyA9IHRoaXMucGF0aC5wb3NlcztcbiAgICBjb25zdCBmcm9udEF4bGVQb3MgPSBDYXIuZ2V0RnJvbnRBeGxlUG9zaXRpb24ocG9zZS5wb3MsIHBvc2Uucm90KTtcbiAgICBjb25zdCBbbmV4dEluZGV4LCBwcm9ncmVzc10gPSB0aGlzLmZpbmROZXh0SW5kZXgoZnJvbnRBeGxlUG9zKTtcbiAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcblxuICAgIGxldCBnYXMgPSAwO1xuICAgIGxldCBicmFrZSA9IDA7XG4gICAgbGV0IHBoaSA9IDA7IC8vIHRoZSBkZXNpcmVkIHdoZWVsIGRlZmxlY3Rpb25cblxuICAgIGlmIChuZXh0SW5kZXggPj0gcGF0aFBvc2VzLmxlbmd0aCAtIDEgJiYgcHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgZ2FzID0gMDtcbiAgICAgIGJyYWtlID0gMTtcbiAgICAgIHBoaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtwX2EgPSA0O1xuICAgICAgY29uc3Qga2RfYSA9IDAuNTtcbiAgICAgIGNvbnN0IGtmZl9hID0gMC41O1xuXG4gICAgICBjb25zdCBjdXJyZW50QWNjZWwgPSAodmVsb2NpdHkgLSB0aGlzLnByZXZWZWxvY2l0eSkgLyBkdDtcbiAgICAgIGNvbnN0IHByZXZOZXh0RGlzdCA9IHBhdGhQb3Nlc1t0aGlzLm5leHRJbmRleF0ucG9zLmRpc3RhbmNlVG8ocGF0aFBvc2VzW3RoaXMubmV4dEluZGV4IC0gMV0ucG9zKTtcbiAgICAgIGNvbnN0IHRhcmdldFZlbG9jaXR5ID0gTWF0aC5zcXJ0KDIgKiBwYXRoUG9zZXNbbmV4dEluZGV4XS5hY2NlbGVyYXRpb24gKiBwcmV2TmV4dERpc3QgKiBNYXRoLmNsYW1wKHByb2dyZXNzLCAwLCAxKSArIHBhdGhQb3Nlc1t0aGlzLm5leHRJbmRleCAtIDFdLnZlbG9jaXR5ICogcGF0aFBvc2VzW3RoaXMubmV4dEluZGV4IC0gMV0udmVsb2NpdHkpO1xuICAgICAgY29uc3QgZGlmZlZlbG9jaXR5ID0gdGFyZ2V0VmVsb2NpdHkgLSB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IGRpZmZBY2NlbCA9IHBhdGhQb3Nlc1t0aGlzLm5leHRJbmRleF0uYWNjZWxlcmF0aW9uIC0gY3VycmVudEFjY2VsO1xuICAgICAgY29uc3QgdGFyZ2V0QWNjZWwgPSBrcF9hICogZGlmZlZlbG9jaXR5ICsga2RfYSAqIGRpZmZBY2NlbCArIGtmZl9hICogcGF0aFBvc2VzW3RoaXMubmV4dEluZGV4XS5hY2NlbGVyYXRpb247XG5cbiAgICAgIGlmICh0YXJnZXRBY2NlbCA+IDApXG4gICAgICAgIGdhcyA9IE1hdGgubWluKHRhcmdldEFjY2VsIC8gQ2FyLk1BWF9HQVNfQUNDRUwsIDEpO1xuICAgICAgZWxzZVxuICAgICAgICBicmFrZSA9IE1hdGgubWluKC10YXJnZXRBY2NlbCAvIENhci5NQVhfQlJBS0VfREVDRUwsIDEpO1xuXG4gICAgICB0aGlzLnByZXZWZWxvY2l0eSA9IHZlbG9jaXR5O1xuXG4gICAgICBjb25zdCBjbG9zZXN0RnJvbnRQYXRoUG9zID0gcHJvamVjdFBvaW50T25TZWdtZW50KGZyb250QXhsZVBvcywgcGF0aFBvc2VzW3RoaXMubmV4dEluZGV4IC0gMV0uZnJvbnRQb3MsIHBhdGhQb3Nlc1t0aGlzLm5leHRJbmRleF0uZnJvbnRQb3MpWzBdO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGRlc2lyZWQgaGVhZGluZyBhdCB0aGUgc3BlY2lmaWMgcG9pbnQgb24gdGhlIGZyb250IHBhdGggYnkgbGVycGluZyBiZXR3ZWVuIHByZXZIZWFkaW5nIGFuZCBuZXh0SGVhZGluZyB1c2luZyBwcm9ncmVzcyBhcyB0aGUgd2VpZ2h0XG4gICAgICBjb25zdCBwcmV2SGVhZGluZyA9IHRoaXMubmV4dEluZGV4ID4gMSA/IHBhdGhQb3Nlc1tuZXh0SW5kZXhdLmZyb250UG9zLmNsb25lKCkuc3ViKHBhdGhQb3Nlc1tuZXh0SW5kZXggLSAyXS5mcm9udFBvcykuYW5nbGUoKSA6IHBhdGhQb3Nlc1swXS5yb3Q7XG4gICAgICBjb25zdCBuZXh0SGVhZGluZyA9IHRoaXMubmV4dEluZGV4IDwgcGF0aFBvc2VzLmxlbmd0aCAtIDEgPyBwYXRoUG9zZXNbbmV4dEluZGV4ICsgMV0uZnJvbnRQb3MuY2xvbmUoKS5zdWIocGF0aFBvc2VzW25leHRJbmRleCAtIDFdLmZyb250UG9zKS5hbmdsZSgpIDogcGF0aFBvc2VzW3BhdGhQb3Nlcy5sZW5ndGggLSAxXS5yb3Q7XG4gICAgICBjb25zdCBkZXNpcmVkSGVhZGluZyA9IHByZXZIZWFkaW5nICsgKG5leHRIZWFkaW5nIC0gcHJldkhlYWRpbmcpICogcHJvZ3Jlc3M7XG5cbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZnJvbnQgYXhsZSBpcyB0byB0aGUgbGVmdCBvciByaWdodCBvZiB0aGUgZnJvbnQgcGF0aFxuICAgICAgY29uc3QgcGF0aFZlYyA9IHBhdGhQb3Nlc1tuZXh0SW5kZXhdLmZyb250UG9zLmNsb25lKCkuc3ViKHBhdGhQb3Nlc1tuZXh0SW5kZXggLSAxXS5mcm9udFBvcykubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCB6ZXJvID0gbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCk7XG4gICAgICBjb25zdCBsZWZ0ID0gcGF0aFZlYy5jbG9uZSgpLnJvdGF0ZUFyb3VuZCh6ZXJvLCBNYXRoLlBJIC8gMikuYWRkKGNsb3Nlc3RGcm9udFBhdGhQb3MpO1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXRoVmVjLmNsb25lKCkucm90YXRlQXJvdW5kKHplcm8sIC1NYXRoLlBJIC8gMikuYWRkKGNsb3Nlc3RGcm9udFBhdGhQb3MpO1xuICAgICAgY29uc3QgZGlyID0gZnJvbnRBeGxlUG9zLmRpc3RhbmNlVG9TcXVhcmVkKGxlZnQpIDwgZnJvbnRBeGxlUG9zLmRpc3RhbmNlVG9TcXVhcmVkKHJpZ2h0KSA/IC0xIDogMTtcblxuICAgICAgY29uc3QgayA9IDQ7XG4gICAgICBjb25zdCBnYWluID0gMC44O1xuICAgICAgY29uc3QgY3Jvc3NUcmFja0Vycm9yID0gZnJvbnRBeGxlUG9zLmRpc3RhbmNlVG8oY2xvc2VzdEZyb250UGF0aFBvcyk7XG4gICAgICBjb25zdCBoZWFkaW5nRXJyb3IgPSBNYXRoLndyYXBBbmdsZShwb3NlLnJvdCAtIGRlc2lyZWRIZWFkaW5nKTtcblxuICAgICAgLy9waGkgPSAtaGVhZGluZ0Vycm9yICsgZ2FpbiAqIE1hdGguYXRhbihrICogZGlyICogY3Jvc3NUcmFja0Vycm9yIC8gdmVsb2NpdHkpO1xuXG4gICAgICBjb25zdCBjdXJ2ID0gcGF0aFBvc2VzW25leHRJbmRleCAtIDFdLmN1cnYgKyAocGF0aFBvc2VzW25leHRJbmRleF0uY3VydiAtIHBhdGhQb3Nlc1tuZXh0SW5kZXggLSAxXS5jdXJ2KSAqIHByb2dyZXNzO1xuXG4gICAgICBwaGkgPSBNYXRoLmF0YW4oY3VydiAqIENhci5XSEVFTF9CQVNFKSArIGdhaW4gKiBNYXRoLmF0YW4oayAqIGRpciAqIGNyb3NzVHJhY2tFcnJvciAvIE1hdGgubWF4KHZlbG9jaXR5LCAwLjAxKSk7XG5cbiAgICAgIGNvbnN0IGNoZWNrU3RlZXIgPSBNYXRoLmNsYW1wKChwaGkgLSB3aGVlbEFuZ2xlKSAvIGR0IC8gQ2FyLk1BWF9TVEVFUl9TUEVFRCwgLTEsIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IHBoaUVycm9yID0gcGhpIC0gd2hlZWxBbmdsZTtcbiAgICAvKlxuICAgIGNvbnN0IGRQaGlFcnJvciA9IChwaGlFcnJvciAtIHRoaXMucHJldlBoaUVycm9yKSAvIGR0O1xuICAgIHRoaXMucHJldlBoaUVycm9yID0gcGhpRXJyb3I7XG4gICAgXG4gICAgY29uc3Qgc3RlZXIgPSBNYXRoLmNsYW1wKDEyICogcGhpRXJyb3IgKyAwLjggKiBkUGhpRXJyb3IsIC0xLCAxKTtcbiAgICAqL1xuXG4gICAgY29uc3Qgc3RlZXIgPSBNYXRoLmNsYW1wKHBoaUVycm9yIC8gZHQgLyBDYXIuTUFYX1NURUVSX1NQRUVELCAtMSwgMSk7XG5cbiAgICByZXR1cm4geyBnYXMsIGJyYWtlLCBzdGVlciB9O1xuICB9XG5cbiAgLy8gRmluZHMgdGhlIG5leHQgcG9pbnQgdGhlIHZlaGljbGUgaXMgYXBwcm9hY2hpbmcgYW5kIHRoZSBwcm9ncmVzcyBiZXR3ZWVuIHRoZSBwcmV2IHBvaW50IGFuZCB0aGUgbmV4dCBwb2ludFxuICAvLyBSZXR1cm5zIFtuZXh0UG9pbnRJbmRleCwgcHJvZ3Jlc3MgZnJvbSAobmV4dFBvaW50SW5kZXggLSAxKSB0byBuZXh0UG9pbnRJbmRleCwgezAgLSAxfV1cbiAgZmluZE5leHRJbmRleChmcm9udEF4bGVQb3MpIHtcbiAgICBjb25zdCBwYXRoUG9zZXMgPSB0aGlzLnBhdGgucG9zZXM7XG5cbiAgICAvLyBDb25zdHJhaW4gdGhlIHNlYXJjaCB0byBqdXN0IGEgZmV3IHBvaW50cyBzdXJyb3VuZGluZyB0aGUgY3VycmVudCBuZXh0SW5kZXhcbiAgICAvLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggYSBwYXRoIHRoYXQgY3Jvc3NlcyBpdHNlbGZcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMubmV4dEluZGV4IC0gMjApO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhdGhQb3Nlcy5sZW5ndGggLSAxLCB0aGlzLm5leHRJbmRleCArIDIwKTtcbiAgICBsZXQgY2xvc2VzdERpc3RTcXIgPSBmcm9udEF4bGVQb3MuZGlzdGFuY2VUb1NxdWFyZWQocGF0aFBvc2VzW3N0YXJ0XS5mcm9udFBvcyk7XG4gICAgbGV0IGNsb3Nlc3RJbmRleCA9IHN0YXJ0O1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBkaXN0U3FyID0gZnJvbnRBeGxlUG9zLmRpc3RhbmNlVG9TcXVhcmVkKHBhdGhQb3Nlc1tpXS5mcm9udFBvcyk7XG4gICAgICBpZiAoZGlzdFNxciA8IGNsb3Nlc3REaXN0U3FyKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0U3FyID0gZGlzdFNxcjtcbiAgICAgICAgY2xvc2VzdEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xvc2VzdEluZGV4ID09IHBhdGhQb3Nlcy5sZW5ndGggLSAxKSB7XG4gICAgICBjb25zdCBbXywgcHJvZ3Jlc3NdID0gcHJvamVjdFBvaW50T25TZWdtZW50KGZyb250QXhsZVBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleCAtIDFdLmZyb250UG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4XS5mcm9udFBvcyk7XG4gICAgICByZXR1cm4gW2Nsb3Nlc3RJbmRleCwgcHJvZ3Jlc3NdO1xuICAgIH0gZWxzZSBpZiAoY2xvc2VzdEluZGV4ID09IDApIHtcbiAgICAgIGNvbnN0IFtfLCBwcm9ncmVzc10gPSBwcm9qZWN0UG9pbnRPblNlZ21lbnQoZnJvbnRBeGxlUG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4XS5mcm9udFBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleCArIDFdLmZyb250UG9zKTtcbiAgICAgIHJldHVybiBbY2xvc2VzdEluZGV4ICsgMSwgcHJvZ3Jlc3NdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbmV4dFBvaW50IGlzIGVpdGhlciAoY2xvc2VzdFBvaW50KSBvciAoY2xvc2VzdFBvaW50ICsgMSkuIFByb2plY3QgdGhlIGZyb250QXhsZVBvcyB0byBib3RoXG4gICAgICAvLyBvZiB0aG9zZSB0d28gbGluZSBzZWdtZW50cyAodGhlIHNlZ21lbnQgcHJlY2VkaW5nIGNsb3Nlc3RQb2ludCBhbmQgdGhlIHNlZ21lbnQgc3VjY2VlZGluZyBjbG9zZXN0UG9pbnQpXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hpY2ggc2VnbWVudCBpdCdzIGNsb3Nlc3QgdG8uXG4gICAgICBjb25zdCBbcHJlY2VkaW5nUHJvamVjdGlvbiwgcHJlY2VkaW5nUHJvZ3Jlc3NdID0gcHJvamVjdFBvaW50T25TZWdtZW50KGZyb250QXhsZVBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleCAtIDFdLmZyb250UG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4XS5mcm9udFBvcyk7XG4gICAgICBjb25zdCBbc3VjY2VlZGluZ1Byb2plY3Rpb24sIHN1Y2NlZWRpbmdQcm9ncmVzc10gPSBwcm9qZWN0UG9pbnRPblNlZ21lbnQoZnJvbnRBeGxlUG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4XS5mcm9udFBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleCArIDFdLmZyb250UG9zKTtcblxuICAgICAgaWYgKGZyb250QXhsZVBvcy5kaXN0YW5jZVRvU3F1YXJlZChwcmVjZWRpbmdQcm9qZWN0aW9uKSA8IGZyb250QXhsZVBvcy5kaXN0YW5jZVRvU3F1YXJlZChzdWNjZWVkaW5nUHJvamVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIFtjbG9zZXN0SW5kZXgsIHByZWNlZGluZ1Byb2dyZXNzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbY2xvc2VzdEluZGV4ICsgMSwgc3VjY2VlZGluZ1Byb2dyZXNzXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gUmV0dXJucyBbcG9pbnRPblNlZ21lbnQsIHByb2dyZXNzQWxvbmdTZWdtZW50IHswIC0gMX1dXG5mdW5jdGlvbiBwcm9qZWN0UG9pbnRPblNlZ21lbnQocG9pbnQsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgZGlzdFNxciA9IHN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKGVuZCk7XG4gIC8vY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLmNsYW1wKHBvaW50LmNsb25lKCkuc3ViKHN0YXJ0KS5kb3QoZW5kLmNsb25lKCkuc3ViKHN0YXJ0KSkgLyBkaXN0U3FyLCAwLCAxKTtcbiAgY29uc3QgcHJvZ3Jlc3MgPSBwb2ludC5jbG9uZSgpLnN1YihzdGFydCkuZG90KGVuZC5jbG9uZSgpLnN1YihzdGFydCkpIC8gZGlzdFNxcjtcbiAgcmV0dXJuIFtlbmQuY2xvbmUoKS5zdWIoc3RhcnQpLm11bHRpcGx5U2NhbGFyKHByb2dyZXNzKS5hZGQoc3RhcnQpLCBwcm9ncmVzc107XG59XG4iLCJpbXBvcnQgQ2FyIGZyb20gXCIuLi8uLi9waHlzaWNzL0Nhci5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbGxvd0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihwYXRoLCBjYXIpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuY2FyID0gY2FyO1xuICAgIHRoaXMubmV4dEluZGV4ID0gMTtcbiAgICB0aGlzLnByZXZWZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5wcmV2QWNjZWwgPSAwO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wcmV2VmVsb2NpdHkgPSAwO1xuICAgIHRoaXMucHJldkFjY2VsID0gMDtcbiAgfVxuXG4gIHJlcGxhY2VQYXRoKHBhdGgpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubmV4dEluZGV4ID0gMTtcbiAgfVxuXG4gIHByZWRpY3RQb3NlQWZ0ZXJUaW1lKGN1cnJlbnRQb3NlLCBwcmVkaWN0aW9uVGltZSkge1xuICAgIGNvbnN0IHBhdGhQb3NlcyA9IHRoaXMucGF0aC5wb3NlcztcbiAgICBsZXQgW25leHRJbmRleCwgcHJvZ3Jlc3NdID0gdGhpcy5maW5kTmV4dEluZGV4KGN1cnJlbnRQb3NlLnBvcyk7XG4gICAgbGV0IGN1cnJlbnRWZWxvY2l0eSA9IGN1cnJlbnRQb3NlLnZlbG9jaXR5O1xuXG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eSA8PSAwLjAxKSByZXR1cm4gY3VycmVudFBvc2U7XG5cbiAgICB3aGlsZSAocHJlZGljdGlvblRpbWUgPiAwKSB7XG4gICAgICBjb25zdCBwcmV2UG9zZSA9IHBhdGhQb3Nlc1tuZXh0SW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IG5leHRQb3NlID0gcGF0aFBvc2VzW25leHRJbmRleF07XG5cbiAgICAgIGNvbnN0IHNlZ21lbnREaXN0ID0gbmV4dFBvc2UucG9zLmRpc3RhbmNlVG8ocHJldlBvc2UucG9zKTtcbiAgICAgIGNvbnN0IGRpc3RMZWZ0ID0gc2VnbWVudERpc3QgKiAoMSAtIHByb2dyZXNzKTtcbiAgICAgIGNvbnN0IHN1bVYgPSAoY3VycmVudFZlbG9jaXR5ICsgbmV4dFBvc2UudmVsb2NpdHkpIC8gMjtcbiAgICAgIGNvbnN0IHRpbWVUb05leHRJbmRleCA9IDIgKiBkaXN0TGVmdCAvIChzdW1WID09IDAgPyAwLjAxIDogc3VtVik7XG5cbiAgICAgIGlmICh0aW1lVG9OZXh0SW5kZXggPj0gcHJlZGljdGlvblRpbWUgfHwgbmV4dEluZGV4ICsgMSA+PSBwYXRoUG9zZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBzdW1WIC8gMiAqIHByZWRpY3Rpb25UaW1lO1xuICAgICAgICBjb25zdCBuZXdQcm9ncmVzcyA9IHByb2dyZXNzICsgZGlzdCAvIHNlZ21lbnREaXN0O1xuICAgICAgICBjb25zdCBuZXdSb3RhdGlvbiA9IE1hdGgud3JhcEFuZ2xlKHByZXZQb3NlLnJvdCArIE1hdGgud3JhcEFuZ2xlKG5leHRQb3NlLnJvdCAtIHByZXZQb3NlLnJvdCkgKiBuZXdQcm9ncmVzcyk7XG5cbiAgICAgICAgY29uc3QgcHByZXZQb3NlID0gbmV4dEluZGV4IC0gMiA+PSAwID8gcGF0aFBvc2VzW25leHRJbmRleCAtIDJdIDogcHJldlBvc2U7XG4gICAgICAgIGNvbnN0IG5uZXh0UG9zZSA9IG5leHRJbmRleCArIDEgPCBwYXRoUG9zZXMubGVuZ3RoID8gcGF0aFBvc2VzW25leHRJbmRleCArIDFdIDogbmV4dFBvc2U7XG5cbiAgICAgICAgY29uc3QgZEN1cnYgPSAobmV4dFBvc2UuY3VydiAtIHByZXZQb3NlLmN1cnYpIC8gc2VnbWVudERpc3Q7XG4gICAgICAgIGNvbnN0IGRDdXJ2UHJldiA9ICgocHJldlBvc2UuY3VydiAtIHBwcmV2UG9zZS5jdXJ2KSAvIHBwcmV2UG9zZS5wb3MuZGlzdGFuY2VUbyhwcmV2UG9zZS5wb3MpICsgZEN1cnYpIC8gMjtcbiAgICAgICAgY29uc3QgZEN1cnZOZXh0ID0gKGRDdXJ2ICsgKG5uZXh0UG9zZS5jdXJ2IC0gbmV4dFBvc2UuY3VydikgLyBuZXh0UG9zZS5wb3MuZGlzdGFuY2VUbyhubmV4dFBvc2UucG9zKSkgLyAyO1xuXG4gICAgICAgIGNvbnN0IGRkQ3VydiA9IChkQ3Vydk5leHQgLSBkQ3VydlByZXYpIC8gc2VnbWVudERpc3Q7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3M6IG5leHRQb3NlLnBvcy5jbG9uZSgpLnN1YihwcmV2UG9zZS5wb3MpLm11bHRpcGx5U2NhbGFyKG5ld1Byb2dyZXNzKS5hZGQobmV4dFBvc2UucG9zKSxcbiAgICAgICAgICByb3Q6IG5ld1JvdGF0aW9uLFxuICAgICAgICAgIGN1cnY6IHByZXZQb3NlLmN1cnYgKyAobmV4dFBvc2UuY3VydiAtIHByZXZQb3NlLmN1cnYpICogbmV3UHJvZ3Jlc3MsXG4gICAgICAgICAgZEN1cnY6IGRDdXJ2LFxuICAgICAgICAgIGRkQ3VydjogZGRDdXJ2LFxuICAgICAgICAgIHZlbG9jaXR5OiBuZXh0UG9zZS52ZWxvY2l0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRWZWxvY2l0eSA9IG5leHRQb3NlLnZlbG9jaXR5O1xuICAgICAgcHJlZGljdGlvblRpbWUgLT0gdGltZVRvTmV4dEluZGV4O1xuICAgICAgcHJvZ3Jlc3MgPSAwO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgY29udHJvbChwb3NlLCB3aGVlbEFuZ2xlLCB2ZWxvY2l0eSwgZHQsIGxvY2tQYXRoID0gZmFsc2UpIHtcbiAgICBjb25zdCBwYXRoUG9zZXMgPSB0aGlzLnBhdGgucG9zZXM7XG4gICAgY29uc3QgW25leHRJbmRleCwgcHJvZ3Jlc3MsIHByb2plY3Rpb25dID0gdGhpcy5maW5kTmV4dEluZGV4KHBvc2UucG9zKTtcbiAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcblxuICAgIGNvbnN0IHByZXZQb3NlID0gcGF0aFBvc2VzW25leHRJbmRleCAtIDFdO1xuICAgIGNvbnN0IG5leHRQb3NlID0gcGF0aFBvc2VzW25leHRJbmRleF07XG5cbiAgICBsZXQgZ2FzID0gMDtcbiAgICBsZXQgYnJha2UgPSAwO1xuICAgIGxldCBzdGVlciA9IDA7XG5cbiAgICBpZiAobmV4dEluZGV4ID49IHBhdGhQb3Nlcy5sZW5ndGggLSAyICYmIHByb2dyZXNzID49IDEpIHtcbiAgICAgIGJyYWtlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLypcbiAgICAgIGNvbnN0IGtwX2EgPSA0O1xuICAgICAgY29uc3Qga2RfYSA9IDAuNTtcbiAgICAgIGNvbnN0IGtmZl9hID0gMC41O1xuXG4gICAgICBjb25zdCBjdXJyZW50QWNjZWwgPSAodmVsb2NpdHkgLSB0aGlzLnByZXZWZWxvY2l0eSkgLyBkdDtcbiAgICAgIGNvbnN0IHByZXZOZXh0RGlzdCA9IG5leHRQb3NlLnBvcy5kaXN0YW5jZVRvKHByZXZQb3NlLnBvcyk7XG4gICAgICBjb25zdCB0YXJnZXRWZWxvY2l0eSA9IE1hdGguc3FydCgyICogbmV4dFBvc2UuYWNjZWxlcmF0aW9uICogcHJldk5leHREaXN0ICogTWF0aC5jbGFtcChwcm9ncmVzcywgMCwgMSkgKyBwcmV2UG9zZS52ZWxvY2l0eSAqIHByZXZQb3NlLnZlbG9jaXR5KTtcbiAgICAgIGNvbnN0IGRpZmZWZWxvY2l0eSA9IHRhcmdldFZlbG9jaXR5IC0gdmVsb2NpdHk7XG4gICAgICBjb25zdCBkaWZmQWNjZWwgPSBuZXh0UG9zZS5hY2NlbGVyYXRpb24gLSBjdXJyZW50QWNjZWw7XG4gICAgICBjb25zdCB0YXJnZXRBY2NlbCA9IGtwX2EgKiBkaWZmVmVsb2NpdHkgKyBrZF9hICogZGlmZkFjY2VsICsga2ZmX2EgKiBuZXh0UG9zZS5hY2NlbGVyYXRpb247XG4gICAgICAqL1xuICAgICAgY29uc3QgYWNjZWxEYW1waW5nID0gMC4xO1xuICAgICAgY29uc3QgdGFyZ2V0QWNjZWwgPSBuZXh0UG9zZS5hY2NlbGVyYXRpb247XG4gICAgICBjb25zdCBkYW1wZWRBY2NlbCA9IHRoaXMucHJldkFjY2VsICogKDEgLSBhY2NlbERhbXBpbmcpICsgdGFyZ2V0QWNjZWwgKiBhY2NlbERhbXBpbmc7XG5cbiAgICAgIGlmIChkYW1wZWRBY2NlbCA+IDApXG4gICAgICAgIGdhcyA9IE1hdGgubWluKGRhbXBlZEFjY2VsIC8gQ2FyLk1BWF9HQVNfQUNDRUwsIDEpO1xuICAgICAgZWxzZVxuICAgICAgICBicmFrZSA9IE1hdGgubWluKC1kYW1wZWRBY2NlbCAvIENhci5NQVhfQlJBS0VfREVDRUwsIDEpO1xuXG4gICAgICB0aGlzLnByZXZWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgdGhpcy5wcmV2QWNjZWwgPSBkYW1wZWRBY2NlbDtcblxuICAgICAgY29uc3QgY3VydmF0dXJlID0gcHJldlBvc2UuY3VydiArIChuZXh0UG9zZS5jdXJ2IC0gcHJldlBvc2UuY3VydikgKiBwcm9ncmVzcztcbiAgICAgIGNvbnN0IGRlc2lyZWRXaGVlbEFuZ2xlID0gTWF0aC5hdGFuKGN1cnZhdHVyZSAqIENhci5XSEVFTF9CQVNFKTtcbiAgICAgIGNvbnN0IHdoZWVsQW5nbGVFcnJvciA9IGRlc2lyZWRXaGVlbEFuZ2xlIC0gd2hlZWxBbmdsZTtcbiAgICAgIHN0ZWVyID0gTWF0aC5jbGFtcCh3aGVlbEFuZ2xlRXJyb3IgLyBkdCAvIENhci5NQVhfU1RFRVJfU1BFRUQsIC0xLCAxKTtcblxuICAgICAgaWYgKGxvY2tQYXRoKSB7XG4gICAgICAgIGNvbnN0IGRhbXBpbmcgPSAwLjE7XG4gICAgICAgIGNvbnN0IG5ld1JvdGF0aW9uID0gTWF0aC53cmFwQW5nbGUocHJldlBvc2Uucm90ICsgTWF0aC53cmFwQW5nbGUobmV4dFBvc2Uucm90IC0gcHJldlBvc2Uucm90KSAqIHByb2dyZXNzKTtcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMihwcm9qZWN0aW9uLnggLSBDYXIuUkVBUl9BWExFX1BPUyAqIE1hdGguY29zKG5ld1JvdGF0aW9uKSwgcHJvamVjdGlvbi55IC0gQ2FyLlJFQVJfQVhMRV9QT1MgKiBNYXRoLnNpbihuZXdSb3RhdGlvbikpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhNYXRoLndyYXBBbmdsZShuZXdSb3RhdGlvbiAtIHRoaXMuY2FyLnJvdGF0aW9uKSkgPiAwLjUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnd3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhci5yb3RhdGlvbiArPSBkYW1waW5nICogTWF0aC53cmFwQW5nbGUobmV3Um90YXRpb24gLSB0aGlzLmNhci5yb3RhdGlvbik7XG4gICAgICAgIHRoaXMuY2FyLnBvc2l0aW9uID0gdGhpcy5jYXIucG9zaXRpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxIC0gZGFtcGluZykuYWRkKG5ld1Bvc2l0aW9uLm11bHRpcGx5U2NhbGFyKGRhbXBpbmcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBnYXMsIGJyYWtlLCBzdGVlciB9O1xuICB9XG5cbiAgZmluZE5leHRJbmRleChwb3MpIHtcbiAgICBjb25zdCBwYXRoUG9zZXMgPSB0aGlzLnBhdGgucG9zZXM7XG5cbiAgICAvLyBDb25zdHJhaW4gdGhlIHNlYXJjaCB0byBqdXN0IGEgZmV3IHBvaW50cyBzdXJyb3VuZGluZyB0aGUgY3VycmVudCBuZXh0SW5kZXhcbiAgICAvLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggYSBwYXRoIHRoYXQgY3Jvc3NlcyBpdHNlbGZcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMubmV4dEluZGV4IC0gMjApO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhdGhQb3Nlcy5sZW5ndGggLSAxLCB0aGlzLm5leHRJbmRleCArIDIwKTtcbiAgICBsZXQgY2xvc2VzdERpc3RTcXIgPSBwb3MuZGlzdGFuY2VUb1NxdWFyZWQocGF0aFBvc2VzW3N0YXJ0XS5wb3MpO1xuICAgIGxldCBjbG9zZXN0SW5kZXggPSBzdGFydDtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydCArIDE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZGlzdFNxciA9IHBvcy5kaXN0YW5jZVRvU3F1YXJlZChwYXRoUG9zZXNbaV0ucG9zKTtcbiAgICAgIGlmIChkaXN0U3FyIDwgY2xvc2VzdERpc3RTcXIpIHtcbiAgICAgICAgY2xvc2VzdERpc3RTcXIgPSBkaXN0U3FyO1xuICAgICAgICBjbG9zZXN0SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbG9zZXN0SW5kZXggPT0gcGF0aFBvc2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGNvbnN0IFtwcm9qZWN0aW9uLCBwcm9ncmVzc10gPSBwcm9qZWN0UG9pbnRPblNlZ21lbnQocG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4IC0gMV0ucG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4XS5wb3MpO1xuICAgICAgcmV0dXJuIFtjbG9zZXN0SW5kZXgsIHByb2dyZXNzLCBwcm9qZWN0aW9uXTtcbiAgICB9IGVsc2UgaWYgKGNsb3Nlc3RJbmRleCA9PSAwKSB7XG4gICAgICBjb25zdCBbcHJvamVjdGlvbiwgcHJvZ3Jlc3NdID0gcHJvamVjdFBvaW50T25TZWdtZW50KHBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleF0ucG9zLCBwYXRoUG9zZXNbY2xvc2VzdEluZGV4ICsgMV0ucG9zKTtcbiAgICAgIHJldHVybiBbY2xvc2VzdEluZGV4ICsgMSwgcHJvZ3Jlc3MsIHByb2plY3Rpb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbmV4dFBvaW50IGlzIGVpdGhlciAoY2xvc2VzdFBvaW50KSBvciAoY2xvc2VzdFBvaW50ICsgMSkuIFByb2plY3QgdGhlIHBvcyB0byBib3RoXG4gICAgICAvLyBvZiB0aG9zZSB0d28gbGluZSBzZWdtZW50cyAodGhlIHNlZ21lbnQgcHJlY2VkaW5nIGNsb3Nlc3RQb2ludCBhbmQgdGhlIHNlZ21lbnQgc3VjY2VlZGluZyBjbG9zZXN0UG9pbnQpXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hpY2ggc2VnbWVudCBpdCdzIGNsb3Nlc3QgdG8uXG4gICAgICBjb25zdCBbcHJlY2VkaW5nUHJvamVjdGlvbiwgcHJlY2VkaW5nUHJvZ3Jlc3NdID0gcHJvamVjdFBvaW50T25TZWdtZW50KHBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleCAtIDFdLnBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleF0ucG9zKTtcbiAgICAgIGNvbnN0IFtzdWNjZWVkaW5nUHJvamVjdGlvbiwgc3VjY2VlZGluZ1Byb2dyZXNzXSA9IHByb2plY3RQb2ludE9uU2VnbWVudChwb3MsIHBhdGhQb3Nlc1tjbG9zZXN0SW5kZXhdLnBvcywgcGF0aFBvc2VzW2Nsb3Nlc3RJbmRleCArIDFdLnBvcyk7XG5cbiAgICAgIGlmIChwb3MuZGlzdGFuY2VUb1NxdWFyZWQocHJlY2VkaW5nUHJvamVjdGlvbikgPCBwb3MuZGlzdGFuY2VUb1NxdWFyZWQoc3VjY2VlZGluZ1Byb2plY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBbY2xvc2VzdEluZGV4LCBwcmVjZWRpbmdQcm9ncmVzcywgcHJlY2VkaW5nUHJvamVjdGlvbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2Nsb3Nlc3RJbmRleCArIDEsIHN1Y2NlZWRpbmdQcm9ncmVzcywgc3VjY2VlZGluZ1Byb2plY3Rpb25dO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBSZXR1cm5zIFtwb2ludE9uU2VnbWVudCwgcHJvZ3Jlc3NBbG9uZ1NlZ21lbnQgezAgLSAxfV1cbmZ1bmN0aW9uIHByb2plY3RQb2ludE9uU2VnbWVudChwb2ludCwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBkaXN0U3FyID0gc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoZW5kKTtcbiAgY29uc3QgcHJvZ3Jlc3MgPSBwb2ludC5jbG9uZSgpLnN1YihzdGFydCkuZG90KGVuZC5jbG9uZSgpLnN1YihzdGFydCkpIC8gZGlzdFNxcjtcbiAgcmV0dXJuIFtlbmQuY2xvbmUoKS5zdWIoc3RhcnQpLm11bHRpcGx5U2NhbGFyKHByb2dyZXNzKS5hZGQoc3RhcnQpLCBwcm9ncmVzc107XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNYW51YWxDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYXJLZXlzID0geyBmb3J3YXJkOiBmYWxzZSwgYmFja3dhcmQ6IGZhbHNlLCBsZWZ0OiBmYWxzZSwgcmlnaHQ6IGZhbHNlLCBicmFrZTogZmFsc2UgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudCA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlICd3JzogY2FzZSAnVyc6IHRoaXMuY2FyS2V5cy5mb3J3YXJkID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3MnOiBjYXNlICdTJzogdGhpcy5jYXJLZXlzLmJhY2t3YXJkID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2EnOiBjYXNlICdBJzogdGhpcy5jYXJLZXlzLmxlZnQgPSB0cnVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnZCc6IGNhc2UgJ0QnOiB0aGlzLmNhcktleXMucmlnaHQgPSB0cnVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnICc6IHRoaXMuY2FyS2V5cy5icmFrZSA9IHRydWU7IGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBldmVudCA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlICd3JzogY2FzZSAnVyc6IHRoaXMuY2FyS2V5cy5mb3J3YXJkID0gZmFsc2U7IGJyZWFrO1xuICAgICAgICBjYXNlICdzJzogY2FzZSAnUyc6IHRoaXMuY2FyS2V5cy5iYWNrd2FyZCA9IGZhbHNlOyBicmVhaztcbiAgICAgICAgY2FzZSAnYSc6IGNhc2UgJ0EnOiB0aGlzLmNhcktleXMubGVmdCA9IGZhbHNlOyBicmVhaztcbiAgICAgICAgY2FzZSAnZCc6IGNhc2UgJ0QnOiB0aGlzLmNhcktleXMucmlnaHQgPSBmYWxzZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJyAnOiB0aGlzLmNhcktleXMuYnJha2UgPSBmYWxzZTsgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb250cm9sKCkge1xuICAgIGxldCBnYXMgPSAwO1xuICAgIGxldCBicmFrZSA9IDA7XG4gICAgbGV0IHN0ZWVyID0gMDtcblxuICAgIGlmICh0aGlzLmNhcktleXMuZm9yd2FyZCkgZ2FzICs9IDE7XG4gICAgaWYgKHRoaXMuY2FyS2V5cy5iYWNrd2FyZCkgZ2FzIC09IDE7XG4gICAgaWYgKHRoaXMuY2FyS2V5cy5sZWZ0KSBzdGVlciAtPSAxO1xuICAgIGlmICh0aGlzLmNhcktleXMucmlnaHQpIHN0ZWVyICs9IDE7XG4gICAgaWYgKHRoaXMuY2FyS2V5cy5icmFrZSkgYnJha2UgKz0gMTtcblxuICAgIHJldHVybiB7IGdhcywgYnJha2UsIHN0ZWVyIH07XG4gIH1cbn1cbiIsIi8vIGdlb2xvY2F0aW9uID0gWzMzLjUyMzkwMCwgLTExMS45MDg3NTZdO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwT2JqZWN0IGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcihnZW9sb2NhdGlvbiA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5nZW9sb2NhdGlvbiA9IGdlb2xvY2F0aW9uO1xuICAgIHRoaXMudGlsZXNHcm91cCA9IG51bGw7XG5cbiAgICBjb25zdCB0aWxlU2l6ZSA9IGdlb2xvY2F0aW9uID8gdGhpcy50aWxlU2l6ZUluTWV0ZXJzKCkgOiAxMDtcbiAgICBjb25zdCBncmlkID0gbmV3IFRIUkVFLkdyaWRIZWxwZXIoTWFwT2JqZWN0LkhBTEZfTlVNX1RJTEVTICogOCAqIHRpbGVTaXplLCBNYXBPYmplY3QuSEFMRl9OVU1fVElMRVMgKiA4LCAweDMzMzMzMywgMHgzMzMzMzMpO1xuICAgIGdyaWQucmVuZGVyT3JkZXIgPSAtMTtcbiAgICBncmlkLm1hdGVyaWFsLmRlcHRoVGVzdCA9IGZhbHNlO1xuICAgIGdyaWQucG9zaXRpb24uYWRkKG5ldyBUSFJFRS5WZWN0b3IzKC10aWxlU2l6ZSAvIDIsIDAsIC10aWxlU2l6ZSAvIDIpKTtcbiAgICB0aGlzLmFkZChncmlkKTtcblxuICAgIGlmIChnZW9sb2NhdGlvbilcbiAgICAgIHRoaXMuZHJhd1RpbGVzKCk7XG4gIH1cblxuICAvLyBDb252ZXJ0cyBsYXQtbG9uZyBnZW9sb2NhdGlvbiB0byBHb29nbGUgTWFwcyB3b3JsZCBjb29kaW5hdGVzXG4gIHN0YXRpYyBnZW9Ub1dvcmxkKGxhdGxuZykge1xuICAgIGNvbnN0IGxhdGl0dWRlUmFkaWFucyA9IGxhdGxuZ1swXSAqIE1hdGguUEkgLyAxODA7XG4gICAgY29uc3QgeCA9IChsYXRsbmdbMV0gKyAxODApIC8gMzYwICogMjU2O1xuICAgIGNvbnN0IHkgPSAoKDEgLSBNYXRoLmxvZyhNYXRoLnRhbihsYXRpdHVkZVJhZGlhbnMpICsgMSAvIE1hdGguY29zKGxhdGl0dWRlUmFkaWFucykpIC8gTWF0aC5QSSkgLyAyKSAqIDI1NjtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyB0aGUgeCBhbmQgeSB0aWxlIGluZGljZXMgZm9yIHRoZSBwcm92aWRlZCB3b3JsZCBjb29yZGluYXRlc1xuICBzdGF0aWMgd29ybGRUb1RpbGUod29ybGRDb29yZGluYXRlcykge1xuICAgIHJldHVybiBbTWF0aC5mbG9vcih3b3JsZENvb3JkaW5hdGVzWzBdICogTWFwT2JqZWN0LlNDQUxFIC8gMjU2KSwgTWF0aC5mbG9vcih3b3JsZENvb3JkaW5hdGVzWzFdICogTWFwT2JqZWN0LlNDQUxFIC8gMjU2KV07XG4gIH1cblxuICBkcmF3VGlsZXMoKSB7XG4gICAgaWYgKHRoaXMudGlsZUdyb3VwICE9IG51bGwpIHRoaXMucmVtb3ZlKHRoaXMudGlsZXNHcm91cCk7XG4gICAgdGhpcy50aWxlR3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuICAgIGNvbnN0IG9yaWdpblRpbGUgPSBNYXBPYmplY3Qud29ybGRUb1RpbGUoTWFwT2JqZWN0Lmdlb1RvV29ybGQodGhpcy5nZW9sb2NhdGlvbikpO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdGhpcy50aWxlU2l6ZUluTWV0ZXJzKCk7XG5cbiAgICBmb3IgKGxldCB4ID0gLU1hcE9iamVjdC5IQUxGX05VTV9USUxFUywgaCA9IDA7IHggPCBNYXBPYmplY3QuSEFMRl9OVU1fVElMRVM7IHgrKykge1xuICAgICAgZm9yIChsZXQgeSA9IC1NYXBPYmplY3QuSEFMRl9OVU1fVElMRVM7IHkgPCBNYXBPYmplY3QuSEFMRl9OVU1fVElMRVM7IHkrKywgaCsrKSB7XG4gICAgICAgIGNvbnN0IHRpbGVUZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKGBodHRwczovL2tobXMke2ggJSA0fS5nb29nbGUuY29tL2toL3Y9NzQ4P3g9JHtvcmlnaW5UaWxlWzBdICsgeH0meT0ke29yaWdpblRpbGVbMV0gKyB5fSZ6PSR7TWFwT2JqZWN0LlpPT019YCk7XG4gICAgICAgIHRpbGVUZXh0dXJlLmFuaXNvdHJvcHkgPSAxNjtcbiAgICAgICAgY29uc3QgdGlsZUdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkodGlsZVNpemUsIHRpbGVTaXplKTtcbiAgICAgICAgY29uc3QgdGlsZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiB0aWxlVGV4dHVyZSwgY29sb3I6IDB4ZmZmZmZmIH0pO1xuICAgICAgICBjb25zdCB0aWxlID0gbmV3IFRIUkVFLk1lc2godGlsZUdlb21ldHJ5LCB0aWxlTWF0ZXJpYWwpO1xuICAgICAgICB0aWxlLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIHRpbGUucG9zaXRpb24ueCA9IHggKiB0aWxlU2l6ZTtcbiAgICAgICAgdGlsZS5wb3NpdGlvbi56ID0geSAqIHRpbGVTaXplO1xuXG4gICAgICAgIHRoaXMudGlsZUdyb3VwLmFkZCh0aWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFkZCh0aGlzLnRpbGVHcm91cCk7XG4gIH1cblxuICB0aWxlU2l6ZUluTWV0ZXJzKCkge1xuICAgIC8vIEJlY2F1c2Ugb2YgdGhlIE1lcmNhdG9yIHByb2plY3Rpb24gdXNlZCB0byBjcmVhdGUgdGhlIHRpbGUgaW1hZ2VzLCB0aGUgc2l6ZSBvZiBhIHRpbGUgKGluIG1ldGVycykgZGVwZW5kcyBvbiB0aGUgbGF0aXR1ZGVcbiAgICByZXR1cm4gMiAqIE1hdGguUEkgKiBNYXBPYmplY3QuRUFSVEhfUkFESVVTICogTWF0aC5jb3ModGhpcy5nZW9sb2NhdGlvblswXSAqIE1hdGguUEkgLyAxODApIC8gTWF0aC5wb3coMiwgTWFwT2JqZWN0LlpPT00pO1xuICB9XG59XG5cbk1hcE9iamVjdC5FQVJUSF9SQURJVVMgPSA2Mzc4MTM3OyAvLyBtZXRlcnNcbk1hcE9iamVjdC5USUxFX1BJWEVMUyA9IDI1NjsgLy8gcGl4ZWxzIHBlciB0aWxlXG5NYXBPYmplY3QuWk9PTSA9IDIwO1xuTWFwT2JqZWN0LlNDQUxFID0gMSA8PCBNYXBPYmplY3QuWk9PTTtcbk1hcE9iamVjdC5IQUxGX05VTV9USUxFUyA9IDIwO1xuIiwiLypcbiAqIEF1dG9kZXNrIDNEUyB0aHJlZWUuanMgZmlsZSBsb2FkZXIsIGJhc2VkIG9uIGxpYjNkcy5cbiAqXG4gKiBMb2FkcyBnZW9tZXRyeSB3aXRoIHV2IGFuZCBtYXRlcmlhbHMgYmFzaWMgcHJvcGVydGllcyB3aXRoIHRleHR1cmUgc3VwcG9ydC5cbiAqXG4gKiBAYXV0aG9yIEB0ZW50b25lXG4gKiBAYXV0aG9yIEB0aW1rbmlwXG4gKiBAY2xhc3MgVERTTG9hZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblRIUkVFLlREU0xvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0dGhpcy5kZWJ1ZyA9IGZhbHNlO1xuXG5cdHRoaXMuZ3JvdXAgPSBudWxsO1xuXHR0aGlzLnBvc2l0aW9uID0gMDtcblxuXHR0aGlzLm1hdGVyaWFscyA9IFtdO1xuXHR0aGlzLm1lc2hlcyA9IFtdO1xuXG59O1xuXG5USFJFRS5URFNMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5URFNMb2FkZXIsXG5cblx0LyoqXG5cdCAqIExvYWQgM2RzIGZpbGUgZnJvbSB1cmwuXG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKiBAcGFyYW0ge1t0eXBlXX0gdXJsIFVSTCBmb3IgdGhlIGZpbGUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uTG9hZCBvbkxvYWQgY2FsbGJhY2ssIHJlY2VpdmVzIGdyb3VwIE9iamVjdDNEIGFzIGFyZ3VtZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblByb2dyZXNzIG9uUHJvZ3Jlc3MgY2FsbGJhY2suXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3Igb25FcnJvciBjYWxsYmFjay5cblx0ICovXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCA/IHRoaXMucGF0aCA6IFRIUkVFLkxvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIGRhdGEsIHBhdGggKSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhcnNlIGFycmF5YnVmZmVyIGRhdGEgYW5kIGxvYWQgM2RzIGZpbGUuXG5cdCAqXG5cdCAqIEBtZXRob2QgcGFyc2Vcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgQXJyYXlidWZmZXIgZGF0YSB0byBiZSBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggZm9yIGV4dGVybmFsIHJlc291cmNlcy5cblx0ICogQHJldHVybiB7T2JqZWN0M0R9IEdyb3VwIGxvYWRlZCBmcm9tIDNkcyBmaWxlLlxuXHQgKi9cblx0cGFyc2U6IGZ1bmN0aW9uICggYXJyYXlidWZmZXIsIHBhdGggKSB7XG5cblx0XHR0aGlzLmdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IDA7XG5cdFx0dGhpcy5tYXRlcmlhbHMgPSBbXTtcblx0XHR0aGlzLm1lc2hlcyA9IFtdO1xuXG5cdFx0dGhpcy5yZWFkRmlsZSggYXJyYXlidWZmZXIsIHBhdGggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubWVzaGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5ncm91cC5hZGQoIHRoaXMubWVzaGVzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdyb3VwO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIERlY29kZSBmaWxlIGNvbnRlbnQgdG8gcmVhZCAzZHMgZGF0YS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkRmlsZVxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheWJ1ZmZlciBBcnJheWJ1ZmZlciBkYXRhIHRvIGJlIGxvYWRlZC5cblx0ICovXG5cdHJlYWRGaWxlOiBmdW5jdGlvbiAoIGFycmF5YnVmZmVyLCBwYXRoICkge1xuXG5cdFx0dmFyIGRhdGEgPSBuZXcgRGF0YVZpZXcoIGFycmF5YnVmZmVyICk7XG5cdFx0dmFyIGNodW5rID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblxuXHRcdGlmICggY2h1bmsuaWQgPT09IE1MSUJNQUdJQyB8fCBjaHVuay5pZCA9PT0gQ01BR0lDIHx8IGNodW5rLmlkID09PSBNM0RNQUdJQyApIHtcblxuXHRcdFx0dmFyIG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblxuXHRcdFx0d2hpbGUgKCBuZXh0ICE9PSAwICkge1xuXG5cdFx0XHRcdGlmICggbmV4dCA9PT0gTTNEX1ZFUlNJT04gKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVyc2lvbiA9IHRoaXMucmVhZERXb3JkKCBkYXRhICk7XG5cdFx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICczRFMgZmlsZSB2ZXJzaW9uOiAnICsgdmVyc2lvbiApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1EQVRBICkge1xuXG5cdFx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdFx0dGhpcy5yZWFkTWVzaERhdGEoIGRhdGEsIHBhdGggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdVbmtub3duIG1haW4gY2h1bms6ICcgKyBuZXh0LnRvU3RyaW5nKCAxNiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdQYXJzZWQgJyArIHRoaXMubWVzaGVzLmxlbmd0aCArICcgbWVzaGVzJyApO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgbWVzaCBkYXRhIGNodW5rLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRNZXNoRGF0YVxuXHQgKiBAcGFyYW0ge0RhdGF2aWV3fSBkYXRhIERhdGF2aWV3IGluIHVzZS5cblx0ICovXG5cdHJlYWRNZXNoRGF0YTogZnVuY3Rpb24gKCBkYXRhLCBwYXRoICkge1xuXG5cdFx0dmFyIGNodW5rID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblx0XHR2YXIgbmV4dCA9IHRoaXMubmV4dENodW5rKCBkYXRhLCBjaHVuayApO1xuXG5cdFx0d2hpbGUgKCBuZXh0ICE9PSAwICkge1xuXG5cdFx0XHRpZiAoIG5leHQgPT09IE1FU0hfVkVSU0lPTiApIHtcblxuXHRcdFx0XHR2YXIgdmVyc2lvbiA9ICsgdGhpcy5yZWFkRFdvcmQoIGRhdGEgKTtcblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdNZXNoIFZlcnNpb246ICcgKyB2ZXJzaW9uICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BU1RFUl9TQ0FMRSApIHtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJ01hc3RlciBzY2FsZTogJyArIHNjYWxlICk7XG5cdFx0XHRcdHRoaXMuZ3JvdXAuc2NhbGUuc2V0KCBzY2FsZSwgc2NhbGUsIHNjYWxlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE5BTUVEX09CSkVDVCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJ05hbWVkIE9iamVjdCcgKTtcblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdHRoaXMucmVhZE5hbWVkT2JqZWN0KCBkYXRhICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9FTlRSWSApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJ01hdGVyaWFsJyApO1xuXHRcdFx0XHR0aGlzLnJlc2V0UG9zaXRpb24oIGRhdGEgKTtcblx0XHRcdFx0dGhpcy5yZWFkTWF0ZXJpYWxFbnRyeSggZGF0YSwgcGF0aCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnVW5rbm93biBNREFUQSBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCBuYW1lZCBvYmplY3QgY2h1bmsuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZE5hbWVkT2JqZWN0XG5cdCAqIEBwYXJhbSB7RGF0YXZpZXd9IGRhdGEgRGF0YXZpZXcgaW4gdXNlLlxuXHQgKi9cblx0cmVhZE5hbWVkT2JqZWN0OiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdHZhciBuYW1lID0gdGhpcy5yZWFkU3RyaW5nKCBkYXRhLCA2NCApO1xuXHRcdGNodW5rLmN1ciA9IHRoaXMucG9zaXRpb247XG5cblx0XHR2YXIgbmV4dCA9IHRoaXMubmV4dENodW5rKCBkYXRhLCBjaHVuayApO1xuXHRcdHdoaWxlICggbmV4dCAhPT0gMCApIHtcblxuXHRcdFx0aWYgKCBuZXh0ID09PSBOX1RSSV9PQkpFQ1QgKSB7XG5cblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdHZhciBtZXNoID0gdGhpcy5yZWFkTWVzaCggZGF0YSApO1xuXHRcdFx0XHRtZXNoLm5hbWUgPSBuYW1lO1xuXHRcdFx0XHR0aGlzLm1lc2hlcy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdVbmtub3duIG5hbWVkIG9iamVjdCBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgbWF0ZXJpYWwgZGF0YSBjaHVuayBhbmQgYWRkIGl0IHRvIHRoZSBtYXRlcmlhbCBsaXN0LlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRNYXRlcmlhbEVudHJ5XG5cdCAqIEBwYXJhbSB7RGF0YXZpZXd9IGRhdGEgRGF0YXZpZXcgaW4gdXNlLlxuXHQgKi9cblx0cmVhZE1hdGVyaWFsRW50cnk6IGZ1bmN0aW9uICggZGF0YSwgcGF0aCApIHtcblxuXHRcdHZhciBjaHVuayA9IHRoaXMucmVhZENodW5rKCBkYXRhICk7XG5cdFx0dmFyIG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoKTtcblxuXHRcdHdoaWxlICggbmV4dCAhPT0gMCApIHtcblxuXHRcdFx0aWYgKCBuZXh0ID09PSBNQVRfTkFNRSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gdGhpcy5yZWFkU3RyaW5nKCBkYXRhLCA2NCApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIE5hbWU6ICcgKyBtYXRlcmlhbC5uYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9XSVJFICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgV2lyZWZyYW1lJyApO1xuXHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfV0lSRV9TSVpFICkge1xuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMucmVhZEJ5dGUoIGRhdGEgKTtcblx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgV2lyZWZyYW1lIFRoaWNrbmVzczogJyArIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9UV09fU0lERSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gVEhSRUUuRG91YmxlU2lkZTtcblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBEb3VibGVTaWRlZCcgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX0FERElUSVZFICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgQWRkaXRpdmUgQmxlbmRpbmcnICk7XG5cdFx0XHRcdG1hdGVyaWFsLmJsZW5kaW5nID0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZztcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX0RJRkZVU0UgKSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBEaWZmdXNlIENvbG9yJyApO1xuXHRcdFx0XHRtYXRlcmlhbC5jb2xvciA9IHRoaXMucmVhZENvbG9yKCBkYXRhICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9TUEVDVUxBUiApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIFNwZWN1bGFyIENvbG9yJyApO1xuXHRcdFx0XHRtYXRlcmlhbC5zcGVjdWxhciA9IHRoaXMucmVhZENvbG9yKCBkYXRhICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9BTUJJRU5UICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgQW1iaWVudCBjb2xvcicgKTtcblx0XHRcdFx0bWF0ZXJpYWwuY29sb3IgPSB0aGlzLnJlYWRDb2xvciggZGF0YSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfU0hJTklORVNTICkge1xuXG5cdFx0XHRcdHZhciBzaGluaW5lc3MgPSB0aGlzLnJlYWRXb3JkKCBkYXRhICk7XG5cdFx0XHRcdG1hdGVyaWFsLnNoaW5pbmVzcyA9IHNoaW5pbmVzcztcblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBTaGluaW5lc3MgOiAnICsgc2hpbmluZXNzICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9URVhNQVAgKSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBDb2xvck1hcCcgKTtcblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdG1hdGVyaWFsLm1hcCA9IHRoaXMucmVhZE1hcCggZGF0YSwgcGF0aCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfQlVNUE1BUCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIEJ1bXBNYXAnICk7XG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHRtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5yZWFkTWFwKCBkYXRhLCBwYXRoICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9PUEFDTUFQICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgT3BhY2l0eU1hcCcgKTtcblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5yZWFkTWFwKCBkYXRhLCBwYXRoICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9TUEVDTUFQICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgU3BlY3VsYXJNYXAnICk7XG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMucmVhZE1hcCggZGF0YSwgcGF0aCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgVW5rbm93biBtYXRlcmlhbCBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsLm5hbWUgXSA9IG1hdGVyaWFsO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgbWVzaCBkYXRhIGNodW5rLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRNZXNoXG5cdCAqIEBwYXJhbSB7RGF0YXZpZXd9IGRhdGEgRGF0YXZpZXcgaW4gdXNlLlxuXHQgKi9cblx0cmVhZE1lc2g6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdHZhciBjaHVuayA9IHRoaXMucmVhZENodW5rKCBkYXRhICk7XG5cdFx0dmFyIG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblxuXHRcdHZhciB1c2VCdWZmZXJHZW9tZXRyeSA9IGZhbHNlO1xuXHRcdHZhciBnZW9tZXRyeSA9IG51bGw7XG5cdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0aWYgKCB1c2VCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdH1cdGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cdFx0dmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0bWVzaC5uYW1lID0gJ21lc2gnO1xuXG5cdFx0d2hpbGUgKCBuZXh0ICE9PSAwICkge1xuXG5cdFx0XHRpZiAoIG5leHQgPT09IFBPSU5UX0FSUkFZICkge1xuXG5cdFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLnJlYWRXb3JkKCBkYXRhICk7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBWZXJ0ZXg6ICcgKyBwb2ludHMgKTtcblxuXHRcdFx0XHQvL0J1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0aWYgKCB1c2VCdWZmZXJHZW9tZXRyeSApXHR7XG5cblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb2ludHM7IGkgKysgKVx0XHR7XG5cblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKTtcblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKTtcblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKSwgMyApICk7XG5cblx0XHRcdFx0fSBlbHNlXHR7IC8vR2VvbWV0cnlcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50czsgaSArKyApXHRcdHtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMucmVhZEZsb2F0KCBkYXRhICksIHRoaXMucmVhZEZsb2F0KCBkYXRhICksIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gRkFDRV9BUlJBWSApIHtcblxuXHRcdFx0XHR0aGlzLnJlc2V0UG9zaXRpb24oIGRhdGEgKTtcblx0XHRcdFx0dGhpcy5yZWFkRmFjZUFycmF5KCBkYXRhLCBtZXNoICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IFRFWF9WRVJUUyApIHtcblxuXHRcdFx0XHR2YXIgdGV4ZWxzID0gdGhpcy5yZWFkV29yZCggZGF0YSApO1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgVVY6ICcgKyB0ZXhlbHMgKTtcblxuXHRcdFx0XHQvL0J1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0aWYgKCB1c2VCdWZmZXJHZW9tZXRyeSApXHR7XG5cblx0XHRcdFx0XHR2YXIgdXZzID0gW107XG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGV4ZWxzOyBpICsrIClcdFx0e1xuXG5cdFx0XHRcdFx0XHR1dnMucHVzaCggdGhpcy5yZWFkRmxvYXQoIGRhdGEgKSApO1xuXHRcdFx0XHRcdFx0dXZzLnB1c2goIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHV2cyApLCAyICkgKTtcblxuXHRcdFx0XHR9IGVsc2UgeyAvL0dlb21ldHJ5XG5cblx0XHRcdFx0XHR1dnMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhlbHM7IGkgKysgKVx0XHR7XG5cblx0XHRcdFx0XHRcdHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdGhpcy5yZWFkRmxvYXQoIGRhdGEgKSwgdGhpcy5yZWFkRmxvYXQoIGRhdGEgKSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNRVNIX01BVFJJWCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIFRyYW5mb3JtYXRpb24gTWF0cml4IChUT0RPKScgKTtcblxuXHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDEyOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHQvL1ggTGluZVxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSA9IHZhbHVlc1sgMCBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDEgXSA9IHZhbHVlc1sgNiBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDIgXSA9IHZhbHVlc1sgMyBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDMgXSA9IHZhbHVlc1sgOSBdO1xuXG5cdFx0XHRcdC8vWSBMaW5lXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNCBdID0gdmFsdWVzWyAyIF07XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNSBdID0gdmFsdWVzWyA4IF07XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNiBdID0gdmFsdWVzWyA1IF07XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNyBdID0gdmFsdWVzWyAxMSBdO1xuXG5cdFx0XHRcdC8vWiBMaW5lXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdID0gdmFsdWVzWyAxIF07XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdID0gdmFsdWVzWyA3IF07XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTAgXSA9IHZhbHVlc1sgNCBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDExIF0gPSB2YWx1ZXNbIDEwIF07XG5cblx0XHRcdFx0Ly9XIExpbmVcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMiBdID0gMDtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMyBdID0gMDtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxNCBdID0gMDtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxNSBdID0gMTtcblxuXHRcdFx0XHRtYXRyaXgudHJhbnNwb3NlKCk7XG5cblx0XHRcdFx0dmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0XHRpbnZlcnNlLmdldEludmVyc2UoIG1hdHJpeCwgdHJ1ZSApO1xuXHRcdFx0XHRnZW9tZXRyeS5hcHBseU1hdHJpeCggaW52ZXJzZSApO1xuXG5cdFx0XHRcdG1hdHJpeC5kZWNvbXBvc2UoIG1lc2gucG9zaXRpb24sIG1lc2gucXVhdGVybmlvbiwgbWVzaC5zY2FsZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgVW5rbm93biBtZXNoIGNodW5rOiAnICsgbmV4dC50b1N0cmluZyggMTYgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZW5kQ2h1bmsoIGNodW5rICk7XG5cblx0XHRpZiAoICEgdXNlQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdC8vZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1swXVtmYWNlSW5kZXhdW3ZlcnRleEluZGV4XVxuXG5cdFx0XHRpZiAoIHV2cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBmYWNlVVYgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlVVYucHVzaCggWyB1dnNbIGdlb21ldHJ5LmZhY2VzWyBpIF0uYSBdLCB1dnNbIGdlb21ldHJ5LmZhY2VzWyBpIF0uYiBdLCB1dnNbIGdlb21ldHJ5LmZhY2VzWyBpIF0uYyBdIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdID0gZmFjZVVWO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWVzaDtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWFkIGZhY2UgYXJyYXkgZGF0YSBjaHVuay5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkRmFjZUFycmF5XG5cdCAqIEBwYXJhbSB7RGF0YXZpZXd9IGRhdGEgRGF0YXZpZXcgaW4gdXNlLlxuXHQgKiBAcGFyYW0ge01lc2h9IG1lc2ggTWVzaCB0byBiZSBmaWxsZWQgd2l0aCB0aGUgZGF0YSByZWFkLlxuXHQgKi9cblx0cmVhZEZhY2VBcnJheTogZnVuY3Rpb24gKCBkYXRhLCBtZXNoICkge1xuXG5cdFx0dmFyIGNodW5rID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblx0XHR2YXIgZmFjZXMgPSB0aGlzLnJlYWRXb3JkKCBkYXRhICk7XG5cblx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIEZhY2VzOiAnICsgZmFjZXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzOyArKyBpICkge1xuXG5cdFx0XHRtZXNoLmdlb21ldHJ5LmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdGhpcy5yZWFkV29yZCggZGF0YSApLCB0aGlzLnJlYWRXb3JkKCBkYXRhICksIHRoaXMucmVhZFdvcmQoIGRhdGEgKSApICk7XG5cblx0XHRcdHZhciB2aXNpYmlsaXR5ID0gdGhpcy5yZWFkV29yZCggZGF0YSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9UaGUgcmVzdCBvZiB0aGUgRkFDRV9BUlJBWSBjaHVuayBpcyBzdWJjaHVua3NcblxuXHRcdHdoaWxlICggdGhpcy5wb3NpdGlvbiA8IGNodW5rLmVuZCApIHtcblxuXHRcdFx0dmFyIGNodW5rID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblxuXHRcdFx0aWYgKCBjaHVuay5pZCA9PT0gTVNIX01BVF9HUk9VUCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIE1hdGVyaWFsIEdyb3VwJyApO1xuXG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXG5cdFx0XHRcdHZhciBncm91cCA9IHRoaXMucmVhZE1hdGVyaWFsR3JvdXAoIGRhdGEgKTtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsc1sgZ3JvdXAubmFtZSBdO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApXHR7XG5cblx0XHRcdFx0XHRtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm5hbWUgPT09ICcnIClcdFx0e1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gbWVzaC5uYW1lO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIFVua25vd24gZmFjZSBhcnJheSBjaHVuazogJyArIGNodW5rLnRvU3RyaW5nKCAxNiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbmRDaHVuayggY2h1bmsgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZW5kQ2h1bmsoIGNodW5rICk7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCB0ZXh0dXJlIG1hcCBkYXRhIGNodW5rLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRNYXBcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqIEByZXR1cm4ge1RleHR1cmV9IFRleHR1cmUgcmVhZCBmcm9tIHRoaXMgZGF0YSBjaHVuay5cblx0ICovXG5cdHJlYWRNYXA6IGZ1bmN0aW9uICggZGF0YSwgcGF0aCApIHtcbiAgICBpZiAodGhpcy5za2lwTWFwcykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdHZhciBuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cdFx0dmFyIHRleHR1cmUgPSB7fTtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHBhdGggKTtcblxuXHRcdHdoaWxlICggbmV4dCAhPT0gMCApIHtcblxuXHRcdFx0aWYgKCBuZXh0ID09PSBNQVRfTUFQTkFNRSApIHtcblxuXHRcdFx0XHR2YXIgbmFtZSA9IHRoaXMucmVhZFN0cmluZyggZGF0YSwgMTI4ICk7XG5cdFx0XHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggbmFtZSApO1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgRmlsZTogJyArIHBhdGggKyBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9NQVBfVU9GRlNFVCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLm9mZnNldC54ID0gdGhpcy5yZWFkRmxvYXQoIGRhdGEgKTtcblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICAgICBPZmZzZXRYOiAnICsgdGV4dHVyZS5vZmZzZXQueCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfTUFQX1ZPRkZTRVQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5vZmZzZXQueSA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgT2Zmc2V0WTogJyArIHRleHR1cmUub2Zmc2V0LnkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX01BUF9VU0NBTEUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueCA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgUmVwZWF0WDogJyArIHRleHR1cmUucmVwZWF0LnggKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX01BUF9WU0NBTEUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueSA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgUmVwZWF0WTogJyArIHRleHR1cmUucmVwZWF0LnkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIFVua25vd24gbWFwIGNodW5rOiAnICsgbmV4dC50b1N0cmluZyggMTYgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZW5kQ2h1bmsoIGNodW5rICk7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWFkIG1hdGVyaWFsIGdyb3VwIGRhdGEgY2h1bmsuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZE1hdGVyaWFsR3JvdXBcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbmFtZSBhbmQgaW5kZXggb2YgdGhlIG9iamVjdC5cblx0ICovXG5cdHJlYWRNYXRlcmlhbEdyb3VwOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdHZhciBuYW1lID0gdGhpcy5yZWFkU3RyaW5nKCBkYXRhLCA2NCApO1xuXHRcdHZhciBudW1GYWNlcyA9IHRoaXMucmVhZFdvcmQoIGRhdGEgKTtcblxuXHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgICAgTmFtZTogJyArIG5hbWUgKTtcblx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgICAgIEZhY2VzOiAnICsgbnVtRmFjZXMgKTtcblxuXHRcdHZhciBpbmRleCA9IFtdO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bUZhY2VzOyArKyBpICkge1xuXG5cdFx0XHRpbmRleC5wdXNoKCB0aGlzLnJlYWRXb3JkKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7IG5hbWU6IG5hbWUsIGluZGV4OiBpbmRleCB9O1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgYSBjb2xvciB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkQ29sb3Jcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldy5cblx0ICogQHJldHVybiB7Q29sb3J9IENvbG9yIHZhbHVlIHJlYWQuLlxuXHQgKi9cblx0cmVhZENvbG9yOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdHZhciBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXG5cdFx0aWYgKCBjaHVuay5pZCA9PT0gQ09MT1JfMjQgfHwgY2h1bmsuaWQgPT09IExJTl9DT0xPUl8yNCApIHtcblxuXHRcdFx0dmFyIHIgPSB0aGlzLnJlYWRCeXRlKCBkYXRhICk7XG5cdFx0XHR2YXIgZyA9IHRoaXMucmVhZEJ5dGUoIGRhdGEgKTtcblx0XHRcdHZhciBiID0gdGhpcy5yZWFkQnl0ZSggZGF0YSApO1xuXG5cdFx0XHRjb2xvci5zZXRSR0IoIHIgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUgKTtcblxuXHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICAgICBDb2xvcjogJyArIGNvbG9yLnIgKyAnLCAnICsgY29sb3IuZyArICcsICcgKyBjb2xvci5iICk7XG5cblx0XHR9XHRlbHNlIGlmICggY2h1bmsuaWQgPT09IENPTE9SX0YgfHwgY2h1bmsuaWQgPT09IExJTl9DT0xPUl9GICkge1xuXG5cdFx0XHR2YXIgciA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHR2YXIgZyA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHR2YXIgYiA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cblx0XHRcdGNvbG9yLnNldFJHQiggciwgZywgYiApO1xuXG5cdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIENvbG9yOiAnICsgY29sb3IuciArICcsICcgKyBjb2xvci5nICsgJywgJyArIGNvbG9yLmIgKTtcblxuXHRcdH1cdGVsc2Uge1xuXG5cdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIFVua25vd24gY29sb3IgY2h1bms6ICcgKyBjaHVuay50b1N0cmluZyggMTYgKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5lbmRDaHVuayggY2h1bmsgKTtcblx0XHRyZXR1cm4gY29sb3I7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCBuZXh0IGNodW5rIG9mIGRhdGEuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZENodW5rXG5cdCAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGEgRGF0YXZpZXcuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ2h1bmsgb2YgZGF0YSByZWFkLlxuXHQgKi9cblx0cmVhZENodW5rOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgY2h1bmsgPSB7fTtcblxuXHRcdGNodW5rLmN1ciA9IHRoaXMucG9zaXRpb247XG5cdFx0Y2h1bmsuaWQgPSB0aGlzLnJlYWRXb3JkKCBkYXRhICk7XG5cdFx0Y2h1bmsuc2l6ZSA9IHRoaXMucmVhZERXb3JkKCBkYXRhICk7XG5cdFx0Y2h1bmsuZW5kID0gY2h1bmsuY3VyICsgY2h1bmsuc2l6ZTtcblx0XHRjaHVuay5jdXIgKz0gNjtcblxuXHRcdHJldHVybiBjaHVuaztcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjaHVuayBvZiBkYXRhLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGVuZENodW5rXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayBEYXRhIGNodW5rLlxuXHQgKi9cblx0ZW5kQ2h1bms6IGZ1bmN0aW9uICggY2h1bmsgKSB7XG5cblx0XHR0aGlzLnBvc2l0aW9uID0gY2h1bmsuZW5kO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIE1vdmUgdG8gdGhlIG5leHQgZGF0YSBjaHVuay5cblx0ICpcblx0ICogQG1ldGhvZCBuZXh0Q2h1bmtcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNodW5rIERhdGEgY2h1bmsuXG5cdCAqL1xuXHRuZXh0Q2h1bms6IGZ1bmN0aW9uICggZGF0YSwgY2h1bmsgKSB7XG5cblx0XHRpZiAoIGNodW5rLmN1ciA+PSBjaHVuay5lbmQgKSB7XG5cblx0XHRcdHJldHVybiAwO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5wb3NpdGlvbiA9IGNodW5rLmN1cjtcblxuXHRcdHRyeSB7XG5cblx0XHRcdHZhciBuZXh0ID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblx0XHRcdGNodW5rLmN1ciArPSBuZXh0LnNpemU7XG5cdFx0XHRyZXR1cm4gbmV4dC5pZDtcblxuXHRcdH1cdGNhdGNoICggZSApIHtcblxuXHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdVbmFibGUgdG8gcmVhZCBjaHVuayBhdCAnICsgdGhpcy5wb3NpdGlvbiApO1xuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVzZXQgZGF0YXZpZXcgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3LlxuXHQgKi9cblx0cmVzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5wb3NpdGlvbiAtPSA2O1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgYnl0ZSB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkQnl0ZVxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3IHRvIHJlYWQgZGF0YSBmcm9tLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IERhdGEgcmVhZCBmcm9tIHRoZSBkYXRhdmlldy5cblx0ICovXG5cdHJlYWRCeXRlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgdiA9IGRhdGEuZ2V0VWludDgoIHRoaXMucG9zaXRpb24sIHRydWUgKTtcblx0XHR0aGlzLnBvc2l0aW9uICs9IDE7XG5cdFx0cmV0dXJuIHY7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCAzMiBiaXQgZmxvYXQgdmFsdWUuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZEZsb2F0XG5cdCAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGEgRGF0YXZpZXcgdG8gcmVhZCBkYXRhIGZyb20uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gRGF0YSByZWFkIGZyb20gdGhlIGRhdGF2aWV3LlxuXHQgKi9cblx0cmVhZEZsb2F0OiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHR2YXIgdiA9IGRhdGEuZ2V0RmxvYXQzMiggdGhpcy5wb3NpdGlvbiwgdHJ1ZSApO1xuXHRcdFx0dGhpcy5wb3NpdGlvbiArPSA0O1xuXHRcdFx0cmV0dXJuIHY7XG5cblx0XHR9XHRjYXRjaCAoIGUgKSB7XG5cblx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCBlICsgJyAnICsgdGhpcy5wb3NpdGlvbiArICcgJyArIGRhdGEuYnl0ZUxlbmd0aCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgMzIgYml0IHNpZ25lZCBpbnRlZ2VyIHZhbHVlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRJbnRcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldyB0byByZWFkIGRhdGEgZnJvbS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBEYXRhIHJlYWQgZnJvbSB0aGUgZGF0YXZpZXcuXG5cdCAqL1xuXHRyZWFkSW50OiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgdiA9IGRhdGEuZ2V0SW50MzIoIHRoaXMucG9zaXRpb24sIHRydWUgKTtcblx0XHR0aGlzLnBvc2l0aW9uICs9IDQ7XG5cdFx0cmV0dXJuIHY7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCAxNiBiaXQgc2lnbmVkIGludGVnZXIgdmFsdWUuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZFNob3J0XG5cdCAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGEgRGF0YXZpZXcgdG8gcmVhZCBkYXRhIGZyb20uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gRGF0YSByZWFkIGZyb20gdGhlIGRhdGF2aWV3LlxuXHQgKi9cblx0cmVhZFNob3J0OiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgdiA9IGRhdGEuZ2V0SW50MTYoIHRoaXMucG9zaXRpb24sIHRydWUgKTtcblx0XHR0aGlzLnBvc2l0aW9uICs9IDI7XG5cdFx0cmV0dXJuIHY7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCA2NCBiaXQgdW5zaWduZWQgaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkRFdvcmRcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldyB0byByZWFkIGRhdGEgZnJvbS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBEYXRhIHJlYWQgZnJvbSB0aGUgZGF0YXZpZXcuXG5cdCAqL1xuXHRyZWFkRFdvcmQ6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdHZhciB2ID0gZGF0YS5nZXRVaW50MzIoIHRoaXMucG9zaXRpb24sIHRydWUgKTtcblx0XHR0aGlzLnBvc2l0aW9uICs9IDQ7XG5cdFx0cmV0dXJuIHY7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVhZCAzMiBiaXQgdW5zaWduZWQgaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkV29yZFxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3IHRvIHJlYWQgZGF0YSBmcm9tLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IERhdGEgcmVhZCBmcm9tIHRoZSBkYXRhdmlldy5cblx0ICovXG5cdHJlYWRXb3JkOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgdiA9IGRhdGEuZ2V0VWludDE2KCB0aGlzLnBvc2l0aW9uLCB0cnVlICk7XG5cdFx0dGhpcy5wb3NpdGlvbiArPSAyO1xuXHRcdHJldHVybiB2O1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlYWQgc3RyaW5nIHZhbHVlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRTdHJpbmdcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldyB0byByZWFkIGRhdGEgZnJvbS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heExlbmd0aCBNYXggc2l6ZSBvZiB0aGUgc3RyaW5nIHRvIGJlIHJlYWQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRGF0YSByZWFkIGZyb20gdGhlIGRhdGF2aWV3LlxuXHQgKi9cblx0cmVhZFN0cmluZzogZnVuY3Rpb24gKCBkYXRhLCBtYXhMZW5ndGggKSB7XG5cblx0XHR2YXIgcyA9ICcnO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgYyA9IHRoaXMucmVhZEJ5dGUoIGRhdGEgKTtcblx0XHRcdGlmICggISBjICkge1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHM7XG5cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHJlc291cmNlIHBhdGggdXNlZCB0byBkZXRlcm1pbmUgdGhlIGZpbGUgcGF0aCB0byBhdHRhY2hlZCByZXNvdXJjZXMuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0UGF0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHRvIHJlc291cmNlcy5cblx0ICogQHJldHVybiBTZWxmIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggcGF0aCApIHtcblxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQcmludCBkZWJ1ZyBtZXNzYWdlIHRvIHRoZSBjb25zb2xlLlxuXHQgKlxuXHQgKiBJcyBjb250cm9sbGVkIGJ5IGEgZmxhZyB0byBzaG93IG9yIGhpZGUgZGVidWcgbWVzc2FnZXMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZGVidWdNZXNzYWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIERlYnVnIG1lc3NhZ2UgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUuXG5cdCAqL1xuXHRkZWJ1Z01lc3NhZ2U6IGZ1bmN0aW9uICggbWVzc2FnZSApIHtcblxuXHRcdGlmICggdGhpcy5kZWJ1ZyApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coIG1lc3NhZ2UgKTtcblxuXHRcdH1cblxuXHR9XG59O1xuXG52YXIgTlVMTF9DSFVOSyA9IDB4MDAwMDtcbnZhciBNM0RNQUdJQyA9IDB4NEQ0RDtcbnZhciBTTUFHSUMgPSAweDJEMkQ7XG52YXIgTE1BR0lDID0gMHgyRDNEO1xudmFyIE1MSUJNQUdJQyA9IDB4M0RBQTtcbnZhciBNQVRNQUdJQyA9IDB4M0RGRjtcbnZhciBDTUFHSUMgPSAweEMyM0Q7XG52YXIgTTNEX1ZFUlNJT04gPSAweDAwMDI7XG52YXIgTTNEX0tGVkVSU0lPTiA9IDB4MDAwNTtcbnZhciBDT0xPUl9GID0gMHgwMDEwO1xudmFyIENPTE9SXzI0ID0gMHgwMDExO1xudmFyIExJTl9DT0xPUl8yNCA9IDB4MDAxMjtcbnZhciBMSU5fQ09MT1JfRiA9IDB4MDAxMztcbnZhciBJTlRfUEVSQ0VOVEFHRSA9IDB4MDAzMDtcbnZhciBGTE9BVF9QRVJDRU5UQUdFID0gMHgwMDMxO1xudmFyIE1EQVRBID0gMHgzRDNEO1xudmFyIE1FU0hfVkVSU0lPTiA9IDB4M0QzRTtcbnZhciBNQVNURVJfU0NBTEUgPSAweDAxMDA7XG52YXIgTE9fU0hBRE9XX0JJQVMgPSAweDE0MDA7XG52YXIgSElfU0hBRE9XX0JJQVMgPSAweDE0MTA7XG52YXIgU0hBRE9XX01BUF9TSVpFID0gMHgxNDIwO1xudmFyIFNIQURPV19TQU1QTEVTID0gMHgxNDMwO1xudmFyIFNIQURPV19SQU5HRSA9IDB4MTQ0MDtcbnZhciBTSEFET1dfRklMVEVSID0gMHgxNDUwO1xudmFyIFJBWV9CSUFTID0gMHgxNDYwO1xudmFyIE9fQ09OU1RTID0gMHgxNTAwO1xudmFyIEFNQklFTlRfTElHSFQgPSAweDIxMDA7XG52YXIgQklUX01BUCA9IDB4MTEwMDtcbnZhciBTT0xJRF9CR05EID0gMHgxMjAwO1xudmFyIFZfR1JBRElFTlQgPSAweDEzMDA7XG52YXIgVVNFX0JJVF9NQVAgPSAweDExMDE7XG52YXIgVVNFX1NPTElEX0JHTkQgPSAweDEyMDE7XG52YXIgVVNFX1ZfR1JBRElFTlQgPSAweDEzMDE7XG52YXIgRk9HID0gMHgyMjAwO1xudmFyIEZPR19CR05EID0gMHgyMjEwO1xudmFyIExBWUVSX0ZPRyA9IDB4MjMwMjtcbnZhciBESVNUQU5DRV9DVUUgPSAweDIzMDA7XG52YXIgRENVRV9CR05EID0gMHgyMzEwO1xudmFyIFVTRV9GT0cgPSAweDIyMDE7XG52YXIgVVNFX0xBWUVSX0ZPRyA9IDB4MjMwMztcbnZhciBVU0VfRElTVEFOQ0VfQ1VFID0gMHgyMzAxO1xudmFyIE1BVF9FTlRSWSA9IDB4QUZGRjtcbnZhciBNQVRfTkFNRSA9IDB4QTAwMDtcbnZhciBNQVRfQU1CSUVOVCA9IDB4QTAxMDtcbnZhciBNQVRfRElGRlVTRSA9IDB4QTAyMDtcbnZhciBNQVRfU1BFQ1VMQVIgPSAweEEwMzA7XG52YXIgTUFUX1NISU5JTkVTUyA9IDB4QTA0MDtcbnZhciBNQVRfU0hJTjJQQ1QgPSAweEEwNDE7XG52YXIgTUFUX1RSQU5TUEFSRU5DWSA9IDB4QTA1MDtcbnZhciBNQVRfWFBGQUxMID0gMHhBMDUyO1xudmFyIE1BVF9VU0VfWFBGQUxMID0gMHhBMjQwO1xudmFyIE1BVF9SRUZCTFVSID0gMHhBMDUzO1xudmFyIE1BVF9TSEFESU5HID0gMHhBMTAwO1xudmFyIE1BVF9VU0VfUkVGQkxVUiA9IDB4QTI1MDtcbnZhciBNQVRfU0VMRl9JTExVTSA9IDB4QTA4NDtcbnZhciBNQVRfVFdPX1NJREUgPSAweEEwODE7XG52YXIgTUFUX0RFQ0FMID0gMHhBMDgyO1xudmFyIE1BVF9BRERJVElWRSA9IDB4QTA4MztcbnZhciBNQVRfV0lSRSA9IDB4QTA4NTtcbnZhciBNQVRfRkFDRU1BUCA9IDB4QTA4ODtcbnZhciBNQVRfVFJBTlNGQUxMT0ZGX0lOID0gMHhBMDhBO1xudmFyIE1BVF9QSE9OR1NPRlQgPSAweEEwOEM7XG52YXIgTUFUX1dJUkVBQlMgPSAweEEwOEU7XG52YXIgTUFUX1dJUkVfU0laRSA9IDB4QTA4NztcbnZhciBNQVRfVEVYTUFQID0gMHhBMjAwO1xudmFyIE1BVF9TWFBfVEVYVF9EQVRBID0gMHhBMzIwO1xudmFyIE1BVF9URVhNQVNLID0gMHhBMzNFO1xudmFyIE1BVF9TWFBfVEVYVE1BU0tfREFUQSA9IDB4QTMyQTtcbnZhciBNQVRfVEVYMk1BUCA9IDB4QTMzQTtcbnZhciBNQVRfU1hQX1RFWFQyX0RBVEEgPSAweEEzMjE7XG52YXIgTUFUX1RFWDJNQVNLID0gMHhBMzQwO1xudmFyIE1BVF9TWFBfVEVYVDJNQVNLX0RBVEEgPSAweEEzMkM7XG52YXIgTUFUX09QQUNNQVAgPSAweEEyMTA7XG52YXIgTUFUX1NYUF9PUEFDX0RBVEEgPSAweEEzMjI7XG52YXIgTUFUX09QQUNNQVNLID0gMHhBMzQyO1xudmFyIE1BVF9TWFBfT1BBQ01BU0tfREFUQSA9IDB4QTMyRTtcbnZhciBNQVRfQlVNUE1BUCA9IDB4QTIzMDtcbnZhciBNQVRfU1hQX0JVTVBfREFUQSA9IDB4QTMyNDtcbnZhciBNQVRfQlVNUE1BU0sgPSAweEEzNDQ7XG52YXIgTUFUX1NYUF9CVU1QTUFTS19EQVRBID0gMHhBMzMwO1xudmFyIE1BVF9TUEVDTUFQID0gMHhBMjA0O1xudmFyIE1BVF9TWFBfU1BFQ19EQVRBID0gMHhBMzI1O1xudmFyIE1BVF9TUEVDTUFTSyA9IDB4QTM0ODtcbnZhciBNQVRfU1hQX1NQRUNNQVNLX0RBVEEgPSAweEEzMzI7XG52YXIgTUFUX1NISU5NQVAgPSAweEEzM0M7XG52YXIgTUFUX1NYUF9TSElOX0RBVEEgPSAweEEzMjY7XG52YXIgTUFUX1NISU5NQVNLID0gMHhBMzQ2O1xudmFyIE1BVF9TWFBfU0hJTk1BU0tfREFUQSA9IDB4QTMzNDtcbnZhciBNQVRfU0VMRklNQVAgPSAweEEzM0Q7XG52YXIgTUFUX1NYUF9TRUxGSV9EQVRBID0gMHhBMzI4O1xudmFyIE1BVF9TRUxGSU1BU0sgPSAweEEzNEE7XG52YXIgTUFUX1NYUF9TRUxGSU1BU0tfREFUQSA9IDB4QTMzNjtcbnZhciBNQVRfUkVGTE1BUCA9IDB4QTIyMDtcbnZhciBNQVRfUkVGTE1BU0sgPSAweEEzNEM7XG52YXIgTUFUX1NYUF9SRUZMTUFTS19EQVRBID0gMHhBMzM4O1xudmFyIE1BVF9BQ1VCSUMgPSAweEEzMTA7XG52YXIgTUFUX01BUE5BTUUgPSAweEEzMDA7XG52YXIgTUFUX01BUF9USUxJTkcgPSAweEEzNTE7XG52YXIgTUFUX01BUF9URVhCTFVSID0gMHhBMzUzO1xudmFyIE1BVF9NQVBfVVNDQUxFID0gMHhBMzU0O1xudmFyIE1BVF9NQVBfVlNDQUxFID0gMHhBMzU2O1xudmFyIE1BVF9NQVBfVU9GRlNFVCA9IDB4QTM1ODtcbnZhciBNQVRfTUFQX1ZPRkZTRVQgPSAweEEzNUE7XG52YXIgTUFUX01BUF9BTkcgPSAweEEzNUM7XG52YXIgTUFUX01BUF9DT0wxID0gMHhBMzYwO1xudmFyIE1BVF9NQVBfQ09MMiA9IDB4QTM2MjtcbnZhciBNQVRfTUFQX1JDT0wgPSAweEEzNjQ7XG52YXIgTUFUX01BUF9HQ09MID0gMHhBMzY2O1xudmFyIE1BVF9NQVBfQkNPTCA9IDB4QTM2ODtcbnZhciBOQU1FRF9PQkpFQ1QgPSAweDQwMDA7XG52YXIgTl9ESVJFQ1RfTElHSFQgPSAweDQ2MDA7XG52YXIgRExfT0ZGID0gMHg0NjIwO1xudmFyIERMX09VVEVSX1JBTkdFID0gMHg0NjVBO1xudmFyIERMX0lOTkVSX1JBTkdFID0gMHg0NjU5O1xudmFyIERMX01VTFRJUExJRVIgPSAweDQ2NUI7XG52YXIgRExfRVhDTFVERSA9IDB4NDY1NDtcbnZhciBETF9BVFRFTlVBVEUgPSAweDQ2MjU7XG52YXIgRExfU1BPVExJR0hUID0gMHg0NjEwO1xudmFyIERMX1NQT1RfUk9MTCA9IDB4NDY1NjtcbnZhciBETF9TSEFET1dFRCA9IDB4NDYzMDtcbnZhciBETF9MT0NBTF9TSEFET1cyID0gMHg0NjQxO1xudmFyIERMX1NFRV9DT05FID0gMHg0NjUwO1xudmFyIERMX1NQT1RfUkVDVEFOR1VMQVIgPSAweDQ2NTE7XG52YXIgRExfU1BPVF9BU1BFQ1QgPSAweDQ2NTc7XG52YXIgRExfU1BPVF9QUk9KRUNUT1IgPSAweDQ2NTM7XG52YXIgRExfU1BPVF9PVkVSU0hPT1QgPSAweDQ2NTI7XG52YXIgRExfUkFZX0JJQVMgPSAweDQ2NTg7XG52YXIgRExfUkFZU0hBRCA9IDB4NDYyNztcbnZhciBOX0NBTUVSQSA9IDB4NDcwMDtcbnZhciBDQU1fU0VFX0NPTkUgPSAweDQ3MTA7XG52YXIgQ0FNX1JBTkdFUyA9IDB4NDcyMDtcbnZhciBPQkpfSElEREVOID0gMHg0MDEwO1xudmFyIE9CSl9WSVNfTE9GVEVSID0gMHg0MDExO1xudmFyIE9CSl9ET0VTTlRfQ0FTVCA9IDB4NDAxMjtcbnZhciBPQkpfRE9OVF9SRUNWU0hBRE9XID0gMHg0MDE3O1xudmFyIE9CSl9NQVRURSA9IDB4NDAxMztcbnZhciBPQkpfRkFTVCA9IDB4NDAxNDtcbnZhciBPQkpfUFJPQ0VEVVJBTCA9IDB4NDAxNTtcbnZhciBPQkpfRlJPWkVOID0gMHg0MDE2O1xudmFyIE5fVFJJX09CSkVDVCA9IDB4NDEwMDtcbnZhciBQT0lOVF9BUlJBWSA9IDB4NDExMDtcbnZhciBQT0lOVF9GTEFHX0FSUkFZID0gMHg0MTExO1xudmFyIEZBQ0VfQVJSQVkgPSAweDQxMjA7XG52YXIgTVNIX01BVF9HUk9VUCA9IDB4NDEzMDtcbnZhciBTTU9PVEhfR1JPVVAgPSAweDQxNTA7XG52YXIgTVNIX0JPWE1BUCA9IDB4NDE5MDtcbnZhciBURVhfVkVSVFMgPSAweDQxNDA7XG52YXIgTUVTSF9NQVRSSVggPSAweDQxNjA7XG52YXIgTUVTSF9DT0xPUiA9IDB4NDE2NTtcbnZhciBNRVNIX1RFWFRVUkVfSU5GTyA9IDB4NDE3MDtcbnZhciBLRkRBVEEgPSAweEIwMDA7XG52YXIgS0ZIRFIgPSAweEIwMEE7XG52YXIgS0ZTRUcgPSAweEIwMDg7XG52YXIgS0ZDVVJUSU1FID0gMHhCMDA5O1xudmFyIEFNQklFTlRfTk9ERV9UQUcgPSAweEIwMDE7XG52YXIgT0JKRUNUX05PREVfVEFHID0gMHhCMDAyO1xudmFyIENBTUVSQV9OT0RFX1RBRyA9IDB4QjAwMztcbnZhciBUQVJHRVRfTk9ERV9UQUcgPSAweEIwMDQ7XG52YXIgTElHSFRfTk9ERV9UQUcgPSAweEIwMDU7XG52YXIgTF9UQVJHRVRfTk9ERV9UQUcgPSAweEIwMDY7XG52YXIgU1BPVExJR0hUX05PREVfVEFHID0gMHhCMDA3O1xudmFyIE5PREVfSUQgPSAweEIwMzA7XG52YXIgTk9ERV9IRFIgPSAweEIwMTA7XG52YXIgUElWT1QgPSAweEIwMTM7XG52YXIgSU5TVEFOQ0VfTkFNRSA9IDB4QjAxMTtcbnZhciBNT1JQSF9TTU9PVEggPSAweEIwMTU7XG52YXIgQk9VTkRCT1ggPSAweEIwMTQ7XG52YXIgUE9TX1RSQUNLX1RBRyA9IDB4QjAyMDtcbnZhciBDT0xfVFJBQ0tfVEFHID0gMHhCMDI1O1xudmFyIFJPVF9UUkFDS19UQUcgPSAweEIwMjE7XG52YXIgU0NMX1RSQUNLX1RBRyA9IDB4QjAyMjtcbnZhciBNT1JQSF9UUkFDS19UQUcgPSAweEIwMjY7XG52YXIgRk9WX1RSQUNLX1RBRyA9IDB4QjAyMztcbnZhciBST0xMX1RSQUNLX1RBRyA9IDB4QjAyNDtcbnZhciBIT1RfVFJBQ0tfVEFHID0gMHhCMDI3O1xudmFyIEZBTExfVFJBQ0tfVEFHID0gMHhCMDI4O1xudmFyIEhJREVfVFJBQ0tfVEFHID0gMHhCMDI5O1xudmFyIFBPTFlfMkQgPSAweDUwMDA7XG52YXIgU0hBUEVfT0sgPSAweDUwMTA7XG52YXIgU0hBUEVfTk9UX09LID0gMHg1MDExO1xudmFyIFNIQVBFX0hPT0sgPSAweDUwMjA7XG52YXIgUEFUSF8zRCA9IDB4NjAwMDtcbnZhciBQQVRIX01BVFJJWCA9IDB4NjAwNTtcbnZhciBTSEFQRV8yRCA9IDB4NjAxMDtcbnZhciBNX1NDQUxFID0gMHg2MDIwO1xudmFyIE1fVFdJU1QgPSAweDYwMzA7XG52YXIgTV9URUVURVIgPSAweDYwNDA7XG52YXIgTV9GSVQgPSAweDYwNTA7XG52YXIgTV9CRVZFTCA9IDB4NjA2MDtcbnZhciBYWl9DVVJWRSA9IDB4NjA3MDtcbnZhciBZWl9DVVJWRSA9IDB4NjA4MDtcbnZhciBJTlRFUlBDVCA9IDB4NjA5MDtcbnZhciBERUZPUk1fTElNSVQgPSAweDYwQTA7XG52YXIgVVNFX0NPTlRPVVIgPSAweDYxMDA7XG52YXIgVVNFX1RXRUVOID0gMHg2MTEwO1xudmFyIFVTRV9TQ0FMRSA9IDB4NjEyMDtcbnZhciBVU0VfVFdJU1QgPSAweDYxMzA7XG52YXIgVVNFX1RFRVRFUiA9IDB4NjE0MDtcbnZhciBVU0VfRklUID0gMHg2MTUwO1xudmFyIFVTRV9CRVZFTCA9IDB4NjE2MDtcbnZhciBERUZBVUxUX1ZJRVcgPSAweDMwMDA7XG52YXIgVklFV19UT1AgPSAweDMwMTA7XG52YXIgVklFV19CT1RUT00gPSAweDMwMjA7XG52YXIgVklFV19MRUZUID0gMHgzMDMwO1xudmFyIFZJRVdfUklHSFQgPSAweDMwNDA7XG52YXIgVklFV19GUk9OVCA9IDB4MzA1MDtcbnZhciBWSUVXX0JBQ0sgPSAweDMwNjA7XG52YXIgVklFV19VU0VSID0gMHgzMDcwO1xudmFyIFZJRVdfQ0FNRVJBID0gMHgzMDgwO1xudmFyIFZJRVdfV0lORE9XID0gMHgzMDkwO1xudmFyIFZJRVdQT1JUX0xBWU9VVF9PTEQgPSAweDcwMDA7XG52YXIgVklFV1BPUlRfREFUQV9PTEQgPSAweDcwMTA7XG52YXIgVklFV1BPUlRfTEFZT1VUID0gMHg3MDAxO1xudmFyIFZJRVdQT1JUX0RBVEEgPSAweDcwMTE7XG52YXIgVklFV1BPUlRfREFUQV8zID0gMHg3MDEyO1xudmFyIFZJRVdQT1JUX1NJWkUgPSAweDcwMjA7XG52YXIgTkVUV09SS19WSUVXID0gMHg3MDMwO1xuXG5leHBvcnQgZGVmYXVsdCBUSFJFRS5URFNMb2FkZXI7XG4iLCJpbXBvcnQgQ2FyIGZyb20gXCIuLi9waHlzaWNzL0Nhci5qc1wiO1xuaW1wb3J0IFREU0xvYWRlciBmcm9tIFwiLi9URFNMb2FkZXIuanNcIjtcbmltcG9ydCBzdXZNb2RlbCBmcm9tIFwiLi4vLi4vbW9kZWxzL3dqai5qc1wiO1xuXG5jb25zdCBDQVJfQ09MT1IgPSAweDAwODhmZjtcbmNvbnN0IFdIRUVMX0NPTE9SID0gMHhmZjg4MDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhck9iamVjdCBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcbiAgY29uc3RydWN0b3IoY2FyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2FyID0gY2FyO1xuXG4gICAgdGhpcy5idWlsZENhcjJEKCk7XG4gICAgdGhpcy5idWlsZENhcjNEKCk7XG4gIH1cblxuICBidWlsZENhcjJEKCkge1xuICAgIGNvbnN0IGNhck1lc2ggPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KENhci5IQUxGX0NBUl9MRU5HVEggKiAyLCBDYXIuSEFMRl9DQVJfV0lEVEggKiAyKSxcbiAgICAgIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBDQVJfQ09MT1IsIGRlcHRoVGVzdDogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjcgfSlcbiAgICApO1xuICAgIGNhck1lc2gucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgICBjYXJNZXNoLmxheWVycy5zZXQoMik7XG4gICAgdGhpcy5hZGQoY2FyTWVzaCk7XG5cbiAgICBjb25zdCB3aGVlbEdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoQ2FyLkhBTEZfV0hFRUxfTEVOR1RIICogMiwgQ2FyLkhBTEZfV0hFRUxfV0lEVEggKiAyKTtcbiAgICBjb25zdCB3aGVlbE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IFdIRUVMX0NPTE9SLCBkZXB0aFRlc3Q6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC43IH0pXG5cbiAgICB0aGlzLmxmV2hlZWwyRCA9IG5ldyBUSFJFRS5NZXNoKHdoZWVsR2VvbWV0cnksIHdoZWVsTWF0ZXJpYWwpO1xuICAgIHRoaXMubGZXaGVlbDJELnJlbmRlck9yZGVyID0gMTtcbiAgICB0aGlzLmxmV2hlZWwyRC5wb3NpdGlvbi5zZXQoQ2FyLkZST05UX0FYTEVfUE9TLCAwLCBDYXIuV0hFRUxfTEFURVJBTF9QT1MpO1xuICAgIHRoaXMubGZXaGVlbDJELnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gICAgdGhpcy5sZldoZWVsMkQubGF5ZXJzLnNldCgyKTtcbiAgICB0aGlzLmFkZCh0aGlzLmxmV2hlZWwyRCk7XG5cbiAgICB0aGlzLnJmV2hlZWwyRCA9IG5ldyBUSFJFRS5NZXNoKHdoZWVsR2VvbWV0cnksIHdoZWVsTWF0ZXJpYWwpO1xuICAgIHRoaXMucmZXaGVlbDJELnJlbmRlck9yZGVyID0gMTtcbiAgICB0aGlzLnJmV2hlZWwyRC5wb3NpdGlvbi5zZXQoQ2FyLkZST05UX0FYTEVfUE9TLCAwLCAtQ2FyLldIRUVMX0xBVEVSQUxfUE9TKTtcbiAgICB0aGlzLnJmV2hlZWwyRC5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICAgIHRoaXMucmZXaGVlbDJELmxheWVycy5zZXQoMik7XG4gICAgdGhpcy5hZGQodGhpcy5yZldoZWVsMkQpO1xuXG4gICAgY29uc3QgbHJXaGVlbCA9IG5ldyBUSFJFRS5NZXNoKHdoZWVsR2VvbWV0cnksIHdoZWVsTWF0ZXJpYWwpO1xuICAgIGxyV2hlZWwucmVuZGVyT3JkZXIgPSAxO1xuICAgIGxyV2hlZWwucG9zaXRpb24uc2V0KENhci5SRUFSX0FYTEVfUE9TLCAwLCBDYXIuV0hFRUxfTEFURVJBTF9QT1MpO1xuICAgIGxyV2hlZWwucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgICBscldoZWVsLmxheWVycy5zZXQoMik7XG4gICAgdGhpcy5hZGQobHJXaGVlbCk7XG5cbiAgICBjb25zdCBycldoZWVsID0gbmV3IFRIUkVFLk1lc2god2hlZWxHZW9tZXRyeSwgd2hlZWxNYXRlcmlhbCk7XG4gICAgcnJXaGVlbC5yZW5kZXJPcmRlciA9IDE7XG4gICAgcnJXaGVlbC5wb3NpdGlvbi5zZXQoQ2FyLlJFQVJfQVhMRV9QT1MsIDAsIC1DYXIuV0hFRUxfTEFURVJBTF9QT1MpO1xuICAgIHJyV2hlZWwucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgICBycldoZWVsLmxheWVycy5zZXQoMik7XG4gICAgdGhpcy5hZGQocnJXaGVlbCk7XG4gIH1cblxuICBidWlsZENhcjNEKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBURFNMb2FkZXIoKTtcbiAgICBsb2FkZXIuc2tpcE1hcHMgPSB0cnVlO1xuXG4gICAgbG9hZGVyLmxvYWQoc3V2TW9kZWwsIG9iamVjdCA9PiB7XG4gICAgICBvYmplY3QubGF5ZXJzLnNldCgzKTtcbiAgICAgIG9iamVjdC5yb3RhdGlvbi56ID0gTWF0aC5QSSAvIDI7XG4gICAgICBvYmplY3Qucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcblxuICAgICAgY29uc3QgYm94ID0gKG5ldyBUSFJFRS5Cb3gzKCkpLnNldEZyb21PYmplY3Qob2JqZWN0KTtcbiAgICAgIGNvbnN0IHNjYWxlTGVuZ3RoID0gQ2FyLkhBTEZfQ0FSX0xFTkdUSCAqIDIgLyAoYm94Lm1heC54IC0gYm94Lm1pbi54KTtcbiAgICAgIGNvbnN0IHNjYWxlV2lkdGggPSBDYXIuSEFMRl9DQVJfV0lEVEggKiAyIC8gKGJveC5tYXgueiAtIGJveC5taW4ueik7XG4gICAgICBvYmplY3Quc2NhbGUuc2V0KHNjYWxlV2lkdGgsIHNjYWxlTGVuZ3RoLCAoc2NhbGVXaWR0aCArIHNjYWxlTGVuZ3RoKSAvIDIpO1xuXG4gICAgICBib3guc2V0RnJvbU9iamVjdChvYmplY3QpO1xuICAgICAgb2JqZWN0LnBvc2l0aW9uLnNldFgoLShib3gubWF4LnggKyBib3gubWluLngpIC8gMik7XG4gICAgICBvYmplY3QucG9zaXRpb24uc2V0WSgtYm94Lm1pbi55KTtcblxuICAgICAgdGhpcy5hZGQob2JqZWN0KTtcblxuICAgICAgY29uc3QgY2FyTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFRvb25NYXRlcmlhbCh7IGNvbG9yOiAweDAwODhmZiB9KTtcbiAgICAgIGNvbnN0IHdoZWVsTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFRvb25NYXRlcmlhbCh7IGNvbG9yOiAweGZmODgwMCB9KTtcblxuICAgICAgb2JqZWN0LnRyYXZlcnNlKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmxheWVycy5zZXQoMyk7XG4gICAgICAgICAgY2hpbGQubWF0ZXJpYWwgPSBbJ1RveW90YV9SQTcnLCAnVG95b3RhX1JBOCcsICdUb3lvdGFfUkE5JywgJ1RveW90YV9SMTAnXS5pbmNsdWRlcyhjaGlsZC5uYW1lKSA/IHdoZWVsTWF0ZXJpYWwgOiBjYXJNYXRlcmlhbDtcblxuICAgICAgICAgIGlmIChjaGlsZC5uYW1lID09ICdUb3lvdGFfUkE3JylcbiAgICAgICAgICAgIHRoaXMubGZXaGVlbDNEID0gY2hpbGQ7XG4gICAgICAgICAgZWxzZSBpZiAoY2hpbGQubmFtZSA9PSAnVG95b3RhX1JBOCcpXG4gICAgICAgICAgICB0aGlzLnJmV2hlZWwzRCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgW3RoaXMubGZXaGVlbDNELCB0aGlzLnJmV2hlZWwzRF0uZm9yRWFjaCh3aGVlbCA9PiB7XG4gICAgICAgIHdoZWVsLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgICB3aGVlbC5nZW9tZXRyeS5jZW50ZXIoKTtcbiAgICAgICAgd2hlZWwucG9zaXRpb24uc2V0WSh3aGVlbC5wb3NpdGlvbi55IC0gMzYpO1xuICAgICAgICB3aGVlbC5wb3NpdGlvbi5zZXRaKHdoZWVsLnBvc2l0aW9uLnogKyAzNik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICB0aGlzLnVwZGF0ZUNhcigpO1xuICAgIHN1cGVyLnVwZGF0ZU1hdHJpeCgpO1xuICB9XG5cbiAgdXBkYXRlQ2FyKCkge1xuICAgIGNvbnN0IGNhclBvc2l0aW9uID0gdGhpcy5jYXIucG9zaXRpb247XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoY2FyUG9zaXRpb24ueCwgMCwgY2FyUG9zaXRpb24ueSk7XG4gICAgdGhpcy5yb3RhdGlvbi55ID0gLXRoaXMuY2FyLnJvdGF0aW9uO1xuXG4gICAgY29uc3Qgd2hlZWxBbmdsZSA9IHRoaXMuY2FyLndoZWVsQW5nbGU7XG5cbiAgICAvLyBBZGRpbmcgdGhlIHdoZWVscyB0byB0aGUgY2FyIG9iamVjdCBjYW4gdHJpZ2dlciB0aGlzIGZ1bmN0aW9uIGluIHNvbWUgYnJvd3NlcnNcbiAgICAvLyBiZWZvcmUgdGhlIG90aGVyIHdoZWVscyBhcmUgYWRkZWQsIHNvIGNoZWNrIHRoZW0gZmlyc3QuXG4gICAgaWYgKHRoaXMubGZXaGVlbDJEKSB0aGlzLmxmV2hlZWwyRC5yb3RhdGlvbi56ID0gLXdoZWVsQW5nbGU7XG4gICAgaWYgKHRoaXMucmZXaGVlbDJEKSB0aGlzLnJmV2hlZWwyRC5yb3RhdGlvbi56ID0gLXdoZWVsQW5nbGU7XG4gICAgaWYgKHRoaXMubGZXaGVlbDNEKSB0aGlzLmxmV2hlZWwzRC5yb3RhdGlvbi55ID0gd2hlZWxBbmdsZTtcbiAgICBpZiAodGhpcy5yZldoZWVsM0QpIHRoaXMucmZXaGVlbDNELnJvdGF0aW9uLnkgPSB3aGVlbEFuZ2xlO1xuICB9XG59XG4iLCJjb25zdCBDT0xPUiA9IDB4ZGQwMDAwO1xuY29uc3QgSEVJR0hUID0gNTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGljT2JzdGFjbGVPYmplY3QgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKHN0YXRpY09ic3RhY2xlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IG1lc2gyRCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoc3RhdGljT2JzdGFjbGUud2lkdGgsIHN0YXRpY09ic3RhY2xlLmhlaWdodCksXG4gICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogQ09MT1IsIGRlcHRoVGVzdDogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjUgfSlcbiAgICApO1xuICAgIG1lc2gyRC5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICAgIG1lc2gyRC5sYXllcnMuc2V0KDIpO1xuICAgIHRoaXMuYWRkKG1lc2gyRCk7XG5cbiAgICBjb25zdCBtZXNoM0QgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5Cb3hCdWZmZXJHZW9tZXRyeShzdGF0aWNPYnN0YWNsZS53aWR0aCwgSEVJR0hULCBzdGF0aWNPYnN0YWNsZS5oZWlnaHQpLFxuICAgICAgbmV3IFRIUkVFLk1lc2hUb29uTWF0ZXJpYWwoeyBjb2xvcjogQ09MT1IsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjUgfSlcbiAgICApO1xuICAgIG1lc2gzRC5wb3NpdGlvbi5zZXRZKEhFSUdIVCAvIDIpO1xuICAgIG1lc2gzRC5sYXllcnMuc2V0KDMpO1xuICAgIHRoaXMuYWRkKG1lc2gzRCk7XG5cbiAgICB0aGlzLnJvdGF0aW9uLnkgPSAtc3RhdGljT2JzdGFjbGUucm90O1xuICAgIHRoaXMucG9zaXRpb24uc2V0KHN0YXRpY09ic3RhY2xlLnBvcy54LCAwLCBzdGF0aWNPYnN0YWNsZS5wb3MueSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNPYnN0YWNsZU9iamVjdCBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcbiAgY29uc3RydWN0b3IoZHluYW1pY09ic3RhY2xlLCBsYW5lUGF0aCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmR5bmFtaWNPYnN0YWNsZSA9IGR5bmFtaWNPYnN0YWNsZTtcbiAgICB0aGlzLmxhbmVQYXRoID0gbGFuZVBhdGg7XG5cbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICB2ZWhpY2xlOiAweGZmODgwMCwgIC8vMHhmZjg4MDBcbiAgICAgIGN5Y2xpc3Q6IDB4MDBjY2ZmLFxuICAgICAgcGVkZXN0cmlhbjogMHhmZmRkMDBcbiAgICB9O1xuXG4gICAgY29uc3QgaGVpZ2h0cyA9IHtcbiAgICAgIHZlaGljbGU6IDIuMCxcbiAgICAgIGN5Y2xpc3Q6IDEuOCxcbiAgICAgIHBlZGVzdHJpYW46IDEuOFxuICAgIH07XG5cbiAgICBjb25zdCBtZXNoMkQgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KGR5bmFtaWNPYnN0YWNsZS5zaXplLncgKiAyLCBkeW5hbWljT2JzdGFjbGUuc2l6ZS5oICogMiksXG4gICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogY29sb3JzW2R5bmFtaWNPYnN0YWNsZS50eXBlXSB8fCAweGZmODgwMCwgZGVwdGhUZXN0OiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNyB9KVxuICAgICk7XG4gICAgbWVzaDJELnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gICAgbWVzaDJELmxheWVycy5zZXQoMik7XG4gICAgdGhpcy5hZGQobWVzaDJEKTtcblxuICAgIGNvbnN0IG1lc2gzRCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgbmV3IFRIUkVFLkJveEJ1ZmZlckdlb21ldHJ5KGR5bmFtaWNPYnN0YWNsZS5zaXplLncgKiAyLCBoZWlnaHRzW2R5bmFtaWNPYnN0YWNsZS50eXBlXSB8fCAxLjUsIGR5bmFtaWNPYnN0YWNsZS5zaXplLmggKiAyKSxcbiAgICAgIG5ldyBUSFJFRS5NZXNoVG9vbk1hdGVyaWFsKHsgY29sb3I6IGNvbG9yc1tkeW5hbWljT2JzdGFjbGUudHlwZV0gfHwgMHhmZjg4MDAsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjcgfSlcbiAgICApO1xuICAgIG1lc2gzRC5wb3NpdGlvbi5zZXRZKChoZWlnaHRzW2R5bmFtaWNPYnN0YWNsZS50eXBlXSB8fCAxLjUpIC8gMik7XG4gICAgbWVzaDNELmxheWVycy5zZXQoMyk7XG4gICAgdGhpcy5hZGQobWVzaDNEKTtcbiAgfVxuXG4gIHVwZGF0ZSh0aW1lKSB7XG4gICAgY29uc3Qgc2xQb3MgPSB0aGlzLmR5bmFtaWNPYnN0YWNsZS5wb3NpdGlvbkF0VGltZSh0aW1lKTtcblxuICAgIC8vIFNhbXBsZSBqdXN0IHRoZSBzdGF0aW9uIHRoaXMgZHluYW1pYyBvYnN0YWNsZSBpcyBhdFxuICAgIGNvbnN0IFtzYW1wbGVdID0gdGhpcy5sYW5lUGF0aC5zYW1wbGVTdGF0aW9ucyhzbFBvcy54LCAxLCAwKTtcblxuICAgIGlmIChzYW1wbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgcm90ID0gc2FtcGxlLnJvdDtcbiAgICBjb25zdCBwb3MgPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QgKyBNYXRoLlBJIC8gMikubXVsdGlwbHlTY2FsYXIoc2xQb3MueSkuYWRkKHNhbXBsZS5wb3MpO1xuXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQocG9zLngsIDAsIHBvcy55KTtcbiAgICB0aGlzLnJvdGF0aW9uLnkgPSAtcm90O1xuXG4gICAgc3VwZXIudXBkYXRlTWF0cml4KCk7XG5cbiAgICB0aGlzLnZpc2libGUgPSBzbFBvcy54ID49IDA7XG4gIH1cbn1cbiIsImltcG9ydCBDYXIgZnJvbSBcIi4uL3BoeXNpY3MvQ2FyLmpzXCI7XG5cbmNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZID0gJ2Rhc2hfUGF0aFBsYW5uZXJDb25maWcnO1xuXG5jb25zdCBpbnRlcm5hbENvbmZpZyA9IHtcbiAgbGF0dGljZToge1xuICAgIG51bVN0YXRpb25zOiA4LFxuICAgIG51bUxhdGl0dWRlczogMTcsXG4gICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogMyxcbiAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogN1xuICB9LFxuXG4gIHJvYWRXaWR0aDogMy43ICogMiwgLy8gbWV0ZXJzXG5cbiAgbnVtRHluYW1pY0ZyYW1lczogMjAsXG4gIG51bUR5bmFtaWNTdWJmcmFtZXM6IDQsXG5cbiAgZEN1cnZhdHVyZU1heDogQ2FyLk1BWF9TVEVFUl9TUEVFRCAvIENhci5XSEVFTF9CQVNFLFxuICByZWFyQXhsZVRvQ2VudGVyOiAtQ2FyLlJFQVJfQVhMRV9QT1Ncbn07XG5cbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gIFxuICAvLyAgc3BhdGlhbEhvcml6b246IDEyMCwgLy8gbWV0ZXJzXG4gIC8vIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IDAuNSwgLy8gbWV0ZXJzXG5cbiAgLy8geHlHcmlkQ2VsbFNpemU6IDAuMywgLy8gbWV0ZXJzXG4gIC8vIHNsR3JpZENlbGxTaXplOiAwLjE1LCAvLyBtZXRlcnNcbiAgLy8gZ3JpZE1hcmdpbjogMjAsIC8vIG1ldGVyc1xuICAvLyBwYXRoU2FtcGxpbmdTdGVwOiAxLCAvLyBtZXRlcnNcblxuICAvLyBjdWJpY1BhdGhQZW5hbHR5OiAwLFxuXG4gIC8vIGNvbGxpc2lvbkRpbGF0aW9uUzogQ2FyLkhBTEZfQ0FSX0xFTkdUSCArIDIsIC8vIG1ldGVyc1xuICAvLyBoYXphcmREaWxhdGlvblM6IDgsIC8vIG1ldGVyc1xuICAvLyBjb2xsaXNpb25EaWxhdGlvbkw6IENhci5IQUxGX0NBUl9XSURUSCArIDAuNSwgLy9tZXRlcnNcbiAgLy8gaGF6YXJkRGlsYXRpb25MOiAwLjUsIC8vIG1ldGVyc1xuXG4gIC8vIGR5bmFtaWNIYXphcmREaWxhdGlvblM6IDE2LFxuICAvLyBkeW5hbWljSGF6YXJkRGlsYXRpb25MOiAwLjUsXG5cbiAgLy8gb2JzdGFjbGVIYXphcmRDb3N0OiAyMDAsXG5cbiAgLy8gbGFuZUNlbnRlckxhdGl0dWRlOiBpbnRlcm5hbENvbmZpZy5yb2FkV2lkdGggLyA0LFxuICAvLyBsYW5lU2hvdWxkZXJMYXRpdHVkZTogaW50ZXJuYWxDb25maWcucm9hZFdpZHRoIC8gMiAqIDEuMSAtIENhci5IQUxGX0NBUl9XSURUSCxcbiAgLy8gbGFuZUNvc3RTbG9wZTogMjAsIC8vIGNvc3QgLyBtZXRlclxuICAvLyBsYW5lUHJlZmVyZW5jZURpc2NvdW50OiA1NSxcblxuICAvLyBzdGF0aW9uUmVhY2hEaXNjb3VudDogNDAwLFxuICAvLyBleHRyYVRpbWVQZW5hbHR5OiAxMDAwLFxuXG4gIC8vIGh5c3RlcmVzaXNEaXNjb3VudDogNTAsXG5cbiAgLy8gc3BlZWRMaW1pdFBlbmFsdHk6IDIwMCxcblxuICAvLyBoYXJkQWNjZWxlcmF0aW9uUGVuYWx0eTogNzAsXG4gIC8vIGhhcmREZWNlbGVyYXRpb25QZW5hbHR5OiA1MCxcblxuICAvLyBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0OiA0LCAvLyBtL3NeMlxuICAvLyBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IDEwMCxcbiAgLy8gbGluZWFyTGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IDEwLFxuXG4gIC8vIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IDEwLFxuICB45pa55ZCR5pyA5aSn57q/6YCf5bqmOiAwLjMsXG4gIHjmlrnlkJHmnIDlsI/nur/pgJ/luqY6IDAsXG4gIOacgOWkp+aXi+i9rOinkumAn+W6pjogMC4yLFxuICDmnIDlsI/ml4vovazop5LpgJ/luqY6MCxcblxuICB45pa55ZCR55qE5p6B6ZmQ5Yqg6YCf5bqmOjAuMSxcbiAg5p6B6ZmQ5peL6L2s5Yqg6YCf5bqmOjAuMSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhQbGFubmVyQ29uZmlnRWRpdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyk7XG5cbiAgICB0aGlzLnNob3dDb25maWdCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1jb25maWctYm94Jyk7XG4gICAgdGhpcy5jb25maWdCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZmlnLWJveC1jb250ZW50Jyk7XG4gICAgdGhpcy5jb25maWdGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpZy1mb3JtJyk7XG5cbiAgICB0aGlzLl9zZXRVcEJ1dHRvbnMoKTtcblxuICAgIGxldCBzdG9yZWRDb25maWcgPSB7fTtcbiAgICB0cnkge1xuICAgICAgc3RvcmVkQ29uZmlnID0gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpKSB8fCB7fTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5fY29uZmlnKS5zb3J0KCkpIHtcbiAgICAgIGlmIChzdG9yZWRDb25maWdba2V5XSAhPT0gdW5kZWZpbmVkKSB0aGlzLl9jb25maWdba2V5XSA9IHN0b3JlZENvbmZpZ1trZXldO1xuICAgICAgdGhpcy5jb25maWdGb3JtLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUNvbmZpZ0ZpZWxkKGtleSwgdGhpcy5fY29uZmlnW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9jb25maWcsIGludGVybmFsQ29uZmlnKTtcbiAgfVxuXG4gIF9zZXRVcEJ1dHRvbnMoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nob3ctY29uZmlnLWJ1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICB0aGlzLnNob3dDb25maWdCb3guY2xhc3NMaXN0LmFkZCgnaXMtaGlkZGVuJyk7XG4gICAgICB0aGlzLmNvbmZpZ0JveC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoaWRlLWNvbmZpZy1idXR0b24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgdGhpcy5zaG93Q29uZmlnQm94LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICAgICAgdGhpcy5jb25maWdCb3guY2xhc3NMaXN0LmFkZCgnaXMtaGlkZGVuJyk7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2F2ZS1jb25maWctYnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9zYXZlQ29uZmlnRmllbGRzLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN0b3JlLWRlZmF1bHRzLWNvbmZpZy1idXR0b24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX3Jlc3RvcmVEZWZhdWx0cy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDb25maWdGaWVsZChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgaHRtbCA9XG4gICAgICBgPGRpdiBjbGFzcz1cImZpZWxkIGlzLWhvcml6b250YWxcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQtbGFiZWwgaXMtc21hbGxcIiBzdHlsZT1cImZsZXgtZ3JvdzogMTAwO1wiPlxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbCBoYXMtdGV4dC1ncmV5LWxpZ2h0XCIgZm9yPVwiY29uZmlnLWZpZWxkLSR7a2V5fVwiPiR7a2V5fTwvbGFiZWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkLWJvZHlcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxNnB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cImNvbmZpZy1maWVsZC0ke2tleX1cIiBuYW1lPVwiJHtrZXl9XCIgY2xhc3M9XCJpbnB1dCBpcy1zbWFsbCAke3ZhbHVlICE9PSBkZWZhdWx0Q29uZmlnW2tleV0gPyAnaXMtZGFuZ2VyJyA6ICcnfVwiIHR5cGU9XCJ0ZXh0XCIgc3R5bGU9XCJ3aWR0aDogNjBweDsgYm9yZGVyLXdpZHRoOiAycHg7XCIgdmFsdWU9XCIke3ZhbHVlfVwiIC8+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIF9zYXZlQ29uZmlnRmllbGRzKCkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRoaXMuY29uZmlnRm9ybSk7XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gTnVtYmVyLnBhcnNlRmxvYXQodik7XG4gICAgICB0aGlzLl9jb25maWdba10gPSBwYXJzZWRWYWx1ZVxuXG4gICAgICBjb25zdCBmaWVsZERvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBjb25maWctZmllbGQtJHtrfWApO1xuICAgICAgaWYgKHBhcnNlZFZhbHVlID09PSBkZWZhdWx0Q29uZmlnW2tdKVxuICAgICAgICBmaWVsZERvbS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kYW5nZXInKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZmllbGREb20uY2xhc3NMaXN0LmFkZCgnaXMtZGFuZ2VyJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodGhpcy5fY29uZmlnKSk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIF9yZXN0b3JlRGVmYXVsdHMoKSB7XG4gICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyk7XG5cbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKExPQ0FMX1NUT1JBR0VfS0VZKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgd2hpbGUgKHRoaXMuY29uZmlnRm9ybS5maXJzdENoaWxkKVxuICAgICAgdGhpcy5jb25maWdGb3JtLnJlbW92ZUNoaWxkKHRoaXMuY29uZmlnRm9ybS5maXJzdENoaWxkKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX2NvbmZpZykuc29ydCgpKVxuICAgICAgdGhpcy5jb25maWdGb3JtLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUNvbmZpZ0ZpZWxkKGtleSwgdGhpcy5fY29uZmlnW2tleV0pKTtcbiAgfVxufVxuXG5QYXRoUGxhbm5lckNvbmZpZ0VkaXRvci5pbnRlcm5hbENvbmZpZyA9IGludGVybmFsQ29uZmlnO1xuIiwiaW1wb3J0IER5bmFtaWNPYnN0YWNsZSBmcm9tIFwiLi4vYXV0b25vbXkvRHluYW1pY09ic3RhY2xlLmpzXCI7XG5pbXBvcnQgUGF0aFBsYW5uZXJDb25maWdFZGl0b3IgZnJvbSBcIi4vUGF0aFBsYW5uZXJDb25maWdFZGl0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHluYW1pY09ic3RhY2xlRWRpdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lZGl0b3JEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWR5bmFtaWMtb2JzdGFjbGVzLWJveCcpO1xuICAgIHRoaXMuZm9ybXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWR5bmFtaWMtb2JzdGFjbGUtZm9ybXMnKTtcbiAgICB0aGlzLnN0YXRzRHluYW1pY09ic3RhY2xlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3Itc3RhdHMtZHluYW1pYy1vYnN0YWNsZXMnKTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItYWRkLWR5bmFtaWMtb2JzdGFjbGUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuYWRkRHluYW1pY09ic3RhY2xlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZWRpdG9yRG9tLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVkaXRvckRvbS5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBmb3JtcyA9IHRoaXMuZm9ybXNDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvcm0nKTtcbiAgICBjb25zdCBvYnN0YWNsZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm1zW2ldKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHsgcGFyYWxsZWw6IGZhbHNlIH07XG5cbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSlcbiAgICAgICAgcGFyYW1zW2tdID0gdjtcblxuICAgICAgbGV0IHR5cGUgPSAwO1xuICAgICAgaWYgKHBhcmFtcy50eXBlID09ICdjeWNsaXN0JylcbiAgICAgICAgdHlwZSA9IDE7XG4gICAgICBlbHNlIGlmIChwYXJhbXMudHlwZSA9PSAncGVkZXN0cmlhbicpXG4gICAgICAgIHR5cGUgPSAyO1xuXG4gICAgICBvYnN0YWNsZXMucHVzaCh7XG4gICAgICAgIHA6IFtwYXJhbXMuc1BvcywgcGFyYW1zLmxQb3NdLFxuICAgICAgICB2OiBbcGFyYW1zLnNWZWwsIHBhcmFtcy5sVmVsXSxcbiAgICAgICAgbDogISFwYXJhbXMucGFyYWxsZWwgPyAxIDogMCxcbiAgICAgICAgdDogdHlwZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic3RhY2xlcztcbiAgfVxuXG4gIGxvYWRKU09OKGpzb24pIHtcbiAgICB0aGlzLmNsZWFyRHluYW1pY09ic3RhY2xlcygpO1xuXG4gICAganNvbi5mb3JFYWNoKG8gPT4ge1xuICAgICAgY29uc3QgZm9ybSA9IHRoaXMuYWRkRHluYW1pY09ic3RhY2xlKCk7XG5cbiAgICAgIGZvcm1bJ3NQb3MnXS52YWx1ZSA9IG8ucFswXTtcbiAgICAgIGZvcm1bJ2xQb3MnXS52YWx1ZSA9IG8ucFsxXTtcbiAgICAgIGZvcm1bJ3NWZWwnXS52YWx1ZSA9IG8udlswXTtcbiAgICAgIGZvcm1bJ2xWZWwnXS52YWx1ZSA9IG8udlsxXTtcbiAgICAgIGZvcm1bJ3BhcmFsbGVsJ10uY2hlY2tlZCA9ICEhby5sO1xuICAgICAgZm9ybVsndHlwZSddLnNlbGVjdGVkSW5kZXggPSBvLnQ7XG4gICAgfSk7XG4gIH1cblxuICBjb2xsZWN0RHluYW1pY09ic3RhY2xlcygpIHtcbiAgICBjb25zdCBmb3JtcyA9IHRoaXMuZm9ybXNDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvcm0nKTtcbiAgICBjb25zdCBvYnN0YWNsZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm1zW2ldKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHsgcGFyYWxsZWw6IGZhbHNlIH07XG5cbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSlcbiAgICAgICAgcGFyYW1zW2tdID0gdjtcblxuICAgICAgY29uc3QgcG9zID0gbmV3IFRIUkVFLlZlY3RvcjIoTnVtYmVyKHBhcmFtcy5zUG9zKSB8fCAwLCAoTnVtYmVyKHBhcmFtcy5sUG9zKSB8fCAwKSAqIFBhdGhQbGFubmVyQ29uZmlnRWRpdG9yLmludGVybmFsQ29uZmlnLnJvYWRXaWR0aCAvIDIpO1xuICAgICAgY29uc3QgdmVsID0gbmV3IFRIUkVFLlZlY3RvcjIoTnVtYmVyKHBhcmFtcy5zVmVsKSB8fCAwLCBOdW1iZXIocGFyYW1zLmxWZWwpIHx8IDApO1xuICAgICAgY29uc3QgcGFyYWxsZWwgPSAhIXBhcmFtcy5wYXJhbGxlbDtcblxuICAgICAgb2JzdGFjbGVzLnB1c2gobmV3IER5bmFtaWNPYnN0YWNsZShwYXJhbXMudHlwZSwgcG9zLCB2ZWwsIHBhcmFsbGVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic3RhY2xlcztcbiAgfVxuXG4gIGFkZER5bmFtaWNPYnN0YWNsZSgpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZm9ybXNDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvcm0nKS5sZW5ndGggKyAxO1xuICAgIGNvbnN0IGZvcm0gPSB0aGlzLmJ1aWxkRm9ybShpbmRleCk7XG5cbiAgICB0aGlzLmZvcm1zQ29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xuICAgIHRoaXMuc3RhdHNEeW5hbWljT2JzdGFjbGVzLnRleHRDb250ZW50ID0gdGhpcy5mb3Jtc0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9ybScpLmxlbmd0aDtcblxuICAgIHJldHVybiBmb3JtO1xuICB9XG5cbiAgcmVtb3ZlRHluYW1pY09ic3RhY2xlKGZvcm0pIHtcbiAgICB0aGlzLmZvcm1zQ29udGFpbmVyLnJlbW92ZUNoaWxkKGZvcm0pO1xuICAgIHRoaXMucmVpbmRleEZvcm1zKCk7XG4gICAgdGhpcy5zdGF0c0R5bmFtaWNPYnN0YWNsZXMudGV4dENvbnRlbnQgPSB0aGlzLmZvcm1zQ29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb3JtJykubGVuZ3RoO1xuICB9XG5cbiAgY2xlYXJEeW5hbWljT2JzdGFjbGVzKCkge1xuICAgIHRoaXMuZm9ybXNDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5zdGF0c0R5bmFtaWNPYnN0YWNsZXMudGV4dENvbnRlbnQgPSAwO1xuICB9XG5cbiAgcmVpbmRleEZvcm1zKCkge1xuICAgIGNvbnN0IGZvcm1zID0gdGhpcy5mb3Jtc0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9ybScpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9ybXNbaV0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZHluYW1pYy1vYnN0YWNsZS1pbmRleCcpWzBdLnRleHRDb250ZW50ID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRGb3JtKGluZGV4KSB7XG4gICAgY29uc3QgaHRtbCA9XG4gICAgICBgPGZvcm0gY2xhc3M9XCJlZGl0b3ItZHluYW1pYy1vYnN0YWNsZS1mb3JtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgaXMtZ2FwbGVzc1wiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTFcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZC1sYWJlbCBpcy1ub3JtYWwgaXMtc2l6ZS03IGhhcy10ZXh0LWdyZXktbGlnaHRlciBoYXMtdGV4dC13ZWlnaHQtYm9sZCBkeW5hbWljLW9ic3RhY2xlLWluZGV4XCI+JHtpbmRleH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy0zXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VsZWN0IGlzLXNtYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IG5hbWU9XCJ0eXBlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInZlaGljbGVcIj5WZWhpY2xlPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN5Y2xpc3RcIj5DeWNsaXN0PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInBlZGVzdHJpYW5cIj5QZWRlc3RyaWFuPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtMVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLXRleHQtY2VudGVyZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY2hlY2tib3hcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwicGFyYWxsZWxcIiBjaGVja2VkIC8+Jm5ic3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtM1wiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkIGhhcy1hZGRvbnMgZWRpdG9yLWZpZWxkLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlucHV0IGlzLXNtYWxsXCIgdHlwZT1cInRleHRcIiBuYW1lPVwic1Bvc1wiIHN0eWxlPVwid2lkdGg6IDUwcHg7XCIgdmFsdWU9XCIwXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJpbnB1dCBpcy1zbWFsbFwiIHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxQb3NcIiBzdHlsZT1cIndpZHRoOiA1MHB4O1wiIHZhbHVlPVwiMFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtM1wiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkIGhhcy1hZGRvbnMgZWRpdG9yLWZpZWxkLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlucHV0IGlzLXNtYWxsXCIgdHlwZT1cInRleHRcIiBuYW1lPVwic1ZlbFwiIHN0eWxlPVwid2lkdGg6IDUwcHg7XCIgdmFsdWU9XCIwXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJpbnB1dCBpcy1zbWFsbFwiIHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxWZWxcIiBzdHlsZT1cIndpZHRoOiA1MHB4O1wiIHZhbHVlPVwiMFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtMVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkIGhhcy10ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbiBpcy1zbWFsbCBpcy1kYW5nZXIgZWRpdG9yLXJlbW92ZS1keW5hbWljLW9ic3RhY2xlXCIgdGl0bGU9XCJSZW1vdmUgRHluYW1pYyBPYnN0YWNsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWxnIGZhLXRyYXNoLWFsdFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgPC9mb3JtPmA7XG5cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBjb25zdCBmb3JtID0gdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkO1xuXG4gICAgZm9ybS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdlZGl0b3ItcmVtb3ZlLWR5bmFtaWMtb2JzdGFjbGUnKVswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy5yZW1vdmVEeW5hbWljT2JzdGFjbGUoZm9ybSkpO1xuXG4gICAgcmV0dXJuIGZvcm07XG4gIH1cbn1cbiIsImZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICByZXR1cm4gZGF0ZSAmJiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyh1bmRlZmluZWQsIHttb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJywgaG91cjogJ251bWVyaWMnLCBtaW51dGU6ICdudW1lcmljJywgaG91cjEyOiB0cnVlfSk7XG59XG5cbmV4cG9ydCB7IGZvcm1hdERhdGUgfTtcbiIsImV4cG9ydCBkZWZhdWx0IFtcbiAgeyBuYW1lOiBcIk9uZS1jYXIgb3ZlcnRha2VcIiwgZGF0YToge1wicFwiOlstMjk4LjEyOTc5LDM1Ny41MTA1Nyw3LjU1NDk3LDEzNi44OTI1NSwyNTUuNDU0NDYsLTE4Ni42NTA2Myw1ODYuNjYyODgsLTQ5NC41ODA4XSxcInNcIjpbXSxcImRcIjpbe1wicFwiOltcIjE1MFwiLFwiMC41XCJdLFwidlwiOltcIjE1XCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH1dLFwibFwiOjEyMzguMTI5LFwiY1wiOntcInNcIjpcIjI1XCIsXCJzbFwiOlwiMjVcIixcImxwXCI6MX0sXCJ2XCI6MX0gfSxcblxuICB7IG5hbWU6IFwiVHdvLWNhciBvdmVydGFrZVwiLCBkYXRhOiB7XCJwXCI6Wy0yNzYuNDY3NCwzMDMuMDA4NjUsNDQuODg1OTMsMTIwLjg2NzEyLDMwNS4xMDcyOSwtNDM1Ljk5NzI4XSxcInNcIjpbXSxcImRcIjpbe1wicFwiOltcIjEwMFwiLFwiMC41XCJdLFwidlwiOltcIjVcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfSx7XCJwXCI6W1wiMTAwXCIsXCItMC41XCJdLFwidlwiOltcIjZcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfV0sXCJsXCI6OTkwLjU3NixcImNcIjp7XCJzXCI6XCIyMFwiLFwic2xcIjpcIjIwXCIsXCJscFwiOjF9LFwidlwiOjF9IH0sXG5cbiAgeyBuYW1lOiBcIlJvdWdoIHJvYWRcIiwgZGF0YToge1wicFwiOlstMTAyLjQ2MDc4LDI2LjM4NTEzLC02OC42OTgyMSwyNS43OTc3NiwtNTUuOTQ5MTMsMTkuNTA0MjcsLTI1LjMyMjg0LDEyLjYxODMsLTE2LjYwMjQsMTAuNzczOSwtNi43MDgsMTEuNzgwMTMsMzEuMzYwNTQsMTIuMTE1NTQsNDcuMDQwNTcsMTQuNzk4OCw1Ni44NTA0OCwyMy4yNjc3Niw1Ni44NDk3OSwzNS4yNTgyOCw0Ni45NTUxMSw0My44OTQ2MywyNS40ODk3OSw0My41NTkyNCw4LjEzMzI2LDUyLjI3OTksLTE1LjM0NDM3LDY0LjEwMjQyXSxcInNcIjpbe1wicFwiOlstNTQuOTY0MjksMjEuMjU1M10sXCJyXCI6LTAuMjc2MTIsXCJ3XCI6Mi43NjcxLFwiaFwiOjEuNjc3MDN9LHtcInBcIjpbLTM2LjA5MjU0LDEyLjM2OTYzXSxcInJcIjowLjE0NzI2LFwid1wiOjMuNDM3OTEsXCJoXCI6MS44NDQ3NX0se1wicFwiOlstMTMuNDE2MjUsMTQuMjUzN10sXCJyXCI6MC4xMTY1OCxcIndcIjo0LjY5NTY4LFwiaFwiOjEuNDI1NDl9LHtcInBcIjpbNDQuMDA5MzEsMTguMzgxNjZdLFwiclwiOjAuMjU3NzEsXCJ3XCI6NC45NDcxMyxcImhcIjo0LjI3NjQyfSx7XCJwXCI6WzYyLjc0NjY5LDI5LjQxMzMxXSxcInJcIjowLFwid1wiOjQuMTA4NTUsXCJoXCI6NS44Njk1Mn0se1wicFwiOls0Ni43MTExOSwzOC43NDQ2OV0sXCJyXCI6MS4xNDc0MixcIndcIjo0LjUyNzc1LFwiaFwiOjYuNzA3OTR9LHtcInBcIjpbLTE0LjI2Mjc1LDYzLjYwMDA2XSxcInJcIjoyLjY3NTI2LFwid1wiOjEwLjE0NTg0LFwiaFwiOjEyLjI0MTczfSx7XCJwXCI6WzE5LjczNTEsOS40MDYyMV0sXCJyXCI6MC42NTA0MSxcIndcIjoxLjk3MTc3LFwiaFwiOjEuMDc1NTN9LHtcInBcIjpbMjguOTk2NzksOS43MTcyN10sXCJyXCI6MC4yMDg2MixcIndcIjoxLjk3MTc1LFwiaFwiOjEuMDMwNzJ9LHtcInBcIjpbMjQuMTUyMDUsOS45Mzg3Ml0sXCJyXCI6LTAuMzE5MDcsXCJ3XCI6MS4yNTQ3NixcImhcIjowLjk4NTl9XSxcImRcIjpbXSxcImxcIjoyNTkuMDg4LFwiY1wiOntcInNcIjpcIjEwXCIsXCJzbFwiOlwiMTBcIixcImxwXCI6MX0sXCJ2XCI6MX0gfSxcblxuICB7IG5hbWU6IFwiRG9kZ2luZyBhIHNwZWVkZXJcIiwgZGF0YToge1wicFwiOlstMjI2LjE0MDY2LDI3NS4zNDk0MSwyMS4zMjE5NCwtNi4yNjU0LDI2Ni45OTk1OCwtMTc0LjM5NTU5LDQ2Ni40MjQ0OSwtNDI3Ljk1MTI0XSxcInNcIjpbXSxcImRcIjpbe1wicFwiOltcIi0yNTBcIixcIi0wLjVcIl0sXCJ2XCI6W1wiNDBcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfV0sXCJsXCI6OTk2LjU3MixcImNcIjp7XCJzXCI6XCIyNVwiLFwic2xcIjpcIjI1XCIsXCJscFwiOi0xfSxcInZcIjoxfSB9LFxuXG4gIHsgbmFtZTogXCJMYW5lIGJsb2NrYWdlIHdpdGggb25jb21pbmcgdHJhZmZpY1wiLCBkYXRhOiB7XCJwXCI6Wy04NC45NjMxOCwtMTQuOTQ5NzMsMzc0LjkxMDQ0LC0xNC43MTY4XSxcInNcIjpbe1wicFwiOlstMzQuOTEwMjQsLTEyLjUxMzU5XSxcInJcIjowLFwid1wiOjIuNzY3MTEsXCJoXCI6Mi42ODMyNH1dLFwiZFwiOlt7XCJwXCI6W1wiNDBcIixcIi0wLjVcIl0sXCJ2XCI6W1wiLTEwXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjE1MFwiLFwiLTAuNVwiXSxcInZcIjpbXCItMTBcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfV0sXCJsXCI6NDU5Ljg3NCxcImNcIjp7XCJzXCI6XCIyMFwiLFwic2xcIjpcIjIwXCIsXCJscFwiOjF9LFwidlwiOjF9IH0sXG5cbiAgeyBuYW1lOiBcIk1lcmdpbmcgaW50byBzbG93ZXIgdHJhZmZpY1wiLCBkYXRhOiB7XCJwXCI6Wy02MjkuMDk0NjQsMTYuMzE1ODksMjgxLjk3MTYyLDE0LjgxNTY1XSxcInNcIjpbe1wicFwiOlstNDQwLjAwMTUyLDExLjYyNjAyXSxcInJcIjowLFwid1wiOjMuMTM3OSxcImhcIjozLjEzODAxfSx7XCJwXCI6Wy0yNTkuNzQwMzYsMTEuOTgwMTNdLFwiclwiOjAsXCJ3XCI6Mi41MTU1NixcImhcIjo0LjQ0NDF9LHtcInBcIjpbOTMuNzEwMTMsMTEuMjcwMzJdLFwiclwiOjAsXCJ3XCI6NC4wNzk0NyxcImhcIjo3Ljg0NTAxfSx7XCJwXCI6Wy05NC43MjIwOCwxMS4yODE3Ml0sXCJyXCI6MCxcIndcIjozLjc2NjA5LFwiaFwiOjcuNTMxMjJ9XSxcImRcIjpbe1wicFwiOltcIjMyMFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjI4MFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjI0MFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjIwMFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjE2MFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjEyMFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIjgwXCIsXCIwLjVcIl0sXCJ2XCI6W1wiMTJcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfSx7XCJwXCI6W1wiNDBcIixcIjAuNVwiXSxcInZcIjpbXCIxMlwiLFwiMFwiXSxcImxcIjoxLFwidFwiOjB9LHtcInBcIjpbXCIwXCIsXCIwLjVcIl0sXCJ2XCI6W1wiMTJcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfSx7XCJwXCI6W1wiLTQwXCIsXCIwLjVcIl0sXCJ2XCI6W1wiMTJcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfSx7XCJwXCI6W1wiLTgwXCIsXCIwLjVcIl0sXCJ2XCI6W1wiMTJcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfSx7XCJwXCI6W1wiLTEyMFwiLFwiMC41XCJdLFwidlwiOltcIjEyXCIsXCIwXCJdLFwibFwiOjEsXCJ0XCI6MH0se1wicFwiOltcIi0xNjBcIixcIjAuNVwiXSxcInZcIjpbXCIxMlwiLFwiMFwiXSxcImxcIjoxLFwidFwiOjB9LHtcInBcIjpbXCItMjAwXCIsXCIwLjVcIl0sXCJ2XCI6W1wiMTJcIixcIjBcIl0sXCJsXCI6MSxcInRcIjowfV0sXCJsXCI6OTExLjA2NyxcImNcIjp7XCJzXCI6XCIyNVwiLFwic2xcIjpcIjI1XCIsXCJscFwiOi0xfSxcInZcIjoxfSB9LFxuXG4gIHsgbmFtZTogXCJOZWdvdGlhdGluZyBjcm9zc3dhbGtzXCIsIGRhdGE6IHtcInBcIjpbLTE0NC43MzU3NCw1NS40NDk1LC0xMDQuODk0NDEsMzEuNjI3NTUsLTMzLjg3NDc5LDYxLjU3ODExLDU0LjYwNjMxLDQ2LjM0ODU4LDE1Mi4zNzI4LC00MS40MzM1LDIxOS45MDI1OCwtMTEzLjk1MjI1XSxcInNcIjpbXSxcImRcIjpbe1wicFwiOltcIjUxXCIsXCItMlwiXSxcInZcIjpbXCIwXCIsXCIxLjVcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTJcIixcIisyXCJdLFwidlwiOltcIjBcIixcIi0xLjZcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTNcIixcIi0yXCJdLFwidlwiOltcIjBcIixcIjEuNVwiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1NFwiLFwiKzJcIl0sXCJ2XCI6W1wiMFwiLFwiLTEuNFwiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1NVwiLFwiLTJcIl0sXCJ2XCI6W1wiMFwiLFwiMS41XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUwXCIsXCIrM1wiXSxcInZcIjpbXCIwXCIsXCItMS41XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUxXCIsXCItM1wiXSxcInZcIjpbXCIwXCIsXCIxLjdcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTJcIixcIiszXCJdLFwidlwiOltcIjBcIixcIi0xLjVcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTNcIixcIi0zXCJdLFwidlwiOltcIjBcIixcIjEuM1wiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1MFwiLFwiLTRcIl0sXCJ2XCI6W1wiMFwiLFwiMS42XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUxXCIsXCItNFwiXSxcInZcIjpbXCIwXCIsXCIxLjJcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTJcIixcIi01XCJdLFwidlwiOltcIjBcIixcIjEuNVwiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1M1wiLFwiLTVcIl0sXCJ2XCI6W1wiMFwiLFwiMS40XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUwXCIsXCI0LjVcIl0sXCJ2XCI6W1wiMFwiLFwiLTEuNlwiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1MVwiLFwiNVwiXSxcInZcIjpbXCIwXCIsXCItMS40XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUyXCIsXCI0XCJdLFwidlwiOltcIjBcIixcIi0xLjVcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTNcIixcIjQuNVwiXSxcInZcIjpbXCIwXCIsXCItMS40XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjQ5XCIsXCI1LjVcIl0sXCJ2XCI6W1wiMFwiLFwiLTEuMlwiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1MFwiLFwiNlwiXSxcInZcIjpbXCIwXCIsXCItMS42XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUxXCIsXCI1Ljc1XCJdLFwidlwiOltcIjBcIixcIi0xLjVcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiNTJcIixcIjVcIl0sXCJ2XCI6W1wiMFwiLFwiLTEuNVwiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI0OVwiLFwiLTZcIl0sXCJ2XCI6W1wiMFwiLFwiMS41XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUwXCIsXCItNS41XCJdLFwidlwiOltcIjBcIixcIjEuN1wiXSxcImxcIjoxLFwidFwiOjJ9LHtcInBcIjpbXCI1MVwiLFwiLTVcIl0sXCJ2XCI6W1wiMFwiLFwiMC45XCJdLFwibFwiOjEsXCJ0XCI6Mn0se1wicFwiOltcIjUyXCIsXCItNS43NVwiXSxcInZcIjpbXCIwXCIsXCIxLjJcIl0sXCJsXCI6MSxcInRcIjoyfSx7XCJwXCI6W1wiMTUwXCIsXCItNzVcIl0sXCJ2XCI6W1wiMFwiLFwiOVwiXSxcImxcIjowLFwidFwiOjF9LHtcInBcIjpbXCIxNTJcIixcIi04MFwiXSxcInZcIjpbXCIwXCIsXCIxMFwiXSxcImxcIjowLFwidFwiOjF9LHtcInBcIjpbXCIxNTRcIixcIi04NVwiXSxcInZcIjpbXCIwXCIsXCI5LjVcIl0sXCJsXCI6MCxcInRcIjoxfSx7XCJwXCI6W1wiMTUwXCIsXCI3NVwiXSxcInZcIjpbXCIwXCIsXCItMTBcIl0sXCJsXCI6MCxcInRcIjoxfSx7XCJwXCI6W1wiMTUyXCIsXCI4MFwiXSxcInZcIjpbXCIwXCIsXCItOVwiXSxcImxcIjowLFwidFwiOjF9LHtcInBcIjpbXCIxNTRcIixcIjg1XCJdLFwidlwiOltcIjBcIixcIi05LjVcIl0sXCJsXCI6MCxcInRcIjoxfV0sXCJsXCI6NDQ3LjUzNSxcImNcIjp7XCJzXCI6XCI1XCIsXCJzbFwiOlwiMjBcIixcImxwXCI6MX0sXCJ2XCI6MX0gfSxcblxuICB7IG5hbWU6IFwiQ2hhc2luZyB0aGUgcGVsb3RvblwiLCBkYXRhOiB7XCJwXCI6Wy03MDguMTA5Myw1NjEuNjcyMjIsLTY1Ny43MzY0OSw3MDEuNDY3NzIsLTUzMS4zMDIxMiw3MzYuNDE2MTMsLTMzMi45MTUxNyw3MDguNjYzLC0yMDEuMzQxNzYsNjExLjAxMjE1LC04MC4wNDUyMyw0NzcuMzgyMzIsMjIuNzUwODIsMzQxLjY5Mzg1LDE0Ny42NjE3NCwxNzYuNzM2MjIsMjUzLjAyMzcxLC0xNS4wMTU3NCw0NDguMzE4MjgsLTMzNS43MTgzNiw0OTUuNjA5MzIsLTU0NC40MDA0OF0sXCJzXCI6W10sXCJkXCI6W3tcInBcIjpbXCI1MFwiLFwiMC40XCJdLFwidlwiOltcIjE1LjVcIixcIi0wLjFcIl0sXCJsXCI6MSxcInRcIjoxfSx7XCJwXCI6W1wiNTJcIixcIjAuNlwiXSxcInZcIjpbXCIxNS43XCIsXCItMC4xNVwiXSxcImxcIjoxLFwidFwiOjF9LHtcInBcIjpbXCI1NFwiLFwiMC4zXCJdLFwidlwiOltcIjE1LjNcIixcIi0wLjEzXCJdLFwibFwiOjEsXCJ0XCI6MX0se1wicFwiOltcIjU2XCIsXCIwLjdcIl0sXCJ2XCI6W1wiMTUuMlwiLFwiLTAuMVwiXSxcImxcIjoxLFwidFwiOjF9LHtcInBcIjpbXCI1OFwiLFwiMC4zXCJdLFwidlwiOltcIjE1LjhcIixcIi0wLjEyXCJdLFwibFwiOjEsXCJ0XCI6MX0se1wicFwiOltcIjYwXCIsXCIwLjdcIl0sXCJ2XCI6W1wiMTUuNlwiLFwiLTAuMTdcIl0sXCJsXCI6MSxcInRcIjoxfSx7XCJwXCI6W1wiNjJcIixcIjAuMVwiXSxcInZcIjpbXCIxNS40XCIsXCItMC4xNFwiXSxcImxcIjoxLFwidFwiOjF9LHtcInBcIjpbXCI2NFwiLFwiLTAuMVwiXSxcInZcIjpbXCIxNS41XCIsXCIwLjEzXCJdLFwibFwiOjEsXCJ0XCI6MX0se1wicFwiOltcIjY2XCIsXCIwLjNcIl0sXCJ2XCI6W1wiMTUuM1wiLFwiLTAuMTNcIl0sXCJsXCI6MSxcInRcIjoxfSx7XCJwXCI6W1wiNjhcIixcIjBcIl0sXCJ2XCI6W1wiMTUuNlwiLFwiMC4xNVwiXSxcImxcIjoxLFwidFwiOjF9LHtcInBcIjpbXCI3MFwiLFwiLTAuM1wiXSxcInZcIjpbXCIxNS44XCIsXCIwLjE3XCJdLFwibFwiOjEsXCJ0XCI6MX0se1wicFwiOltcIjcyXCIsXCItMC43XCJdLFwidlwiOltcIjE1LjdcIixcIjAuMTJcIl0sXCJsXCI6MSxcInRcIjoxfSx7XCJwXCI6W1wiNzRcIixcIi0wLjVcIl0sXCJ2XCI6W1wiMTUuMVwiLFwiMC4xNVwiXSxcImxcIjoxLFwidFwiOjF9LHtcInBcIjpbXCI3NlwiLFwiLTAuN1wiXSxcInZcIjpbXCIxNS45XCIsXCIwLjExXCJdLFwibFwiOjEsXCJ0XCI6MX0se1wicFwiOltcIjc4XCIsXCItMC4zXCJdLFwidlwiOltcIjE1LjVcIixcIjAuMTZcIl0sXCJsXCI6MSxcInRcIjoxfSx7XCJwXCI6W1wiODBcIixcIi0wLjVcIl0sXCJ2XCI6W1wiMTUuNlwiLFwiMC4xM1wiXSxcImxcIjoxLFwidFwiOjF9XSxcImxcIjoyMDE4LjIxMyxcImNcIjp7XCJzXCI6XCIxNVwiLFwic2xcIjpcIjI1XCIsXCJscFwiOjF9LFwidlwiOjF9IH1cbl07XG4iLCJpbXBvcnQgeyBmb3JtYXREYXRlIH0gZnJvbSBcIi4uL0hlbHBlcnMuanNcIjtcbmltcG9ydCBFWEFNUExFUyBmcm9tIFwiLi9leGFtcGxlcy5qc1wiO1xuXG5jb25zdCBMT0NBTF9TVE9SQUdFX0tFWSA9ICdkYXNoX1NjZW5hcmlvcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5hcmlvTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMubW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW9zLW1vZGFsJyk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW9zLW1vZGFsLWJhY2tncm91bmQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2Nsb3NlTW9kYWwuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvcy1tb2RhbC1jbG9zZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xvc2VNb2RhbC5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuZXhhbXBsZXNUYWIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW9zLW1vZGFsLWV4YW1wbGVzLXRhYicpO1xuICAgIHRoaXMuc2F2ZWRUYWIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW9zLW1vZGFsLXNhdmVkLXRhYicpO1xuICAgIHRoaXMuaW1wb3J0VGFiID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvcy1tb2RhbC1pbXBvcnQtdGFiJyk7XG5cbiAgICB0aGlzLmV4YW1wbGVzVGFiQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvcy1tb2RhbC1leGFtcGxlcy10YWItYnV0dG9uJyk7XG4gICAgdGhpcy5zYXZlZFRhYkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2VuYXJpb3MtbW9kYWwtc2F2ZWQtdGFiLWJ1dHRvbicpO1xuICAgIHRoaXMuaW1wb3J0VGFiQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvcy1tb2RhbC1pbXBvcnQtdGFiLWJ1dHRvbicpO1xuICAgIHRoaXMuZXhhbXBsZXNUYWJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuc3dpdGNoVGFiKHRoaXMuZXhhbXBsZXNUYWIpKTtcbiAgICB0aGlzLnNhdmVkVGFiQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLnN3aXRjaFRhYih0aGlzLnNhdmVkVGFiKSk7XG4gICAgdGhpcy5pbXBvcnRUYWJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuc3dpdGNoVGFiKHRoaXMuaW1wb3J0VGFiKSk7XG5cbiAgICB0aGlzLml0ZW1zQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvcy1tb2RhbC1pdGVtcycpO1xuXG4gICAgdGhpcy5zb3J0TmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2VuYXJpb3Mtc29ydC1uYW1lJyk7XG4gICAgdGhpcy5zb3J0TmFtZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy5fYnVpbGRTY2VuYXJpb0l0ZW1zKCduYW1lJykpO1xuICAgIHRoaXMuc29ydFNhdmVkQXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW9zLXNvcnQtc2F2ZWQtYXQnKTtcbiAgICB0aGlzLnNvcnRTYXZlZEF0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLl9idWlsZFNjZW5hcmlvSXRlbXMoJ3NhdmVkQXQnKSk7XG5cbiAgICB0aGlzLmltcG9ydEJveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2VuYXJpby1pbXBvcnQtYm94Jyk7XG4gICAgdGhpcy5pbXBvcnRJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvLWltcG9ydC1pbmZvJyk7XG5cbiAgICB0aGlzLmltcG9ydEJveC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2ltcG9ydEJveENoYW5nZWQuYmluZCh0aGlzKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IEVYQU1QTEVTLmxlbmd0aDsgaSsrKVxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGV4YW1wbGUtJHtpfWApLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLl9sb2FkU2NlbmFyaW8oRVhBTVBMRVNbaV0pKTtcbiAgfVxuXG4gIHN3aXRjaFRhYih0YWIpIHtcbiAgICB0aGlzLmV4YW1wbGVzVGFiLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpXG4gICAgdGhpcy5zYXZlZFRhYi5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKVxuICAgIHRoaXMuaW1wb3J0VGFiLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpXG4gICAgdGhpcy5leGFtcGxlc1RhYkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgICB0aGlzLnNhdmVkVGFiQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIHRoaXMuaW1wb3J0VGFiQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuXG4gICAgbGV0IGJ1dHRvbiA9IHRoaXMuc2F2ZWRUYWJCdXR0b247XG4gICAgaWYgKHRhYiA9PSB0aGlzLmV4YW1wbGVzVGFiKVxuICAgICAgYnV0dG9uID0gdGhpcy5leGFtcGxlc1RhYkJ1dHRvbjtcbiAgICBlbHNlIGlmICh0YWIgPT0gdGhpcy5pbXBvcnRUYWIpXG4gICAgICBidXR0b24gPSB0aGlzLmltcG9ydFRhYkJ1dHRvbjtcblxuICAgIHRhYi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG5cbiAgICBpZiAodGFiID09IHRoaXMuaW1wb3J0VGFiKVxuICAgICAgdGhpcy5pbXBvcnRCb3guZm9jdXMoKTtcbiAgfVxuXG4gIHNhdmVTY2VuYXJpbyhuYW1lLCBkYXRhLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2NlbmFyaW9zID0gdGhpcy5mZXRjaFNjZW5hcmlvcygpO1xuICAgIGxldCBzY2VuYXJpbyA9IHNjZW5hcmlvc1tuYW1lXTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKHNjZW5hcmlvKSB7XG4gICAgICBpZiAoIWZvcmNlKSByZXR1cm4gW2ZhbHNlLCBzY2VuYXJpby5zYXZlZEF0XTtcblxuICAgICAgc2NlbmFyaW8uZGF0YSA9IGRhdGE7XG4gICAgICBzY2VuYXJpby5zYXZlZEF0ID0gbm93O1xuICAgIH0gZWxzZSB7XG4gICAgICAgc2NlbmFyaW8gPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHNhdmVkQXQ6IG5vd1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2NlbmFyaW9zW25hbWVdID0gc2NlbmFyaW87XG4gICAgfVxuXG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHNjZW5hcmlvcyk7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKExPQ0FMX1NUT1JBR0VfS0VZLCBqc29uKTtcblxuICAgIHJldHVybiBbdHJ1ZSwgc2NlbmFyaW8uc2F2ZWRBdF07XG4gIH1cblxuICBmZXRjaFNjZW5hcmlvcygpIHtcbiAgICBjb25zdCBzY2VuYXJpb3MgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSkpIHx8IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIGluIHNjZW5hcmlvcylcbiAgICAgIHNjZW5hcmlvc1trXS5zYXZlZEF0ID0gbmV3IERhdGUoc2NlbmFyaW9zW2tdLnNhdmVkQXQpO1xuXG4gICAgcmV0dXJuIHNjZW5hcmlvcztcbiAgfVxuXG4gIHNob3dNb2RhbChvbkxvYWRTY2VuYXJpbyA9IG51bGwpIHtcbiAgICB0aGlzLm9uTG9hZFNjZW5hcmlvID0gb25Mb2FkU2NlbmFyaW87XG5cbiAgICB0aGlzLm1vZGFsLmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuICAgIHRoaXMuc3dpdGNoVGFiKHRoaXMuc2F2ZWRUYWIpO1xuXG4gICAgdGhpcy5fYnVpbGRTY2VuYXJpb0l0ZW1zKCk7XG4gICAgdGhpcy5pdGVtc0NvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICAgIFxuICAgIHRoaXMuaW1wb3J0Qm94LnZhbHVlID0gJyc7XG4gICAgdGhpcy5pbXBvcnRCb3guZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpO1xuICB9XG5cbiAgX2Nsb3NlTW9kYWwoKSB7XG4gICAgdGhpcy5vbkxvYWRTY2VuYXJpbyA9IG51bGw7XG4gICAgdGhpcy5tb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgfVxuXG4gIF9idWlsZFNjZW5hcmlvSXRlbXMoc29ydCA9ICdzYXZlZEF0Jykge1xuICAgIHRoaXMuaXRlbXNDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cbiAgICB0aGlzLnNvcnROYW1lLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXVuZGVybGluZWQnKTtcbiAgICB0aGlzLnNvcnRTYXZlZEF0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXVuZGVybGluZWQnKTtcbiAgICBpZiAoc29ydCA9PSAnbmFtZScpXG4gICAgICB0aGlzLnNvcnROYW1lLmNsYXNzTGlzdC5hZGQoJ2lzLXVuZGVybGluZWQnKTtcbiAgICBlbHNlIGlmIChzb3J0ID09ICdzYXZlZEF0JylcbiAgICAgIHRoaXMuc29ydFNhdmVkQXQuY2xhc3NMaXN0LmFkZCgnaXMtdW5kZXJsaW5lZCcpO1xuXG4gICAgY29uc3Qgc2NlbmFyaW9zID0gT2JqZWN0LnZhbHVlcyh0aGlzLmZldGNoU2NlbmFyaW9zKCkpO1xuXG4gICAgaWYgKHNjZW5hcmlvcy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5fc2hvd0VtcHR5TWVzc2FnZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2VuYXJpb3Muc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoc29ydCA9PSAnc2F2ZWRBdCcpIHtcbiAgICAgICAgICBpZiAoYS5zYXZlZEF0IDwgYi5zYXZlZEF0KSByZXR1cm4gKzE7XG4gICAgICAgICAgZWxzZSBpZiAoYi5zYXZlZEF0IDwgYS5zYXZlZEF0KSByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuYW1lQSA9IGEubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBuYW1lQiA9IGIubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChuYW1lQSA8IG5hbWVCKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChuYW1lQiA8IG5hbWVBKSByZXR1cm4gKzE7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG5cbiAgICAgIHNjZW5hcmlvcy5mb3JFYWNoKHMgPT4gdGhpcy5fYWRkU2NlbmFyaW9JdGVtKHMpKTtcbiAgICB9XG4gIH1cblxuICBfc2hvd0VtcHR5TWVzc2FnZSgpIHtcbiAgICB0aGlzLml0ZW1zQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPGk+WW91IGRvbid0IGhhdmUgYW55IHNhdmVkIHNjZW5hcmlvcy48L2k+XCI7XG4gIH1cblxuICBfYWRkU2NlbmFyaW9JdGVtKHNjZW5hcmlvKSB7XG4gICAgY29uc3QgaHRtbCA9XG4gICAgICBgPGRpdiBjbGFzcz1cImNvbHVtbnNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTcgc2NlbmFyaW8taXRlbS1uYW1lIHNjZW5hcmlvLWl0ZW0tbG9hZFwiIHRpdGxlPVwiXCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy00IHNjZW5hcmlvLWl0ZW0tc2F2ZWQtYXRcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTFcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkIGlzLWdyb3VwZWQgaXMtcHVsbGVkLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImNvbnRyb2xcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogOHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYnV0dG9uIGlzLXNtYWxsIGlzLWRhbmdlciBzY2VuYXJpby1pdGVtLWRlbGV0ZVwiIHRpdGxlPVwiRGVsZXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYXMgZmEtbGcgZmEtdHJhc2gtYWx0XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PmA7XG5cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBjb25zdCBpdGVtID0gdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkO1xuXG4gICAgY29uc3QgbmFtZURvbSA9IGl0ZW0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2NlbmFyaW8taXRlbS1uYW1lJylbMF07XG4gICAgbmFtZURvbS50ZXh0Q29udGVudCA9IHNjZW5hcmlvLm5hbWU7XG4gICAgbmFtZURvbS50aXRsZSA9IHNjZW5hcmlvLm5hbWU7XG5cbiAgICBpdGVtLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NjZW5hcmlvLWl0ZW0tc2F2ZWQtYXQnKVswXS50ZXh0Q29udGVudCA9IGZvcm1hdERhdGUoc2NlbmFyaW8uc2F2ZWRBdCk7XG5cbiAgICBpdGVtLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NjZW5hcmlvLWl0ZW0tbG9hZCcpWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLl9sb2FkU2NlbmFyaW8oc2NlbmFyaW8pKTtcblxuICAgIGl0ZW0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2NlbmFyaW8taXRlbS1kZWxldGUnKVswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5jb25maXJtKGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoZSBzY2VuYXJpbyBcIiR7c2NlbmFyaW8ubmFtZX1cIj9gKSkge1xuICAgICAgICB0aGlzLl9kZWxldGVTY2VuYXJpbyhzY2VuYXJpbyk7XG4gICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIucmVtb3ZlQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXRlbXNDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoID09IDApXG4gICAgICAgICAgdGhpcy5fc2hvd0VtcHR5TWVzc2FnZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pdGVtc0NvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtKTtcbiAgfVxuXG4gIF9sb2FkU2NlbmFyaW8oc2NlbmFyaW8pIHtcbiAgICB0aGlzLmVkaXRvci5sb2FkSlNPTihzY2VuYXJpby5kYXRhKTtcbiAgICB0aGlzLmVkaXRvci51cGRhdGVTYXZlZEluZm8oc2NlbmFyaW8ubmFtZSwgZm9ybWF0RGF0ZShzY2VuYXJpby5zYXZlZEF0KSk7XG5cbiAgICBpZiAodGhpcy5vbkxvYWRTY2VuYXJpbykgdGhpcy5vbkxvYWRTY2VuYXJpbygpO1xuXG4gICAgdGhpcy5fY2xvc2VNb2RhbCgpO1xuICB9XG5cbiAgX2RlbGV0ZVNjZW5hcmlvKHNjZW5hcmlvKSB7XG4gICAgY29uc3Qgc2NlbmFyaW9zID0gdGhpcy5mZXRjaFNjZW5hcmlvcygpO1xuICAgIGRlbGV0ZSBzY2VuYXJpb3Nbc2NlbmFyaW8ubmFtZV07XG5cbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoc2NlbmFyaW9zKTtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVksIGpzb24pO1xuICB9XG5cbiAgX2ltcG9ydEJveENoYW5nZWQoKSB7XG4gICAgdGhpcy5pbXBvcnRCb3guY2xhc3NMaXN0LnJlbW92ZSgnaXMtZGFuZ2VyJyk7XG4gICAgdGhpcy5pbXBvcnRJbmZvLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpO1xuXG4gICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuaW1wb3J0Qm94LnZhbHVlO1xuXG4gICAgaWYgKGVuY29kZWQgIT0gJycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGF0b2IodGhpcy5pbXBvcnRCb3gudmFsdWUpKTtcblxuICAgICAgICBpZiAoanNvbi5zID09PSB1bmRlZmluZWQgfHwganNvbi5kID09PSB1bmRlZmluZWQgfHwganNvbi5wID09PSB1bmRlZmluZWQgfHwganNvbi5wLmxlbmd0aCAlIDIgIT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcblxuICAgICAgICB0aGlzLmltcG9ydEluZm8uaW5uZXJIVE1MID0gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b24gaXMtc21hbGwgaXMtc3RhdGljIGhhcy10ZXh0LWdyZXktbGlnaHQgaXMtcGFkZGluZ2xlc3NcIiBzdHlsZT1cImJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyBib3JkZXI6IG5vbmU7XCI+XG4gICAgICAgICAgICAgIFJvYWQgTGVuZ3RoOiZuYnNwOzxiPiR7anNvbi5sLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDEsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMSB9KX08L2I+bVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICZuYnNwO1xuICAgICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b24gaXMtc21hbGwgaXMtc3RhdGljIGhhcy10ZXh0LWdyZXktbGlnaHQgaXMtcGFkZGluZ2xlc3NcIiBzdHlsZT1cImJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyBib3JkZXI6IG5vbmU7XCI+XG4gICAgICAgICAgICAgIFN0YXRpYyBPYnN0YWNsZXM6Jm5ic3A7PGI+JHtqc29uLnMubGVuZ3RofTwvYj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAmbmJzcDtcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uIGlzLXNtYWxsIGlzLXN0YXRpYyBoYXMtdGV4dC1ncmV5LWxpZ2h0IGlzLXBhZGRpbmdsZXNzXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgYm9yZGVyOiBub25lO1wiPlxuICAgICAgICAgICAgICBEeW5hbWljIE9ic3RhY2xlczombmJzcDs8Yj4ke2pzb24uZC5sZW5ndGh9PC9iPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b24gaXMtc21hbGwgaXMtc3VjY2VzcyBpcy1wdWxsZWQtcmlnaHQgc2NlbmFyaW8taW1wb3J0LWJ1dHRvblwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWNoZWNrXCI+PC9pPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4+SW1wb3J0PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICAgIHRoaXMuaW1wb3J0SW5mby5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzY2VuYXJpby1pbXBvcnQtYnV0dG9uJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuX2xvYWRTY2VuYXJpbyh7IGRhdGE6IGpzb24gfSkpO1xuICAgICAgICB0aGlzLmltcG9ydEluZm8uY2xhc3NMaXN0LnJlbW92ZSgnaXMtaGlkZGVuJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuaW1wb3J0Qm94LmNsYXNzTGlzdC5hZGQoJ2lzLWRhbmdlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhcmVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2VuYXJpby1zaGFyZS1tb2RhbCcpO1xuICAgIHRoaXMubGlua0RvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2VuYXJpby1zaGFyZS1saW5rJyk7XG4gICAgdGhpcy5ib3hEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW8tc2hhcmUtYm94Jyk7XG4gICAgdGhpcy5jbGlwYm9hcmRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW8tc2hhcmUtY2xpcGJvYXJkJyk7XG4gICAgdGhpcy5jbGlwYm9hcmRJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvLXNoYXJlLWNsaXBib2FyZC1pY29uJyk7XG4gICAgdGhpcy5jbGlwYm9hcmRTdWNjZXNzSWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2VuYXJpby1zaGFyZS1jbGlwYm9hcmQtc3VjY2Vzcy1pY29uJyk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW8tc2hhcmUtbW9kYWwtYmFja2dyb3VuZCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xvc2VNb2RhbC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW8tc2hhcmUtbW9kYWwtY2xvc2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2Nsb3NlTW9kYWwuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5jbGlwYm9hcmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jb3B5TGlua1RvQ2xpcGJvYXJkLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5saW5rRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZSA9PiB0aGlzLmxpbmtEb20uc2VsZWN0KCkpO1xuICAgIHRoaXMuYm94RG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZSA9PiB0aGlzLmJveERvbS5zZWxlY3QoKSk7XG4gIH1cblxuICBzaG93TW9kYWwoc2NlbmFyaW8pIHtcbiAgICB0aGlzLm1vZGFsLmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuXG4gICAgdGhpcy5jbGlwYm9hcmRJY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICAgIHRoaXMuY2xpcGJvYXJkU3VjY2Vzc0ljb24uY2xhc3NMaXN0LmFkZCgnaXMtaGlkZGVuJyk7XG4gICAgdGhpcy5jbGlwYm9hcmRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtc3VjY2VzcycpO1xuXG4gICAgY29uc3QgY29kZSA9IGJ0b2EoSlNPTi5zdHJpbmdpZnkoc2NlbmFyaW8pKTtcblxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uKTtcbiAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgdXJsLmhhc2ggPSAnL3MvJyArIGVuY29kZVVSSUNvbXBvbmVudChjb2RlKTtcblxuICAgIHRoaXMubGlua0RvbS52YWx1ZSA9IHVybC5ocmVmO1xuICAgIHRoaXMuYm94RG9tLnZhbHVlID0gY29kZTtcbiAgfVxuXG4gIF9jbG9zZU1vZGFsKCkge1xuICAgIHRoaXMubW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XG4gIH1cblxuICBfY29weUxpbmtUb0NsaXBib2FyZCgpIHtcbiAgICB0aGlzLmxpbmtEb20uZm9jdXMoKTtcbiAgICB0aGlzLmxpbmtEb20uc2VsZWN0KCk7XG5cbiAgICBpZiAoZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknLCBmYWxzZSwgbnVsbCkpIHtcbiAgICAgIHRoaXMuY2xpcGJvYXJkSWNvbi5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKTtcbiAgICAgIHRoaXMuY2xpcGJvYXJkU3VjY2Vzc0ljb24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtaGlkZGVuJyk7XG4gICAgICB0aGlzLmNsaXBib2FyZEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpcy1zdWNjZXNzJyk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgTGFuZVBhdGggZnJvbSBcIi4uL2F1dG9ub215L0xhbmVQYXRoLmpzXCI7XG5pbXBvcnQgU3RhdGljT2JzdGFjbGUgZnJvbSBcIi4uL2F1dG9ub215L1N0YXRpY09ic3RhY2xlLmpzXCI7XG5pbXBvcnQgRHluYW1pY09ic3RhY2xlRWRpdG9yIGZyb20gXCIuL0R5bmFtaWNPYnN0YWNsZUVkaXRvci5qc1wiO1xuaW1wb3J0IFNjZW5hcmlvTWFuYWdlciBmcm9tIFwiLi9TY2VuYXJpb01hbmFnZXIuanNcIjtcbmltcG9ydCBTaGFyZU1hbmFnZXIgZnJvbSBcIi4vU2hhcmVNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXREYXRlIH0gZnJvbSBcIi4uL0hlbHBlcnMuanNcIjtcblxuY29uc3QgR1JPVU5EX1BMQU5FID0gbmV3IFRIUkVFLlBsYW5lKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApKTtcblxuY29uc3QgTk9STUFMX09QQUNJVFkgPSAwLjc7XG5jb25zdCBIT1ZFUl9PUEFDSVRZID0gMTtcbmNvbnN0IE5PUk1BTF9QT0lOVF9DT0xPUiA9IDB4MDA4OGZmO1xuY29uc3QgSE9WRVJfUE9JTlRfQ09MT1IgPSAweDMzY2NmZjtcbmNvbnN0IE5PUk1BTF9TVEFUSUNfT0JTVEFDTEVfQ09MT1IgPSAweGRkMDAwMDtcbmNvbnN0IEhPVkVSX1NUQVRJQ19PQlNUQUNMRV9DT0xPUiA9IDB4ZGQzMzMzO1xuY29uc3QgTk9STUFMX0RZTkFNSUNfT0JTVEFDTEVfQ09MT1IgPSAweGZmODgwMDtcbmNvbnN0IEhPVkVSX0RZTkFNSUNfT0JTVEFDTEVfQ09MT1IgPSAweGZmY2MzMztcblxuY29uc3QgSU5JVElBTF9TUEVFRF9GQUxMQkFDSyA9IDIwO1xuY29uc3QgU1BFRURfTElNSVRfRkFMTEJBQ0sgPSAyMDtcbmNvbnN0IExBTkVfUFJFRkVSRU5DRV9GQUxMQkFDSyA9ICsxO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0b3Ige1xuICBjb25zdHJ1Y3RvcihjYW52YXMsIGNhbWVyYSwgc2NlbmUpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5yYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgdGhpcy5kcmFnT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLmRyYWdnaW5nUG9pbnQgPSBudWxsO1xuICAgIHRoaXMucG9pbnRJbmRleCA9IDA7XG4gICAgdGhpcy5vYnN0YWNsZUluZGV4ID0gMDtcbiAgICB0aGlzLnByZXZpb3VzU2F2ZWROYW1lID0gbnVsbDtcbiAgICB0aGlzLnNjZW5hcmlvTWFuYWdlciA9IG5ldyBTY2VuYXJpb01hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5zaGFyZU1hbmFnZXIgPSBuZXcgU2hhcmVNYW5hZ2VyKCk7XG5cbiAgICB0aGlzLmNlbnRlcmxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMubGVmdEJvdW5kYXJ5R2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcnlHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMuZHJhZ2dpbmdPYnN0YWNsZVByZXZpZXcgPSBudWxsO1xuXG4gICAgdGhpcy5ncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAucmVuZGVyT3JkZXIgPSAxO1xuICAgIHRoaXMucG9pbnRHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgIHRoaXMucG9pbnRHcm91cC5yZW5kZXJPcmRlciA9IDI7XG4gICAgdGhpcy5vYnN0YWNsZUdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgdGhpcy5vYnN0YWNsZUdyb3VwLnJlbmRlck9yZGVyID0gMTtcbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLm9ic3RhY2xlR3JvdXApO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMucG9pbnRHcm91cCk7XG4gICAgc2NlbmUuYWRkKHRoaXMuZ3JvdXApO1xuXG4gICAgdGhpcy5sYW5lUGF0aCA9IG5ldyBMYW5lUGF0aCgpO1xuICAgIHRoaXMuZHluYW1pY09ic3RhY2xlRWRpdG9yID0gbmV3IER5bmFtaWNPYnN0YWNsZUVkaXRvcigpO1xuXG4gICAgdGhpcy5lZGl0b3JQYXRoQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1wYXRoJyk7XG4gICAgdGhpcy5lZGl0b3JQYXRoQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmNoYW5nZUVkaXRNb2RlKCdwYXRoJykpO1xuICAgIHRoaXMuZWRpdG9yT2JzdGFjbGVzQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1vYnN0YWNsZXMnKTtcbiAgICB0aGlzLmVkaXRvck9ic3RhY2xlc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy5jaGFuZ2VFZGl0TW9kZSgnc3RhdGljT2JzdGFjbGVzJykpO1xuICAgIHRoaXMuZWRpdG9yRHluYW1pY09ic3RhY2xlc0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItZHluYW1pYy1vYnN0YWNsZXMnKTtcbiAgICB0aGlzLmVkaXRvckR5bmFtaWNPYnN0YWNsZXNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuY2hhbmdlRWRpdE1vZGUoJ2R5bmFtaWNPYnN0YWNsZXMnKSk7XG5cbiAgICB0aGlzLmVkaXRvclJvYWRCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLXJvYWQtYm94Jyk7XG4gICAgdGhpcy5pbml0aWFsU3BlZWREb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWluaXRpYWwtc3BlZWQnKTtcbiAgICB0aGlzLnNwZWVkTGltaXREb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLXNwZWVkLWxpbWl0Jyk7XG4gICAgdGhpcy5sYW5lTGVmdERvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItbGFuZS1sZWZ0Jyk7XG4gICAgdGhpcy5sYW5lUmlnaHREb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWxhbmUtcmlnaHQnKTtcblxuICAgIHRoaXMubGFuZUxlZnREb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuX2NoYW5nZUxhbmVQcmVmZXJlbmNlKC0xKSk7XG4gICAgdGhpcy5sYW5lUmlnaHREb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuX2NoYW5nZUxhbmVQcmVmZXJlbmNlKCsxKSk7XG5cbiAgICB0aGlzLmluaXRpYWxTcGVlZERvbS52YWx1ZSA9IElOSVRJQUxfU1BFRURfRkFMTEJBQ0s7XG4gICAgdGhpcy5zcGVlZExpbWl0RG9tLnZhbHVlID0gU1BFRURfTElNSVRfRkFMTEJBQ0s7XG4gICAgdGhpcy5fY2hhbmdlTGFuZVByZWZlcmVuY2UoTEFORV9QUkVGRVJFTkNFX0ZBTExCQUNLKTtcblxuICAgIHRoaXMuc3RhdHNSb2FkTGVuZ3RoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1zdGF0cy1yb2FkLWxlbmd0aCcpO1xuICAgIHRoaXMuc3RhdHNTdGF0aWNPYnN0YWNsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLXN0YXRzLXN0YXRpYy1vYnN0YWNsZXMnKTtcbiAgICB0aGlzLnN0YXRzU3RhdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3Itc3RhdHMtc3RhdGlvbicpO1xuICAgIHRoaXMuc3RhdHNMYXRpdHVkZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3Itc3RhdHMtbGF0aXR1ZGUnKTtcbiAgICB0aGlzLnNjZW5hcmlvTmFtZURvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3Itc2NlbmFyaW8tbmFtZScpO1xuICAgIHRoaXMuc2NlbmFyaW9TYXZlZEF0RG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1zY2VuYXJpby1zYXZlZC1hdCcpO1xuXG4gICAgdGhpcy5oZWxwUGF0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItaGVscC1wYXRoJyk7XG4gICAgdGhpcy5oZWxwU3RhdGljT2JzdGFjbGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1oZWxwLXN0YXRpYy1vYnN0YWNsZXMnKTtcbiAgICB0aGlzLmhlbHBEeW5hbWljT2JzdGFjbGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1oZWxwLWR5bmFtaWMtb2JzdGFjbGVzJyk7XG5cbiAgICB0aGlzLmNoYW5nZUVkaXRNb2RlKCdwYXRoJyk7XG4gICAgdGhpcy5yZW1vdmVNb2RlID0gZmFsc2U7XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGUgPT4gdGhpcy5pc0VuYWJsZWQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpKTtcblxuICAgIGNvbnN0IGVkaXRvckNsZWFyT3B0aW9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItY2xlYXItb3B0aW9ucycpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItY2xlYXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZWRpdG9yQ2xlYXJPcHRpb25zLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWhpZGRlbicpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gZWRpdG9yQ2xlYXJPcHRpb25zLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpKTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItY2xlYXItb2JzdGFjbGVzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsZWFyU3RhdGljT2JzdGFjbGVzLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3ItY2xlYXItZHluYW1pYy1vYnN0YWNsZXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZHluYW1pY09ic3RhY2xlRWRpdG9yLmNsZWFyRHluYW1pY09ic3RhY2xlcy5iaW5kKHRoaXMuZHluYW1pY09ic3RhY2xlRWRpdG9yKSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1jbGVhci1wYXRoJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsZWFyUGF0aC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWNsZWFyLWFsbCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbGVhckFsbC5iaW5kKHRoaXMpKTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0b3Itc2F2ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zYXZlQ2xpY2tlZC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWxvYWQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMubG9hZENsaWNrZWQuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1zaGFyZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zaGFyZUNsaWNrZWQuYmluZCh0aGlzKSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5rZXlVcC5iaW5kKHRoaXMpKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgICB0aGlzLmNlbnRlcmxpbmVPYmplY3QgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxuICAgICAgbmV3IE1lc2hMaW5lTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogbmV3IFRIUkVFLkNvbG9yKDB4MDA0NDg4KSxcbiAgICAgICAgbGluZVdpZHRoOiA4LFxuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICBzaXplQXR0ZW51YXRpb246IGZhbHNlLFxuICAgICAgICBuZWFyOiBjYW1lcmEubmVhcixcbiAgICAgICAgZmFyOiBjYW1lcmEuZmFyLFxuICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuY2VudGVybGluZU9iamVjdC5yb3RhdGlvbi54ID0gTWF0aC5QSSAvIDI7XG4gICAgdGhpcy5jZW50ZXJsaW5lT2JqZWN0LnJlbmRlck9yZGVyID0gMTtcbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLmNlbnRlcmxpbmVPYmplY3QpO1xuXG4gICAgdGhpcy5sZWZ0Qm91bmRhcnlPYmplY3QgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxuICAgICAgbmV3IE1lc2hMaW5lTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogbmV3IFRIUkVFLkNvbG9yKDB4ZmY0MGZmKSxcbiAgICAgICAgbGluZVdpZHRoOiAwLjE1LFxuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5sZWZ0Qm91bmRhcnlPYmplY3Qucm90YXRpb24ueCA9IE1hdGguUEkgLyAyO1xuICAgIHRoaXMubGVmdEJvdW5kYXJ5T2JqZWN0LnJlbmRlck9yZGVyID0gMTtcbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLmxlZnRCb3VuZGFyeU9iamVjdCk7XG5cbiAgICB0aGlzLnJpZ2h0Qm91bmRhcnlPYmplY3QgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxuICAgICAgbmV3IE1lc2hMaW5lTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogbmV3IFRIUkVFLkNvbG9yKDB4ZmY0MGZmKSxcbiAgICAgICAgbGluZVdpZHRoOiAwLjE1LFxuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5yaWdodEJvdW5kYXJ5T2JqZWN0LnJvdGF0aW9uLnggPSBNYXRoLlBJIC8gMjtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcnlPYmplY3QucmVuZGVyT3JkZXIgPSAxO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMucmlnaHRCb3VuZGFyeU9iamVjdCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICAgICAgLy8gVXNlIHNldFRpbWVvdXQgdG8gcXVldWUgdGhlIHJlc29sdXRpb24gdXBkYXRlIGFmdGVyIHRoZSBjYW52YXMgaXMgcmVmbG93ZWQuXG4gICAgICAvLyBUaGlzIGdldHMgYXJvdW5kIHNvbWUgd2VpcmRuZXNzIG5vdGljZWQgd2hlbiBvcGVuaW5nIGFuZCBjbG9zaW5nIENocm9tZSBEZXZlbG9wZXIgVG9vbHMuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuY2FudmFzLmNsaWVudFdpZHRoLCB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgICAgICB0aGlzLmNlbnRlcmxpbmVPYmplY3QubWF0ZXJpYWwudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZSA9IHJlc29sdXRpb247XG4gICAgICAgIHRoaXMubGVmdEJvdW5kYXJ5T2JqZWN0Lm1hdGVyaWFsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLnJpZ2h0Qm91bmRhcnlPYmplY3QubWF0ZXJpYWwudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZSA9IHJlc29sdXRpb247XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZDtcbiAgfVxuXG4gIHNldCBlbmFibGVkKGUpIHtcbiAgICB0aGlzLmlzRW5hYmxlZCA9IGU7XG4gICAgdGhpcy5wb2ludEdyb3VwLnZpc2libGUgPSB0aGlzLm9ic3RhY2xlR3JvdXAudmlzaWJsZSA9ICEhdGhpcy5pc0VuYWJsZWRcbiAgfVxuXG4gIGdldCBzdGF0aWNPYnN0YWNsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzdGFjbGVHcm91cC5jaGlsZHJlbi5tYXAobyA9PiBuZXcgU3RhdGljT2JzdGFjbGUobmV3IFRIUkVFLlZlY3RvcjIoby5wb3NpdGlvbi54LCBvLnBvc2l0aW9uLnopLCAtby5yb3RhdGlvbi56LCBvLnVzZXJEYXRhLndpZHRoLCBvLnVzZXJEYXRhLmhlaWdodCkpO1xuICB9XG5cbiAgZ2V0IGR5bmFtaWNPYnN0YWNsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHluYW1pY09ic3RhY2xlRWRpdG9yLmNvbGxlY3REeW5hbWljT2JzdGFjbGVzKCk7XG4gIH1cblxuICBnZXQgaW5pdGlhbFNwZWVkKCkge1xuICAgIGxldCBzcGVlZCA9IHBhcnNlRmxvYXQodGhpcy5pbml0aWFsU3BlZWREb20udmFsdWUpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oc3BlZWQpIHx8IHNwZWVkIDwgMClcbiAgICAgIHNwZWVkID0gMDtcblxuICAgIHJldHVybiBOdW1iZXIuaXNOYU4oc3BlZWQpIHx8IHNwZWVkIDwgMCA/IElOSVRJQUxfU1BFRURfRkFMTEJBQ0sgOiBzcGVlZDtcbiAgfVxuXG4gIGdldCBzcGVlZExpbWl0KCkge1xuICAgIGxldCBsaW1pdCA9IHBhcnNlRmxvYXQodGhpcy5zcGVlZExpbWl0RG9tLnZhbHVlKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGxpbWl0KSB8fCBsaW1pdCA8IDApXG4gICAgICBsaW1pdCA9IDA7XG5cbiAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGxpbWl0KSB8fCBsaW1pdCA8IDAgPyBTUEVFRF9MSU1JVF9GQUxMQkFDSyA6IGxpbWl0O1xuICB9XG5cbiAgc2NlbmFyaW9Ub0pTT04oKSB7XG4gICAgY29uc3QgdHJ1bmMgPSBuID0+ICtuLnRvRml4ZWQoNSk7XG5cbiAgICBjb25zdCBqc29uID0ge1xuICAgICAgcDogQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdGhpcy5sYW5lUGF0aC5hbmNob3JzLm1hcChhID0+IFt0cnVuYyhhLngpLCB0cnVuYyhhLnkpXSkpLFxuICAgICAgczogdGhpcy5zdGF0aWNPYnN0YWNsZXMubWFwKG8gPT4gby50b0pTT04oKSksXG4gICAgICBkOiB0aGlzLmR5bmFtaWNPYnN0YWNsZUVkaXRvci50b0pTT04oKSxcbiAgICAgIGw6IE51bWJlcih0aGlzLmxhbmVQYXRoLmFyY0xlbmd0aC50b0ZpeGVkKDMpKSxcbiAgICAgIGM6IHtcbiAgICAgICAgczogdGhpcy5pbml0aWFsU3BlZWREb20udmFsdWUsXG4gICAgICAgIHNsOiB0aGlzLnNwZWVkTGltaXREb20udmFsdWUsXG4gICAgICAgIGxwOiB0aGlzLmxhbmVQcmVmZXJlbmNlXG4gICAgICB9LFxuICAgICAgdjogMVxuICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGxvYWRKU09OKGpzb24pIHtcbiAgICBpZiAoanNvbi5wID09PSB1bmRlZmluZWQgfHwganNvbi5wLmxlbmd0aCAlIDIgIT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIGxhbmUgcGF0aC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyQWxsKCk7XG5cbiAgICB0aGlzLmxhbmVQYXRoID0gbmV3IExhbmVQYXRoKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLnAubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHRoaXMuYWRkUG9pbnQobmV3IFRIUkVFLlZlY3RvcjIoanNvbi5wW2ldLCBqc29uLnBbaSArIDFdKSwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmxhbmVQYXRoLnJlc2FtcGxlQWxsKCk7XG4gICAgdGhpcy5yZWJ1aWxkUGF0aEdlb21ldHJ5KCk7XG5cbiAgICBqc29uLnMuZm9yRWFjaChvID0+IHtcbiAgICAgIGNvbnN0IHN0YXRpY09ic3RhY2xlID0gU3RhdGljT2JzdGFjbGUuZnJvbUpTT04obyk7XG4gICAgICB0aGlzLmFkZFN0YXRpY09ic3RhY2xlKG5ldyBUSFJFRS5WZWN0b3IzKHN0YXRpY09ic3RhY2xlLnBvcy54LCAwLCBzdGF0aWNPYnN0YWNsZS5wb3MueSksIHN0YXRpY09ic3RhY2xlLndpZHRoLCBzdGF0aWNPYnN0YWNsZS5oZWlnaHQsIHN0YXRpY09ic3RhY2xlLnJvdClcbiAgICB9KTtcblxuICAgIHRoaXMuZHluYW1pY09ic3RhY2xlRWRpdG9yLmxvYWRKU09OKGpzb24uZCk7XG5cbiAgICBsZXQgaW5pdGlhbFNwZWVkID0gSU5JVElBTF9TUEVFRF9GQUxMQkFDSztcbiAgICBsZXQgc3BlZWRMaW1pdCA9IFNQRUVEX0xJTUlUX0ZBTExCQUNLO1xuICAgIHRyeSB7IGluaXRpYWxTcGVlZCA9IGpzb24uYy5zOyB9IGNhdGNoIChlKSB7IH1cbiAgICB0cnkgeyBzcGVlZExpbWl0ID0ganNvbi5jLnNsOyB9IGNhdGNoIChlKSB7IH1cblxuICAgIHRoaXMuaW5pdGlhbFNwZWVkRG9tLnZhbHVlID0gaW5pdGlhbFNwZWVkO1xuICAgIHRoaXMuc3BlZWRMaW1pdERvbS52YWx1ZSA9IHNwZWVkTGltaXQ7XG5cbiAgICBsZXQgbGFuZVByZWZlcmVuY2UgPSBMQU5FX1BSRUZFUkVOQ0VfRkFMTEJBQ0s7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YoanNvbi5jLmxwKSA9PT0gJ251bWJlcicpXG4gICAgICAgIGxhbmVQcmVmZXJlbmNlID0gTWF0aC5zaWduKGpzb24uYy5scCkgfHwgTEFORV9QUkVGRVJFTkNFX0ZBTExCQUNLO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgdGhpcy5fY2hhbmdlTGFuZVByZWZlcmVuY2UobGFuZVByZWZlcmVuY2UpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHJldHVybjtcblxuICAgIHRoaXMucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5tb3VzZSwgdGhpcy5jYW1lcmEpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHRoaXMucmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RQbGFuZShHUk9VTkRfUExBTkUpO1xuXG4gICAgY29uc3QgW3N0YXRpb24sIGxhdGl0dWRlLCBfYXJvdW5kXSA9IHRoaXMubGFuZVBhdGguc3RhdGlvbkxhdGl0dWRlRnJvbVBvc2l0aW9uKG5ldyBUSFJFRS5WZWN0b3IyKGludGVyc2VjdGlvbi54LCBpbnRlcnNlY3Rpb24ueikpO1xuICAgIHRoaXMuc3RhdHNTdGF0aW9uLnRleHRDb250ZW50ID0gKHN0YXRpb24gfHwgMCkudG9GaXhlZCgxKTtcbiAgICB0aGlzLnN0YXRzTGF0aXR1ZGUudGV4dENvbnRlbnQgPSAobGF0aXR1ZGUgfHwgMCkudG9GaXhlZCgxKTtcblxuICAgIGlmICh0aGlzLmRyYWdnaW5nUG9pbnQpIHtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBvaW50KHRoaXMuZHJhZ2dpbmdQb2ludCwgaW50ZXJzZWN0aW9uLmNsb25lKCkuYWRkKHRoaXMuZHJhZ09mZnNldCkpO1xuICAgICAgICB0aGlzLnJlYnVpbGRQYXRoR2VvbWV0cnkoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZHJhZ2dpbmdPYnN0YWNsZSkge1xuICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZ09ic3RhY2xlID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmdPYnN0YWNsZVByZXZpZXcpIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMuZHJhZ2dpbmdPYnN0YWNsZVByZXZpZXcpO1xuXG4gICAgICAgICAgY29uc3QgW2NlbnRlciwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLl9kaW1lbnNpb25zRnJvbVJlY3QodGhpcy5kcmFnT2Zmc2V0LCBpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgICAgdGhpcy5kcmFnZ2luZ09ic3RhY2xlUHJldmlldyA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgICAgICAgbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkod2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogTk9STUFMX1NUQVRJQ19PQlNUQUNMRV9DT0xPUiwgZGVwdGhUZXN0OiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNCB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZ09ic3RhY2xlUHJldmlldy5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICAgICAgICAgIHRoaXMuZHJhZ2dpbmdPYnN0YWNsZVByZXZpZXcucG9zaXRpb24uY29weShjZW50ZXIpO1xuICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuZHJhZ2dpbmdPYnN0YWNsZVByZXZpZXcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZHJhZ2dpbmdPYnN0YWNsZS5wb3NpdGlvbi5jb3B5KGludGVyc2VjdGlvbi5jbG9uZSgpLmFkZCh0aGlzLmRyYWdPZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5yb3RhdGluZ09ic3RhY2xlKSB7XG4gICAgICBjb25zdCByb3RhdGlvbiA9ICh0aGlzLmRyYWdPZmZzZXQueCAtIHRoaXMubW91c2UueCkgKiAyICogIE1hdGguUEk7XG4gICAgICB0aGlzLnJvdGF0aW5nT2JzdGFjbGUucm90YXRpb24ueiA9IE1hdGgud3JhcEFuZ2xlKHJvdGF0aW9uICsgdGhpcy5pbml0aWFsT2JzdGFjbGVSb3RhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9pbnRHcm91cC5jaGlsZHJlbi5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLm1hdGVyaWFsLmNvbG9yLnNldChOT1JNQUxfUE9JTlRfQ09MT1IpXG4gICAgICAgIHAubWF0ZXJpYWwub3BhY2l0eSA9IE5PUk1BTF9PUEFDSVRZO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub2JzdGFjbGVHcm91cC5jaGlsZHJlbi5mb3JFYWNoKG8gPT4ge1xuICAgICAgICBvLm1hdGVyaWFsLmNvbG9yLnNldChOT1JNQUxfU1RBVElDX09CU1RBQ0xFX0NPTE9SKVxuICAgICAgICBvLm1hdGVyaWFsLm9wYWNpdHkgPSBOT1JNQUxfT1BBQ0lUWTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItZ3JhYicsICdlZGl0b3ItZ3JhYmJpbmcnLCAnZWRpdG9yLXJlbW92aW5nJyk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09ICdwYXRoJyAmJiB0aGlzLnBvaW50R3JvdXAuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgcGlja2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyh0aGlzLnBvaW50R3JvdXAuY2hpbGRyZW4pLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgaWYgKHBpY2tlZCA9PT0gbnVsbCB8fCBwLm9iamVjdC51c2VyRGF0YS5pbmRleCA+IHBpY2tlZC5vYmplY3QudXNlckRhdGEuaW5kZXgpIHBpY2tlZCA9IHA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwaWNrZWQpIHtcbiAgICAgICAgICBwaWNrZWQub2JqZWN0Lm1hdGVyaWFsLmNvbG9yLnNldChIT1ZFUl9QT0lOVF9DT0xPUik7XG4gICAgICAgICAgcGlja2VkLm9iamVjdC5tYXRlcmlhbC5vcGFjaXR5ID0gSE9WRVJfT1BBQ0lUWTtcblxuICAgICAgICAgIGlmICh0aGlzLnJlbW92ZU1vZGUpXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdlZGl0b3ItcmVtb3ZpbmcnKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdlZGl0b3ItZ3JhYicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWRpdE1vZGUgPT0gJ3N0YXRpY09ic3RhY2xlcycgJiYgdGhpcy5vYnN0YWNsZUdyb3VwLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IHBpY2tlZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHModGhpcy5vYnN0YWNsZUdyb3VwLmNoaWxkcmVuKS5mb3JFYWNoKG8gPT4ge1xuICAgICAgICAgIGlmIChwaWNrZWQgPT09IG51bGwgfHwgby5vYmplY3QudXNlckRhdGEuaW5kZXggPiBwaWNrZWQub2JqZWN0LnVzZXJEYXRhLmluZGV4KSBwaWNrZWQgPSBvO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGlja2VkKSB7XG4gICAgICAgICAgcGlja2VkLm9iamVjdC5tYXRlcmlhbC5jb2xvci5zZXQoSE9WRVJfU1RBVElDX09CU1RBQ0xFX0NPTE9SKTtcbiAgICAgICAgICBwaWNrZWQub2JqZWN0Lm1hdGVyaWFsLm9wYWNpdHkgPSBIT1ZFUl9PUEFDSVRZO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVtb3ZlTW9kZSlcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ2VkaXRvci1yZW1vdmluZycpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ2VkaXRvci1ncmFiJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjaGFuZ2VFZGl0TW9kZShtb2RlKSB7XG4gICAgdGhpcy5lZGl0b3JQYXRoQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2lzLW91dGxpbmVkJyk7XG4gICAgdGhpcy5lZGl0b3JPYnN0YWNsZXNCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtb3V0bGluZWQnKTtcbiAgICB0aGlzLmVkaXRvckR5bmFtaWNPYnN0YWNsZXNCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtb3V0bGluZWQnKTtcbiAgICB0aGlzLmVkaXRvclBhdGhCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtc2VsZWN0ZWQnKTtcbiAgICB0aGlzLmVkaXRvck9ic3RhY2xlc0J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1zZWxlY3RlZCcpO1xuICAgIHRoaXMuZWRpdG9yRHluYW1pY09ic3RhY2xlc0J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1zZWxlY3RlZCcpO1xuICAgIHRoaXMuZWRpdG9yUm9hZEJveC5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKTtcbiAgICB0aGlzLmhlbHBQYXRoLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpO1xuICAgIHRoaXMuaGVscFN0YXRpY09ic3RhY2xlcy5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKTtcbiAgICB0aGlzLmhlbHBEeW5hbWljT2JzdGFjbGVzLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpO1xuXG4gICAgaWYgKG1vZGUgPT0gJ3BhdGgnKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gJ3BhdGgnO1xuICAgICAgdGhpcy5lZGl0b3JQYXRoQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLW91dGxpbmVkJyk7XG4gICAgICB0aGlzLmVkaXRvclBhdGhCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtc2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuZWRpdG9yUm9hZEJveC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgICAgIHRoaXMuaGVscFBhdGguY2xhc3NMaXN0LnJlbW92ZSgnaXMtaGlkZGVuJyk7XG4gICAgICB0aGlzLmR5bmFtaWNPYnN0YWNsZUVkaXRvci5kaXNhYmxlKCk7XG4gICAgfSBlbHNlIGlmIChtb2RlID09ICdzdGF0aWNPYnN0YWNsZXMnKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gJ3N0YXRpY09ic3RhY2xlcyc7XG4gICAgICB0aGlzLmVkaXRvck9ic3RhY2xlc0J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1vdXRsaW5lZCcpO1xuICAgICAgdGhpcy5lZGl0b3JPYnN0YWNsZXNCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtc2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuaGVscFN0YXRpY09ic3RhY2xlcy5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgICAgIHRoaXMuZHluYW1pY09ic3RhY2xlRWRpdG9yLmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9ICdkeW5hbWljT2JzdGFjbGVzJztcbiAgICAgIHRoaXMuZWRpdG9yRHluYW1pY09ic3RhY2xlc0J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1vdXRsaW5lZCcpO1xuICAgICAgdGhpcy5lZGl0b3JEeW5hbWljT2JzdGFjbGVzQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2lzLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmhlbHBEeW5hbWljT2JzdGFjbGVzLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICAgICAgdGhpcy5keW5hbWljT2JzdGFjbGVFZGl0b3IuZW5hYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgYWRkU3RhdGljT2JzdGFjbGUoY2VudGVyLCB3aWR0aCwgaGVpZ2h0LCByb3RhdGlvbiA9IDApIHtcbiAgICBjb25zdCBvYnN0YWNsZSA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkod2lkdGgsIGhlaWdodCksXG4gICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogTk9STUFMX1NUQVRJQ19PQlNUQUNMRV9DT0xPUiwgZGVwdGhUZXN0OiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IE5PUk1BTF9PUEFDSVRZIH0pXG4gICAgKTtcbiAgICBvYnN0YWNsZS5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICAgIG9ic3RhY2xlLnJvdGF0aW9uLnogPSAtTWF0aC53cmFwQW5nbGUocm90YXRpb24pO1xuICAgIG9ic3RhY2xlLnBvc2l0aW9uLmNvcHkoY2VudGVyKTtcbiAgICBvYnN0YWNsZS51c2VyRGF0YSA9IHsgaW5kZXg6IHRoaXMub2JzdGFjbGVJbmRleCsrLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cbiAgICB0aGlzLm9ic3RhY2xlR3JvdXAuYWRkKG9ic3RhY2xlKTtcbiAgICB0aGlzLnN0YXRzU3RhdGljT2JzdGFjbGVzLnRleHRDb250ZW50ID0gdGhpcy5vYnN0YWNsZUdyb3VwLmNoaWxkcmVuLmxlbmd0aDtcbiAgfVxuXG4gIHJlbW92ZVN0YXRpY09ic3RhY2xlKG9ic3RhY2xlKSB7XG4gICAgdGhpcy5vYnN0YWNsZUdyb3VwLnJlbW92ZShvYnN0YWNsZSk7XG4gICAgdGhpcy5zdGF0c1N0YXRpY09ic3RhY2xlcy50ZXh0Q29udGVudCA9IHRoaXMub2JzdGFjbGVHcm91cC5jaGlsZHJlbi5sZW5ndGg7XG4gIH1cblxuICBjbGVhclN0YXRpY09ic3RhY2xlcygpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLm9ic3RhY2xlR3JvdXApO1xuICAgIHRoaXMub2JzdGFjbGVHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgIHRoaXMub2JzdGFjbGVHcm91cC5yZW5kZXJPcmRlciA9IDE7XG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5vYnN0YWNsZUdyb3VwKTtcbiAgICB0aGlzLm9ic3RhY2xlSW5kZXggPSAwO1xuICAgIHRoaXMuc3RhdHNTdGF0aWNPYnN0YWNsZXMudGV4dENvbnRlbnQgPSAwO1xuICB9XG5cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5jbGVhclBhdGgoKTtcbiAgICB0aGlzLmNsZWFyU3RhdGljT2JzdGFjbGVzKCk7XG4gICAgdGhpcy5keW5hbWljT2JzdGFjbGVFZGl0b3IuY2xlYXJEeW5hbWljT2JzdGFjbGVzKCk7XG4gIH1cblxuICByZWJ1aWxkUGF0aEdlb21ldHJ5KCkge1xuICAgIGlmICh0aGlzLmxhbmVQYXRoLmFuY2hvcnMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5jZW50ZXJsaW5lR2VvbWV0cnkuc2V0RnJvbVBvaW50cyh0aGlzLmxhbmVQYXRoLmNlbnRlcmxpbmUpO1xuICAgICAgY29uc3QgY2VudGVybGluZSA9IG5ldyBNZXNoTGluZSgpO1xuICAgICAgY2VudGVybGluZS5zZXRHZW9tZXRyeSh0aGlzLmNlbnRlcmxpbmVHZW9tZXRyeSk7XG4gICAgICB0aGlzLmNlbnRlcmxpbmVPYmplY3QuZ2VvbWV0cnkgPSBjZW50ZXJsaW5lLmdlb21ldHJ5O1xuXG4gICAgICB0aGlzLmxlZnRCb3VuZGFyeUdlb21ldHJ5LnNldEZyb21Qb2ludHModGhpcy5sYW5lUGF0aC5sZWZ0Qm91bmRhcnkpO1xuICAgICAgY29uc3QgbGVmdEJvdW5kYXJ5ID0gbmV3IE1lc2hMaW5lKCk7XG4gICAgICBsZWZ0Qm91bmRhcnkuc2V0R2VvbWV0cnkodGhpcy5sZWZ0Qm91bmRhcnlHZW9tZXRyeSk7XG4gICAgICB0aGlzLmxlZnRCb3VuZGFyeU9iamVjdC5nZW9tZXRyeSA9IGxlZnRCb3VuZGFyeS5nZW9tZXRyeTtcblxuICAgICAgdGhpcy5yaWdodEJvdW5kYXJ5R2VvbWV0cnkuc2V0RnJvbVBvaW50cyh0aGlzLmxhbmVQYXRoLnJpZ2h0Qm91bmRhcnkpO1xuICAgICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IG5ldyBNZXNoTGluZSgpO1xuICAgICAgcmlnaHRCb3VuZGFyeS5zZXRHZW9tZXRyeSh0aGlzLnJpZ2h0Qm91bmRhcnlHZW9tZXRyeSk7XG4gICAgICB0aGlzLnJpZ2h0Qm91bmRhcnlPYmplY3QuZ2VvbWV0cnkgPSByaWdodEJvdW5kYXJ5Lmdlb21ldHJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNlbnRlcmxpbmVPYmplY3QuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jZW50ZXJsaW5lT2JqZWN0Lmdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICAgIHRoaXMubGVmdEJvdW5kYXJ5T2JqZWN0Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMubGVmdEJvdW5kYXJ5T2JqZWN0Lmdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICAgIHRoaXMucmlnaHRCb3VuZGFyeU9iamVjdC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLnJpZ2h0Qm91bmRhcnlPYmplY3QuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRzUm9hZExlbmd0aC50ZXh0Q29udGVudCA9IHRoaXMubGFuZVBhdGguYXJjTGVuZ3RoLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDEsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMSB9KTtcbiAgfVxuXG4gIGFkZFBvaW50KHBvcywgcmVzYW1wbGUgPSB0cnVlKSB7XG4gICAgY29uc3QgcG9pbnQgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeSgxLCAzMiksXG4gICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogTk9STUFMX1BPSU5UX0NPTE9SLFxuICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogTk9STUFMX09QQUNJVFlcbiAgICAgIH0pXG4gICAgKTtcbiAgICBwb2ludC5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyO1xuICAgIHBvaW50LnBvc2l0aW9uLnNldChwb3MueCwgMCwgcG9zLnkpO1xuICAgIHBvaW50LnVzZXJEYXRhID0geyBpbmRleDogdGhpcy5wb2ludEluZGV4KysgfTtcblxuICAgIHRoaXMubGFuZVBhdGguYWRkQW5jaG9yKHBvcywgcmVzYW1wbGUpO1xuICAgIHRoaXMucG9pbnRHcm91cC5hZGQocG9pbnQpO1xuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgdXBkYXRlUG9pbnQob2JqZWN0LCBwb3MpIHtcbiAgICBvYmplY3QucG9zaXRpb24uY29weShwb3MpO1xuICAgIHRoaXMubGFuZVBhdGgudXBkYXRlQW5jaG9yKG9iamVjdC51c2VyRGF0YS5pbmRleCwgbmV3IFRIUkVFLlZlY3RvcjIocG9zLngsIHBvcy56KSk7XG4gIH1cblxuICByZW1vdmVQb2ludChvYmplY3QpIHtcbiAgICBjb25zdCBpbmRleCA9IG9iamVjdC51c2VyRGF0YS5pbmRleDtcblxuICAgIHRoaXMucG9pbnRHcm91cC5yZW1vdmUob2JqZWN0KTtcbiAgICB0aGlzLnBvaW50R3JvdXAuY2hpbGRyZW4uZm9yRWFjaChwID0+IHtcbiAgICAgIGlmIChwLnVzZXJEYXRhLmluZGV4ID4gaW5kZXgpIHAudXNlckRhdGEuaW5kZXgtLTtcbiAgICB9KTtcbiAgICB0aGlzLnBvaW50SW5kZXgtLTtcblxuICAgIHRoaXMubGFuZVBhdGgucmVtb3ZlQW5jaG9yKGluZGV4KTtcbiAgfVxuXG4gIGNsZWFyUGF0aCgpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLnBvaW50R3JvdXApO1xuICAgIHRoaXMucG9pbnRHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgIHRoaXMucG9pbnRHcm91cC5yZW5kZXJPcmRlciA9IDI7XG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5wb2ludEdyb3VwKTtcbiAgICB0aGlzLnBvaW50SW5kZXggPSAwO1xuXG4gICAgdGhpcy5sYW5lUGF0aCA9IG5ldyBMYW5lUGF0aCgpO1xuICAgIHRoaXMucmVidWlsZFBhdGhHZW9tZXRyeSgpO1xuXG4gICAgdGhpcy5pbml0aWFsU3BlZWREb20udmFsdWUgPSBJTklUSUFMX1NQRUVEX0ZBTExCQUNLO1xuICAgIHRoaXMuc3BlZWRMaW1pdERvbS52YWx1ZSA9IFNQRUVEX0xJTUlUX0ZBTExCQUNLO1xuICB9XG5cbiAga2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5yZXBlYXQgfHwgdGhpcy5lZGl0TW9kZSAhPSAncGF0aCcgJiYgdGhpcy5lZGl0TW9kZSAhPSAnc3RhdGljT2JzdGFjbGVzJykgcmV0dXJuO1xuXG4gICAgaWYgKGV2ZW50LmtleSA9PSAnU2hpZnQnKSB7XG4gICAgICB0aGlzLnJlbW92ZU1vZGUgPSB0cnVlO1xuICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnZWRpdG9yLXBvaW50aW5nJyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09ICdDb250cm9sJyAmJiB0aGlzLmVkaXRNb2RlID09ICdzdGF0aWNPYnN0YWNsZXMnKSB7XG4gICAgICB0aGlzLnJvdGF0ZU1vZGUgPSB0cnVlO1xuICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnZWRpdG9yLXBvaW50aW5nJyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGtleVVwKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleSA9PSAnU2hpZnQnKSB7XG4gICAgICB0aGlzLnJlbW92ZU1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRvci1wb2ludGluZycsICdlZGl0b3ItcmVtb3ZpbmcnKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PSAnQ29udHJvbCcpIHtcbiAgICAgIHRoaXMucm90YXRlTW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdG9yLXBvaW50aW5nJywgJ2VkaXRvci1ncmFiYmluZycpO1xuICAgIH1cbiAgfVxuXG4gIG1vdXNlRG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc0VuYWJsZWQgfHwgZXZlbnQuYnV0dG9uICE9IDApIHJldHVybjtcblxuICAgIHRoaXMubW91c2UueCA9IChldmVudC5vZmZzZXRYIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpICogMiAtIDE7XG4gICAgdGhpcy5tb3VzZS55ID0gLShldmVudC5vZmZzZXRZIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAqIDIgKyAxO1xuXG4gICAgdGhpcy5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLm1vdXNlLCB0aGlzLmNhbWVyYSk7XG5cbiAgICBpZiAodGhpcy5lZGl0TW9kZSA9PSAncGF0aCcpIHtcbiAgICAgIGxldCBwaWNrZWQgPSBudWxsO1xuICAgICAgdGhpcy5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyh0aGlzLnBvaW50R3JvdXAuY2hpbGRyZW4pLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmIChwaWNrZWQgPT09IG51bGwgfHwgcC5vYmplY3QudXNlckRhdGEuaW5kZXggPiBwaWNrZWQub2JqZWN0LnVzZXJEYXRhLmluZGV4KSBwaWNrZWQgPSBwO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwaWNrZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlTW9kZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlUG9pbnQocGlja2VkLm9iamVjdCk7XG4gICAgICAgICAgdGhpcy5yZWJ1aWxkUGF0aEdlb21ldHJ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdG9yLWdyYWInKTtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdlZGl0b3ItZ3JhYmJpbmcnKTtcblxuICAgICAgICAgIHRoaXMuZHJhZ2dpbmdQb2ludCA9IHBpY2tlZC5vYmplY3Q7XG4gICAgICAgICAgdGhpcy5kcmFnT2Zmc2V0LmNvcHkocGlja2VkLm9iamVjdC5wb3NpdGlvbikuc3ViKHBpY2tlZC5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucmVtb3ZlTW9kZSkge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSB0aGlzLnJheWNhc3Rlci5yYXkuaW50ZXJzZWN0UGxhbmUoR1JPVU5EX1BMQU5FKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hZGRQb2ludChuZXcgVEhSRUUuVmVjdG9yMihpbnRlcnNlY3Rpb24ueCwgaW50ZXJzZWN0aW9uLnopKTtcbiAgICAgICAgICB0aGlzLnJlYnVpbGRQYXRoR2VvbWV0cnkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0TW9kZSA9PSAnc3RhdGljT2JzdGFjbGVzJykge1xuICAgICAgbGV0IHBpY2tlZCA9IG51bGw7XG4gICAgICB0aGlzLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHRoaXMub2JzdGFjbGVHcm91cC5jaGlsZHJlbikuZm9yRWFjaChvID0+IHtcbiAgICAgICAgaWYgKHBpY2tlZCA9PT0gbnVsbCB8fCBvLm9iamVjdC51c2VyRGF0YS5pbmRleCA+IHBpY2tlZC5vYmplY3QudXNlckRhdGEuaW5kZXgpIHBpY2tlZCA9IG87XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBpY2tlZCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVNb2RlKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTdGF0aWNPYnN0YWNsZShwaWNrZWQub2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItZ3JhYicpO1xuICAgICAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ2VkaXRvci1ncmFiYmluZycpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucm90YXRlTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZ09ic3RhY2xlID0gcGlja2VkLm9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE9ic3RhY2xlUm90YXRpb24gPSBwaWNrZWQub2JqZWN0LnJvdGF0aW9uLno7XG4gICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQuc2V0KHRoaXMubW91c2UueCwgdGhpcy5tb3VzZS55LCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ09ic3RhY2xlID0gcGlja2VkLm9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldC5jb3B5KHBpY2tlZC5vYmplY3QucG9zaXRpb24pLnN1YihwaWNrZWQucG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5yZW1vdmVNb2RlICYmICF0aGlzLnJvdGF0ZU1vZGUpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gdGhpcy5yYXljYXN0ZXIucmF5LmludGVyc2VjdFBsYW5lKEdST1VORF9QTEFORSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZHJhZ2dpbmdPYnN0YWNsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kcmFnT2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMubW91c2UueCA9IChldmVudC5vZmZzZXRYIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpICogMiAtIDE7XG4gICAgdGhpcy5tb3VzZS55ID0gLShldmVudC5vZmZzZXRZIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAqIDIgKyAxO1xuICB9XG5cbiAgbW91c2VVcChldmVudCkge1xuICAgIGlmICghdGhpcy5pc0VuYWJsZWQgfHwgZXZlbnQuYnV0dG9uICE9IDApIHJldHVybjtcblxuICAgIGlmICh0aGlzLmRyYWdnaW5nT2JzdGFjbGUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMuZHJhZ2dpbmdPYnN0YWNsZVByZXZpZXcpO1xuICAgICAgdGhpcy5kcmFnZ2luZ09ic3RhY2xlUHJldmlldyA9IG51bGw7XG5cbiAgICAgIHRoaXMubW91c2UueCA9IChldmVudC5vZmZzZXRYIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpICogMiAtIDE7XG4gICAgICB0aGlzLm1vdXNlLnkgPSAtKGV2ZW50Lm9mZnNldFkgLyB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpICogMiArIDE7XG5cbiAgICAgIHRoaXMucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5tb3VzZSwgdGhpcy5jYW1lcmEpO1xuXG4gICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSB0aGlzLnJheWNhc3Rlci5yYXkuaW50ZXJzZWN0UGxhbmUoR1JPVU5EX1BMQU5FKTtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBbY2VudGVyLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuX2RpbWVuc2lvbnNGcm9tUmVjdCh0aGlzLmRyYWdPZmZzZXQsIGludGVyc2VjdGlvbik7XG4gICAgICAgIHRoaXMuYWRkU3RhdGljT2JzdGFjbGUoY2VudGVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRyYWdnaW5nUG9pbnQgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dpbmdPYnN0YWNsZSA9IG51bGw7XG4gICAgdGhpcy5yb3RhdGluZ09ic3RhY2xlID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItZ3JhYicsICdlZGl0b3ItZ3JhYmJpbmcnKTtcbiAgfVxuXG4gIHVwZGF0ZVNhdmVkSW5mbyhuYW1lLCBzYXZlZEF0KSB7XG4gICAgdGhpcy5wcmV2aW91c1NhdmVkTmFtZSA9IG5hbWUgfHwgbnVsbDtcblxuICAgIG5hbWUgPSBuYW1lIHx8ICdVbnRpdGxlZCc7XG4gICAgc2F2ZWRBdCA9IHNhdmVkQXQgfHwgJ1Vuc2F2ZWQnO1xuXG4gICAgdGhpcy5zY2VuYXJpb05hbWVEb20udGV4dENvbnRlbnQgPSBuYW1lO1xuICAgIHRoaXMuc2NlbmFyaW9OYW1lRG9tLnRpdGxlID0gbmFtZTtcbiAgICB0aGlzLnNjZW5hcmlvU2F2ZWRBdERvbS50ZXh0Q29udGVudCA9IHNhdmVkQXQ7XG4gIH1cblxuICBfY2hhbmdlTGFuZVByZWZlcmVuY2UocHJlZikge1xuICAgIHRoaXMubGFuZVByZWZlcmVuY2UgPSBwcmVmO1xuXG4gICAgaWYgKHByZWYgPiAwKSB7XG4gICAgICB0aGlzLmxhbmVMZWZ0RG9tLmNsYXNzTGlzdC5hZGQoJ2lzLW91dGxpbmVkJyk7XG4gICAgICB0aGlzLmxhbmVMZWZ0RG9tLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmxhbmVSaWdodERvbS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1vdXRsaW5lZCcpO1xuICAgICAgdGhpcy5sYW5lUmlnaHREb20uY2xhc3NMaXN0LmFkZCgnaXMtc2VsZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYW5lUmlnaHREb20uY2xhc3NMaXN0LmFkZCgnaXMtb3V0bGluZWQnKTtcbiAgICAgIHRoaXMubGFuZVJpZ2h0RG9tLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmxhbmVMZWZ0RG9tLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLW91dGxpbmVkJyk7XG4gICAgICB0aGlzLmxhbmVMZWZ0RG9tLmNsYXNzTGlzdC5hZGQoJ2lzLXNlbGVjdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgc2F2ZUNsaWNrZWQoKSB7XG4gICAgY29uc3QgbmFtZSA9IHdpbmRvdy5wcm9tcHQoJ05hbWUgeW91ciBzY2VuYXJpbzonLCB0aGlzLnByZXZpb3VzU2F2ZWROYW1lIHx8ICcnKTtcbiAgICBpZiAobmFtZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChuYW1lID09PSAnJykge1xuICAgICAgd2luZG93LmFsZXJ0KCdUaGUgc2NlbmFyaW8gbmFtZSBjYW5ub3QgYmUgYmxhbmsuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IFtzdWNjZXNzLCBzYXZlZEF0XSA9IHRoaXMuc2NlbmFyaW9NYW5hZ2VyLnNhdmVTY2VuYXJpbyhuYW1lLCB0aGlzLnNjZW5hcmlvVG9KU09OKCksIG5hbWUgPT09IHRoaXMucHJldmlvdXNTYXZlZE5hbWUpO1xuICAgIGNvbnN0IGZvcm1hdHRlZFNhdmVkQXQgPSBmb3JtYXREYXRlKHNhdmVkQXQpO1xuXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMudXBkYXRlU2F2ZWRJbmZvKG5hbWUsIGZvcm1hdHRlZFNhdmVkQXQpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlybShgQSBzY2VuYXJpbyBuYW1lZCBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0cywgbGFzdCBzYXZlZCAke2Zvcm1hdHRlZFNhdmVkQXR9LiBEbyB5b3Ugd2FudCB0byBvdmVyd3JpdGUgaXQ/YCkpIHtcbiAgICAgIFtzdWNjZXNzLCBzYXZlZEF0XSA9IHRoaXMuc2NlbmFyaW9NYW5hZ2VyLnNhdmVTY2VuYXJpbyhuYW1lLCB0aGlzLnNjZW5hcmlvVG9KU09OKCksIHRydWUpO1xuICAgICAgdGhpcy51cGRhdGVTYXZlZEluZm8obmFtZSwgZm9ybWF0RGF0ZShzYXZlZEF0KSk7XG4gICAgfVxuICB9XG5cbiAgbG9hZENsaWNrZWQoKSB7XG4gICAgdGhpcy5zY2VuYXJpb01hbmFnZXIuc2hvd01vZGFsKCk7XG4gIH1cblxuICBzaGFyZUNsaWNrZWQoKSB7XG4gICAgdGhpcy5zaGFyZU1hbmFnZXIuc2hvd01vZGFsKHRoaXMuc2NlbmFyaW9Ub0pTT04oKSk7XG4gIH1cblxuICBfZGltZW5zaW9uc0Zyb21SZWN0KGZyb20sIHRvKSB7XG4gICAgY29uc3QgY2VudGVyID0gZnJvbS5jbG9uZSgpLmFkZCh0bykuZGl2aWRlU2NhbGFyKDIpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoMC41LCBNYXRoLmFicyhmcm9tLnggLSB0by54KSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoMC41LCBNYXRoLmFicyhmcm9tLnogLSB0by56KSk7XG4gICAgcmV0dXJuIFtjZW50ZXIsIHdpZHRoLCBoZWlnaHRdO1xuICB9XG59XG4iLCIvKipcbiAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVyaWNoNjY2IC8gaHR0cDovL2VyaWNoYWluZXMuY29tXG4gKi9cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuXG4vLyBVbmxpa2UgVHJhY2tiYWxsQ29udHJvbHMsIGl0IG1haW50YWlucyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBvYmplY3QudXAgKCtZIGJ5IGRlZmF1bHQpLlxuLy9cbi8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUgZmluZ2VyIG1vdmVcbi8vICAgIFpvb20gLSBtaWRkbGUgbW91c2UsIG9yIG1vdXNld2hlZWwgLyB0b3VjaDogdHdvIGZpbmdlciBzcHJlYWQgb3Igc3F1aXNoXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW5nZXIgc3dpcGVcblxuY29uc3QgT3JiaXRDb250cm9scyA9IGZ1bmN0aW9uICggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0Ly8gXCJ0YXJnZXRcIiBzZXRzIHRoZSBsb2NhdGlvbiBvZiBmb2N1cywgd2hlcmUgdGhlIG9iamVjdCBvcmJpdHMgYXJvdW5kXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dCAoIFBlcnNwZWN0aXZlQ2FtZXJhIG9ubHkgKVxuXHR0aGlzLm1pbkRpc3RhbmNlID0gMDtcblx0dGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG5cdC8vIEhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXG5cdHRoaXMubWluWm9vbSA9IDA7XG5cdHRoaXMubWF4Wm9vbSA9IEluZmluaXR5O1xuXG5cdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHQvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cblx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xuXHR0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IGhvcml6b250YWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0Ly8gSWYgc2V0LCBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIHRoZSBpbnRlcnZhbCBbIC0gTWF0aC5QSSwgTWF0aC5QSSBdLlxuXHR0aGlzLm1pbkF6aW11dGhBbmdsZSA9IC0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblx0dGhpcy5tYXhBemltdXRoQW5nbGUgPSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXG5cdC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuXHQvLyBJZiBkYW1waW5nIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXHR0aGlzLmVuYWJsZURhbXBpbmcgPSBmYWxzZTtcblx0dGhpcy5kYW1waW5nRmFjdG9yID0gMC4yNTtcblxuXHQvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nXG5cdHRoaXMuZW5hYmxlWm9vbSA9IHRydWU7XG5cdHRoaXMuem9vbVNwZWVkID0gMS4wO1xuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG5cdHRoaXMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcblx0dGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcblxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG5cdHRoaXMuZW5hYmxlUGFuID0gdHJ1ZTtcblx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuXHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0dGhpcy5hdXRvUm90YXRlID0gZmFsc2U7XG5cdHRoaXMuYXV0b1JvdGF0ZVNwZWVkID0gMi4wOyAvLyAzMCBzZWNvbmRzIHBlciByb3VuZCB3aGVuIGZwcyBpcyA2MFxuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHVzZSBvZiB0aGUga2V5c1xuXHR0aGlzLmVuYWJsZUtleXMgPSB0cnVlO1xuXG5cdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0dGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcblxuXHQvLyBNb3VzZSBidXR0b25zXG5cdHRoaXMubW91c2VCdXR0b25zID0geyBPUkJJVDogVEhSRUUuTU9VU0UuTEVGVCwgWk9PTTogVEhSRUUuTU9VU0UuTUlERExFLCBQQU46IFRIUkVFLk1PVVNFLlJJR0hUIH07XG5cblx0Ly8gZm9yIHJlc2V0XG5cdHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG5cdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblx0dGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207XG5cblx0Ly9cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0Ly9cblxuXHR0aGlzLmdldFBvbGFyQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0QXppbXV0aGFsQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xuXG5cdH07XG5cblx0dGhpcy5zYXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRzY29wZS50YXJnZXQwLmNvcHkoIHNjb3BlLnRhcmdldCApO1xuXHRcdHNjb3BlLnBvc2l0aW9uMC5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRzY29wZS56b29tMCA9IHNjb3BlLm9iamVjdC56b29tO1xuXG5cdH07XG5cblx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHNjb3BlLnRhcmdldC5jb3B5KCBzY29wZS50YXJnZXQwICk7XG5cdFx0c2NvcGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHNjb3BlLnBvc2l0aW9uMCApO1xuXHRcdHNjb3BlLm9iamVjdC56b29tID0gc2NvcGUuem9vbTA7XG5cblx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR9O1xuXG4gIHRoaXMucm90YXRlTGVmdCA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgcm90YXRlTGVmdChhbmdsZSk7XG4gIH1cblxuXHQvLyB0aGlzIG1ldGhvZCBpcyBleHBvc2VkLCBidXQgcGVyaGFwcyBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgY2FuIG1ha2UgaXQgcHJpdmF0ZS4uLlxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0Ly8gc28gY2FtZXJhLnVwIGlzIHRoZSBvcmJpdCBheGlzXG5cdFx0dmFyIHF1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyggb2JqZWN0LnVwLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG5cdFx0dmFyIHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVyc2UoKTtcblxuXHRcdHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBsYXN0UXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cblx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdC8vIHJvdGF0ZSBvZmZzZXQgdG8gXCJ5LWF4aXMtaXMtdXBcIiBzcGFjZVxuXHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApO1xuXG5cdFx0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cdFx0XHRzcGhlcmljYWwuc2V0RnJvbVZlY3RvcjMoIG9mZnNldCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0cm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YTtcblx0XHRcdHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpO1xuXG5cdFx0XHQvLyByZXN0cmljdCB0aGV0YSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0XHRzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heCggc2NvcGUubWluQXppbXV0aEFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4QXppbXV0aEFuZ2xlLCBzcGhlcmljYWwudGhldGEgKSApO1xuXG5cdFx0XHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0c3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KCBzY29wZS5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4UG9sYXJBbmdsZSwgc3BoZXJpY2FsLnBoaSApICk7XG5cblx0XHRcdHNwaGVyaWNhbC5tYWtlU2FmZSgpO1xuXG5cblx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgKj0gc2NhbGU7XG5cblx0XHRcdC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0XHRzcGhlcmljYWwucmFkaXVzID0gTWF0aC5tYXgoIHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbiggc2NvcGUubWF4RGlzdGFuY2UsIHNwaGVyaWNhbC5yYWRpdXMgKSApO1xuXG5cdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblx0XHRcdHNjb3BlLnRhcmdldC5hZGQoIHBhbk9mZnNldCApO1xuXG5cdFx0XHRvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbCggc3BoZXJpY2FsICk7XG5cblx0XHRcdC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuXHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcblxuXHRcdFx0cG9zaXRpb24uY29weSggc2NvcGUudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcblxuXHRcdFx0c2NvcGUub2JqZWN0Lmxvb2tBdCggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cdFx0XHRcdHNwaGVyaWNhbERlbHRhLnBoaSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3BoZXJpY2FsRGVsdGEuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NhbGUgPSAxO1xuXHRcdFx0cGFuT2Zmc2V0LnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHQvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuXHRcdFx0Ly8gbWluKGNhbWVyYSBkaXNwbGFjZW1lbnQsIGNhbWVyYSByb3RhdGlvbiBpbiByYWRpYW5zKV4yID4gRVBTXG5cdFx0XHQvLyB1c2luZyBzbWFsbC1hbmdsZSBhcHByb3hpbWF0aW9uIGNvcyh4LzIpID0gMSAtIHheMiAvIDhcblxuXHRcdFx0aWYgKCB6b29tQ2hhbmdlZCB8fFxuXHRcdFx0XHRsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApID4gRVBTIHx8XG5cdFx0XHRcdDggKiAoIDEgLSBsYXN0UXVhdGVybmlvbi5kb3QoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICkgKSA+IEVQUyApIHtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xuXG5cdFx0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRcdFx0bGFzdFF1YXRlcm5pb24uY29weSggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKTtcblx0XHRcdFx0em9vbUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUsIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UgKTtcblxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcblxuXHRcdC8vc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApOyAvLyBzaG91bGQgdGhpcyBiZSBhZGRlZCBoZXJlP1xuXG5cdH07XG5cblx0Ly9cblx0Ly8gaW50ZXJuYWxzXG5cdC8vXG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5cdHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnIH07XG5cdHZhciBlbmRFdmVudCA9IHsgdHlwZTogJ2VuZCcgfTtcblxuXHR2YXIgU1RBVEUgPSB7IE5PTkU6IC0gMSwgUk9UQVRFOiAwLCBET0xMWTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX0RPTExZOiA0LCBUT1VDSF9QQU46IDUgfTtcblxuXHR2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHQvLyBjdXJyZW50IHBvc2l0aW9uIGluIHNwaGVyaWNhbCBjb29yZGluYXRlc1xuXHR2YXIgc3BoZXJpY2FsID0gbmV3IFRIUkVFLlNwaGVyaWNhbCgpO1xuXHR2YXIgc3BoZXJpY2FsRGVsdGEgPSBuZXcgVEhSRUUuU3BoZXJpY2FsKCk7XG5cblx0dmFyIHNjYWxlID0gMTtcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdHZhciByb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBwYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBkb2xseVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGRvbGx5RGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuXG5cdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XG5cblx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAtPSBhbmdsZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xuXG5cdFx0c3BoZXJpY2FsRGVsdGEucGhpIC09IGFuZ2xlO1xuXG5cdH1cblxuXHR2YXIgcGFuTGVmdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYW5MZWZ0KCBkaXN0YW5jZSwgb2JqZWN0TWF0cml4ICkge1xuXG5cdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApOyAvLyBnZXQgWCBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XG5cdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRcdHBhbk9mZnNldC5hZGQoIHYgKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdHZhciBwYW5VcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYW5VcCggZGlzdGFuY2UsIG9iamVjdE1hdHJpeCApIHtcblxuXHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDEgKTsgLy8gZ2V0IFkgY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblxuXHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0Ly8gZGVsdGFYIGFuZCBkZWx0YVkgYXJlIGluIHBpeGVsczsgcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG5cdHZhciBwYW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYW4oIGRlbHRhWCwgZGVsdGFZICkge1xuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0aWYgKCBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHQvLyBwZXJzcGVjdGl2ZVxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdHZhciB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcblxuXHRcdFx0XHQvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cblx0XHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHRcdC8vIHdlIGFjdHVhbGx5IGRvbid0IHVzZSBzY3JlZW5XaWR0aCwgc2luY2UgcGVyc3BlY3RpdmUgY2FtZXJhIGlzIGZpeGVkIHRvIHNjcmVlbiBoZWlnaHRcblx0XHRcdFx0cGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0cGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHQvLyBvcnRob2dyYXBoaWNcblx0XHRcdFx0cGFuTGVmdCggZGVsdGFYICogKCBzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCApIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudFdpZHRoLCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cdFx0XHRcdHBhblVwKCBkZWx0YVkgKiAoIHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG5vciBwZXJzcGVjdGl2ZVxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVQYW4gPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0ZnVuY3Rpb24gZG9sbHlJbiggZG9sbHlTY2FsZSApIHtcblxuXHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAqIGRvbGx5U2NhbGUgKSApO1xuXHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0c2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkb2xseU91dCggZG9sbHlTY2FsZSApIHtcblxuXHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIGRvbGx5U2NhbGUgKSApO1xuXHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0c2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXHQvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxuXHQvL1xuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUm90YXRlJyApO1xuXG5cdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25Eb2xseScgKTtcblxuXHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blBhbiggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUGFuJyApO1xuXG5cdFx0cGFuU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUm90YXRlJyApO1xuXG5cdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdHJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG5cdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZU1vdmVEb2xseScgKTtcblxuXHRcdGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fSBlbHNlIGlmICggZG9sbHlEZWx0YS55IDwgMCApIHtcblxuXHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9XG5cblx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZU1vdmVQYW4nICk7XG5cblx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cblx0XHRwYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuXHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdoYW5kbGVNb3VzZVVwJyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VXaGVlbCcgKTtcblxuXHRcdGlmICggZXZlbnQuZGVsdGFZIDwgMCApIHtcblxuXHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZWx0YVkgPiAwICkge1xuXG5cdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fVxuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUtleURvd24oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZUtleURvd24nICk7XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuVVA6XG5cdFx0XHRcdHBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXHRcdFx0XHRwYW4oIDAsIC0gc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcblx0XHRcdFx0cGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcblx0XHRcdFx0cGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFJvdGF0ZScgKTtcblxuXHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0RG9sbHknICk7XG5cblx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG5cdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0ZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRQYW4nICk7XG5cblx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlUm90YXRlJyApO1xuXG5cdFx0cm90YXRlRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRyb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlRG9sbHknICk7XG5cblx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG5cdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXG5cdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9XG5cblx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVQYW4nICk7XG5cblx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuXG5cdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hFbmQnICk7XG5cblx0fVxuXG5cdC8vXG5cdC8vIGV2ZW50IGhhbmRsZXJzIC0gRlNNOiBsaXN0ZW4gZm9yIGV2ZW50cyBhbmQgcmVzZXQgc3RhdGVcblx0Ly9cblxuXHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmJ1dHRvbiApIHtcblxuXHRcdFx0Y2FzZSBzY29wZS5tb3VzZUJ1dHRvbnMuT1JCSVQ6XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5tb3VzZUJ1dHRvbnMuWk9PTTpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUubW91c2VCdXR0b25zLlBBTjpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRzd2l0Y2ggKCBzdGF0ZSApIHtcblxuXHRcdFx0Y2FzZSBTVEFURS5ST1RBVEU6XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTVEFURS5ET0xMWTpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFNUQVRFLlBBTjpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGhhbmRsZU1vdXNlVXAoIGV2ZW50ICk7XG5cblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCAoIHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUgKSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRoYW5kbGVNb3VzZVdoZWVsKCBldmVudCApO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApOyAvLyBub3Qgc3VyZSB3aHkgdGhlc2UgYXJlIGhlcmUuLi5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVLZXlzID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aGFuZGxlS2V5RG93biggZXZlbnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOlx0Ly8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAyOlx0Ly8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUk9UQVRFICkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuXHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuXHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGhhbmRsZVRvdWNoRW5kKCBldmVudCApO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Db250ZXh0TWVudSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHR9XG5cblx0Ly9cblxuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUsIGZhbHNlICk7XG5cblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xuXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlICk7XG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UgKTtcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlICk7XG5cblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xuXG5cdC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cbk9yYml0Q29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApO1xuT3JiaXRDb250cm9scy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmJpdENvbnRyb2xzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggT3JiaXRDb250cm9scy5wcm90b3R5cGUsIHtcblxuXHRjZW50ZXI6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdPcmJpdENvbnRyb2xzOiAuY2VudGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnRhcmdldCcgKTtcblx0XHRcdHJldHVybiB0aGlzLnRhcmdldDtcblxuXHRcdH1cblxuXHR9LFxuXG5cdC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuXHRub1pvb206IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdPcmJpdENvbnRyb2xzOiAubm9ab29tIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlWm9vbSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlWm9vbTtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ09yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5lbmFibGVab29tID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdG5vUm90YXRlOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnT3JiaXRDb250cm9sczogLm5vUm90YXRlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUm90YXRlIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVSb3RhdGU7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdPcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZVJvdGF0ZSA9ICEgdmFsdWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRub1Bhbjoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ09yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlUGFuO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5lbmFibGVQYW4gPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bm9LZXlzOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnT3JiaXRDb250cm9sczogLm5vS2V5cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZUtleXMgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZUtleXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdPcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZW5hYmxlS2V5cyA9ICEgdmFsdWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRzdGF0aWNNb3Zpbmc6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdPcmJpdENvbnRyb2xzOiAuc3RhdGljTW92aW5nIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlRGFtcGluZyBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlRGFtcGluZztcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ09yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5lbmFibGVEYW1waW5nID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGR5bmFtaWNEYW1waW5nRmFjdG9yOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnT3JiaXRDb250cm9sczogLmR5bmFtaWNEYW1waW5nRmFjdG9yIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSAuZGFtcGluZ0ZhY3RvciBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmRhbXBpbmdGYWN0b3I7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdPcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5kYW1waW5nRmFjdG9yID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fVxuXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IE9yYml0Q29udHJvbHM7XG4iLCJjb25zdCBncm91bmRQbGFuZSA9IG5ldyBUSFJFRS5QbGFuZShuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSk7XG5sZXQgcGFubmluZyA9IGZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BEb3duQ2FtZXJhQ29udHJvbHMge1xuICBjb25zdHJ1Y3Rvcihkb21FbGVtZW50LCBjYW1lcmEpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuZW5hYmxlUGFubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICB0aGlzLm1pbkFsdGl0dWRlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHRoaXMubWF4QWx0aXR1ZGUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICB0aGlzLm1vdXNlRG93biA9IHRoaXMubW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tb3VzZU1vdmUgPSB0aGlzLm1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubW91c2VVcCA9IHRoaXMubW91c2VVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMud2hlZWwgPSB0aGlzLndoZWVsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd24pO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZSk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMud2hlZWwpO1xuICB9XG5cbiAgcmVzZXQocHJldkNhbWVyYSkge1xuICAgIGNvbnN0IGxvb2tBdCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBsb29rQXQuYXBwbHlRdWF0ZXJuaW9uKHByZXZDYW1lcmEucXVhdGVybmlvbik7XG5cbiAgICBjb25zdCByYXkgPSBuZXcgVEhSRUUuUmF5KHByZXZDYW1lcmEucG9zaXRpb24sIGxvb2tBdCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmF5LmludGVyc2VjdFBsYW5lKGdyb3VuZFBsYW5lKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldChpbnRlcnNlY3Rpb24ueCwgNTAsIGludGVyc2VjdGlvbi56KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueSA9IDUwO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLnJvdGF0aW9uLnNldCgtTWF0aC5QSSAvIDIsIDAsIDApO1xuICB9XG5cbiAgbW91c2VEb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuZW5hYmxlUGFubmluZyB8fCBldmVudC5idXR0b24gIT0gMikgcmV0dXJuO1xuICAgIHBhbm5pbmcgPSB0cnVlO1xuICB9XG5cbiAgbW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKHBhbm5pbmcpIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gMiAqIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgKiBNYXRoLnRhbigodGhpcy5jYW1lcmEuZm92IC8gMikgKiBNYXRoLlBJIC8gMTgwKSAvIHRoaXMuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi54IC09IGRpc3RhbmNlICogZXZlbnQubW92ZW1lbnRYO1xuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiAtPSBkaXN0YW5jZSAqIGV2ZW50Lm1vdmVtZW50WTtcbiAgICB9XG4gIH1cblxuICBtb3VzZVVwKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAyKSByZXR1cm47XG4gICAgcGFubmluZyA9IGZhbHNlO1xuICB9XG5cbiAgd2hlZWwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgPSBNYXRoLm1heCh0aGlzLm1pbkFsdGl0dWRlLCBNYXRoLm1pbih0aGlzLm1heEFsdGl0dWRlLCB0aGlzLmNhbWVyYS5wb3NpdGlvbi55ICogTWF0aC5wb3coMC45OTUsIC1ldmVudC5kZWx0YVkpKSk7XG4gIH1cbn1cbiIsImltcG9ydCBDYXIgZnJvbSBcIi4uL3BoeXNpY3MvQ2FyLmpzXCI7XG5cbmNvbnN0IE1QU19UT19NUEggPSAyLjIzNjk0O1xuY29uc3QgTUVURVJTX1RPX0ZFRVQgPSAzLjI4MDg0O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXNoYm9hcmQge1xuICBjb25zdHJ1Y3RvcihjYXIpIHtcbiAgICB0aGlzLmNhciA9IGNhcjtcbiAgICB0aGlzLnVuaXRzID0gJ21ldHJpYyc7XG5cbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICB0aGlzLmZldGNoRG9tRWxlbWVudHMuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpXG4gICAgICAgICAgdGhpcy5mZXRjaERvbUVsZW1lbnRzLmNhbGwodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmZXRjaERvbUVsZW1lbnRzKCkge1xuICAgIHRoaXMud2hlZWxEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2hlZWwnKTtcbiAgICB0aGlzLndoZWVsUGllRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3doZWVsLXBpZScpO1xuICAgIHRoaXMud2hlZWxQaWVMZWZ0RG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3doZWVsLXBpZS1sZWZ0Jyk7XG4gICAgdGhpcy53aGVlbFBpZVJpZ2h0RG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3doZWVsLXBpZS1yaWdodCcpO1xuICAgIHRoaXMuZ2VhckRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnZWFyJyk7XG4gICAgdGhpcy5nYXNEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FzJyk7XG4gICAgdGhpcy5icmFrZURvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdicmFrZScpO1xuICAgIHRoaXMuc3BlZWREb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BlZWQnKTtcbiAgICB0aGlzLnN0YXRpb25Eb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGlvbicpO1xuICAgIHRoaXMubGF0aXR1ZGVEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGF0aXR1ZGUnKTtcbiAgICB0aGlzLnBsYW5UaW1lRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsYW4tdGltZScpO1xuICAgIHRoaXMuZWxhcHNlZFRpbWVEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWxhcHNlZC10aW1lJyk7XG5cbiAgICB0aGlzLnNwZWVkVW5pdHNEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BlZWQtdW5pdHMnKTtcbiAgICB0aGlzLnN0YXRpb25Vbml0c0RvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0aW9uLXVuaXRzJyk7XG4gICAgdGhpcy5sYXRpdHVkZVVuaXRzRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhdGl0dWRlLXVuaXRzJyk7XG5cbiAgICBbdGhpcy5zcGVlZFVuaXRzRG9tLCB0aGlzLnN0YXRpb25Vbml0c0RvbSwgdGhpcy5sYXRpdHVkZVVuaXRzRG9tXS5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZVVuaXRzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHRvZ2dsZVVuaXRzKCkge1xuICAgIGxldCBzcGVlZFVuaXRzO1xuICAgIGxldCBkaXN0YW5jZVVuaXRzO1xuXG4gICAgaWYgKHRoaXMudW5pdHMgPT0gJ21ldHJpYycpIHtcbiAgICAgIHRoaXMudW5pdHMgPSAnaW1wZXJpYWwnO1xuICAgICAgc3BlZWRVbml0cyA9ICdtcGgnO1xuICAgICAgZGlzdGFuY2VVbml0cyA9ICdmZWV0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bml0cyA9ICdtZXRyaWMnO1xuICAgICAgc3BlZWRVbml0cyA9ICdtL3MnO1xuICAgICAgZGlzdGFuY2VVbml0cyA9ICdtZXRlcnMnO1xuICAgIH1cblxuICAgIC8vIHRoaXMuc3BlZWRVbml0c0RvbS50ZXh0Q29udGVudCA9IHNwZWVkVW5pdHM7XG4gICAgLy8gdGhpcy5zdGF0aW9uVW5pdHNEb20udGV4dENvbnRlbnQgPSBkaXN0YW5jZVVuaXRzO1xuICAgIC8vIHRoaXMubGF0aXR1ZGVVbml0c0RvbS50ZXh0Q29udGVudCA9IGRpc3RhbmNlVW5pdHM7XG4gIH1cblxuICB1cGRhdGVQbGFuVGltZShwbGFuVGltZSkge1xuICAgIGlmICghdGhpcy53aGVlbERvbSkgcmV0dXJuO1xuXG4gICAgLy90aGlzLnBsYW5UaW1lRG9tLnRleHRDb250ZW50ID0gcGxhblRpbWUgIT09IG51bGwgPyAocGxhblRpbWUgKiAxMDAwKS50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHsgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAwIH0pIDogJ+KAlCc7XG4gIH1cblxuICB1cGRhdGUoY29udHJvbHMsIHNwZWVkLCBzdGF0aW9uLCBsYXRpdHVkZSwgZWxhcHNlZFRpbWUsIHBsYW5UaW1lKSB7XG4gICAgaWYgKCF0aGlzLndoZWVsRG9tKSByZXR1cm47XG5cbiAgICBjb25zdCB3aGVlbFR1cm4gPSBNYXRoLmNsYW1wKHRoaXMuY2FyLndoZWVsQW5nbGUgLyBDYXIuTUFYX1dIRUVMX0FOR0xFICogMC45NSwgLTEsICsxKTtcblxuICAgIHRoaXMud2hlZWxEb20uc3R5bGUudHJhbnNmb3JtID0gYHJvdGF0ZSgke3doZWVsVHVybn10dXJuKWA7XG5cbiAgICBpZiAod2hlZWxUdXJuID49IDApIHtcbiAgICAgIHRoaXMud2hlZWxQaWVSaWdodERvbS5zdHlsZS50cmFuc2Zvcm0gPSBgcm90YXRlKCR7d2hlZWxUdXJufXR1cm4pYDtcblxuICAgICAgaWYgKHdoZWVsVHVybiA8PSAwLjUpIHtcbiAgICAgICAgdGhpcy53aGVlbFBpZURvbS5zdHlsZS5jbGlwUGF0aCA9IFwiaW5zZXQoMCAwIDAgNTAlKVwiO1xuICAgICAgICB0aGlzLndoZWVsUGllTGVmdERvbS5zdHlsZS50cmFuc2Zvcm0gPSBcInJvdGF0ZSgwKVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53aGVlbFBpZURvbS5zdHlsZS5jbGlwUGF0aCA9IFwiaW5zZXQoMCAwIDAgMClcIjtcbiAgICAgICAgdGhpcy53aGVlbFBpZUxlZnREb20uc3R5bGUudHJhbnNmb3JtID0gXCJyb3RhdGUoMC41dHVybilcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aGVlbFBpZVJpZ2h0RG9tLnN0eWxlLnRyYW5zZm9ybSA9IGByb3RhdGUoJHswLjUgKyB3aGVlbFR1cm59dHVybilgO1xuXG4gICAgICBpZiAod2hlZWxUdXJuID49IC0wLjUpIHtcbiAgICAgICAgdGhpcy53aGVlbFBpZURvbS5zdHlsZS5jbGlwUGF0aCA9IFwiaW5zZXQoMCA1MCUgMCAwKVwiO1xuICAgICAgICB0aGlzLndoZWVsUGllTGVmdERvbS5zdHlsZS50cmFuc2Zvcm0gPSBcInJvdGF0ZSgwLjV0dXJuKVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53aGVlbFBpZURvbS5zdHlsZS5jbGlwUGF0aCA9IFwiaW5zZXQoMCAwIDAgMClcIjtcbiAgICAgICAgdGhpcy53aGVlbFBpZUxlZnREb20uc3R5bGUudHJhbnNmb3JtID0gXCJyb3RhdGUoMClcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmdlYXJEb20uaW5uZXJUZXh0ID0gY29udHJvbHMuZ2FzIDwgMCA/ICdSJyA6ICdEJztcbiAgICB0aGlzLmJyYWtlRG9tLnN0eWxlLmNsaXBQYXRoID0gYGluc2V0KDUwJSA1MCUgMCAkezUwIC0gY29udHJvbHMuYnJha2UgKiAyNX0lKWA7XG4gICAgdGhpcy5nYXNEb20uc3R5bGUuY2xpcFBhdGggPSBgaW5zZXQoNTAlICR7NTAgLSBNYXRoLmFicyhjb250cm9scy5nYXMpICogMjV9JSAwIDUwJSlgO1xuXG4gICAgaWYgKHRoaXMudW5pdHMgPT0gJ2ltcGVyaWFsJykge1xuICAgICAgc3BlZWQgKj0gTVBTX1RPX01QSDtcbiAgICAgIHN0YXRpb24gPSBzdGF0aW9uICE9PSBudWxsID8gc3RhdGlvbiAqIE1FVEVSU19UT19GRUVUIDogbnVsbDtcbiAgICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IG51bGwgPyBsYXRpdHVkZSAqIE1FVEVSU19UT19GRUVUIDogbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgbGF0aXR1ZGVUZXh0ID0gbGF0aXR1ZGUgIT09IG51bGwgPyBsYXRpdHVkZS50b0ZpeGVkKDIpIDogJ+KAlCc7XG4gICAgaWYgKGxhdGl0dWRlVGV4dCA9PSAnLTAuMDAnKSBsYXRpdHVkZVRleHQgPSAnMC4wMCc7XG5cbiAgICB0aGlzLnNwZWVkRG9tLnRleHRDb250ZW50ID0gc3BlZWQudG9GaXhlZCgxKTtcbiAgICB0aGlzLnN0YXRpb25Eb20udGV4dENvbnRlbnQgPSBzdGF0aW9uICE9PSBudWxsID8gc3RhdGlvbi50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAxLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDEgfSkgOiAn4oCUJztcbiAgICB0aGlzLmxhdGl0dWRlRG9tLnRleHRDb250ZW50ID0gbGF0aXR1ZGVUZXh0O1xuICAgIHRoaXMudXBkYXRlUGxhblRpbWUocGxhblRpbWUpO1xuXG4gICAgbGV0IG1pbnMgPSBNYXRoLmZsb29yKGVsYXBzZWRUaW1lIC8gNjApO1xuICAgIGxldCBzZWNvbmRzID0gZWxhcHNlZFRpbWUgJSA2MDtcblxuICAgIGlmIChtaW5zID09IDApIHtcbiAgICAgIHRoaXMuZWxhcHNlZFRpbWVEb20udGV4dENvbnRlbnQgPSBzZWNvbmRzLnRvRml4ZWQoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWNvbmRzIDwgMTApXG4gICAgICAgIHNlY29uZHMgPSAnMCcgKyBzZWNvbmRzLnRvRml4ZWQoMSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlY29uZHMgPSBzZWNvbmRzLnRvRml4ZWQoMSk7XG5cbiAgICAgIHRoaXMuZWxhcHNlZFRpbWVEb20udGV4dENvbnRlbnQgPSBgJHttaW5zfToke3NlY29uZHN9YDtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvYWRMYXR0aWNlIHtcbiAgY29uc3RydWN0b3IobGFuZVBhdGgsIGxhdHRpY2VTdGFydFN0YXRpb24sIGNvbmZpZykge1xuICAgIGNvbnN0IHN0YXRpb25JbnRlcnZhbCA9IGNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIGNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zO1xuICAgIGNvbnN0IGNlbnRlcmxpbmUgPSBsYW5lUGF0aC5zYW1wbGVTdGF0aW9ucyhsYXR0aWNlU3RhcnRTdGF0aW9uLCBjb25maWcubGF0dGljZS5udW1TdGF0aW9ucywgc3RhdGlvbkludGVydmFsKTtcbiAgICBjb25zdCBsYXR0aWNlID0gbmV3IEFycmF5KGNlbnRlcmxpbmUubGVuZ3RoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyAvIDIpO1xuXG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjZW50ZXJsaW5lLmxlbmd0aDsgcysrKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSBjZW50ZXJsaW5lW3NdO1xuICAgICAgY29uc3QgbGF0aXR1ZGVzID0gbGF0dGljZVtzXSA9IG5ldyBBcnJheShjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMpO1xuXG4gICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlczsgbCsrKSB7XG4gICAgICAgIGNvbnN0IGxhdGl0dWRlID0gKGwgLSBvZmZzZXQpIC8gb2Zmc2V0ICogY29uZmlnLnJvYWRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJvdCA9IHNhbXBsZS5yb3Q7XG4gICAgICAgIGNvbnN0IHBvcyA9IFRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlKHJvdCArIE1hdGguUEkgLyAyKS5tdWx0aXBseVNjYWxhcihsYXRpdHVkZSkuYWRkKHNhbXBsZS5wb3MpO1xuICAgICAgICBjb25zdCBjdXJ2ID0gc2FtcGxlLmN1cnYgPT0gMCA/IDAgOiAxIC8gKDEgLyBzYW1wbGUuY3VydiAtIGxhdGl0dWRlKTtcblxuICAgICAgICBsYXRpdHVkZXNbbF0gPSB7IHBvcywgcm90LCBjdXJ2IH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXR0aWNlID0gbGF0dGljZTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92aW5nQXZlcmFnZSB7XG4gIGNvbnN0cnVjdG9yKG1heFNhbXBsZXMpIHtcbiAgICB0aGlzLnNhbXBsZXMgPSBuZXcgQXJyYXkobWF4U2FtcGxlcyk7XG4gICAgdGhpcy5udW1TYW1wbGVzID0gMDtcbiAgICB0aGlzLm5leHRJbmRleCA9IDA7XG4gICAgdGhpcy5hdmVyYWdlID0gbnVsbDtcbiAgfVxuXG4gIGFkZFNhbXBsZShzYW1wbGUpIHtcbiAgICB0aGlzLnNhbXBsZXNbdGhpcy5uZXh0SW5kZXgrK10gPSBzYW1wbGU7XG4gICAgdGhpcy5uZXh0SW5kZXggPSB0aGlzLm5leHRJbmRleCAlIHRoaXMuc2FtcGxlcy5sZW5ndGg7XG4gICAgdGhpcy5udW1TYW1wbGVzID0gTWF0aC5taW4odGhpcy5udW1TYW1wbGVzICsgMSwgdGhpcy5zYW1wbGVzLmxlbmd0aCk7XG5cbiAgICBjb25zdCBrID0gMiAvICh0aGlzLm51bVNhbXBsZXMgKyAxKTtcbiAgICBsZXQgY3VyciA9IHRoaXMubmV4dEluZGV4ICUgdGhpcy5udW1TYW1wbGVzO1xuICAgIGxldCBuZXdBdmVyYWdlID0gdGhpcy5zYW1wbGVzW2N1cnJdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLm51bVNhbXBsZXM7IGkrKykge1xuICAgICAgY3VyciA9IChjdXJyICsgMSkgJSB0aGlzLm51bVNhbXBsZXM7XG4gICAgICBuZXdBdmVyYWdlID0gdGhpcy5zYW1wbGVzW2N1cnJdICogayArIG5ld0F2ZXJhZ2UgKiAoMSAtIGspO1xuICAgIH1cblxuICAgIHRoaXMuYXZlcmFnZSA9IG5ld0F2ZXJhZ2U7XG4gIH1cbn1cbiIsImltcG9ydCBQaHlzaWNzIGZyb20gXCIuL3BoeXNpY3MvUGh5c2ljcy5qc1wiO1xuaW1wb3J0IFBhdGggZnJvbSBcIi4vYXV0b25vbXkvUGF0aC5qc1wiO1xuaW1wb3J0IEN1YmljUGF0aCBmcm9tIFwiLi9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL0N1YmljUGF0aC5qc1wiO1xuaW1wb3J0IEF1dG9ub21vdXNDb250cm9sbGVyIGZyb20gXCIuL2F1dG9ub215L2NvbnRyb2wvQXV0b25vbW91c0NvbnRyb2xsZXIuanNcIjtcbmltcG9ydCBGb2xsb3dDb250cm9sbGVyIGZyb20gXCIuL2F1dG9ub215L2NvbnRyb2wvRm9sbG93Q29udHJvbGxlci5qc1wiO1xuaW1wb3J0IE1hbnVhbENvbnRyb2xsZXIgZnJvbSBcIi4vYXV0b25vbXkvY29udHJvbC9NYW51YWxDb250cm9sbGVyLmpzXCI7XG5pbXBvcnQgTWFwT2JqZWN0IGZyb20gXCIuL29iamVjdHMvTWFwT2JqZWN0LmpzXCI7XG5pbXBvcnQgQ2FyT2JqZWN0IGZyb20gXCIuL29iamVjdHMvQ2FyT2JqZWN0LmpzXCI7XG5pbXBvcnQgU3RhdGljT2JzdGFjbGVPYmplY3QgZnJvbSBcIi4vb2JqZWN0cy9TdGF0aWNPYnN0YWNsZU9iamVjdC5qc1wiO1xuaW1wb3J0IER5bmFtaWNPYnN0YWNsZU9iamVjdCBmcm9tIFwiLi9vYmplY3RzL0R5bmFtaWNPYnN0YWNsZU9iamVjdC5qc1wiO1xuaW1wb3J0IEVkaXRvciBmcm9tIFwiLi9zaW11bGF0b3IvRWRpdG9yLmpzXCI7XG5pbXBvcnQgT3JiaXRDb250cm9scyBmcm9tIFwiLi9zaW11bGF0b3IvT3JiaXRDb250cm9scy5qc1wiO1xuaW1wb3J0IFRvcERvd25DYW1lcmFDb250cm9scyBmcm9tIFwiLi9zaW11bGF0b3IvVG9wRG93bkNhbWVyYUNvbnRyb2xzLmpzXCI7XG5pbXBvcnQgRGFzaGJvYXJkIGZyb20gXCIuL3NpbXVsYXRvci9EYXNoYm9hcmQuanNcIjtcbmltcG9ydCBHUEdQVSBmcm9tIFwiLi9HUEdQVS5qc1wiO1xuaW1wb3J0IFJvYWRMYXR0aWNlIGZyb20gXCIuL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvUm9hZExhdHRpY2UuanNcIjtcbmltcG9ydCBQYXRoUGxhbm5lciBmcm9tIFwiLi9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1BhdGhQbGFubmVyLmpzXCI7XG5pbXBvcnQgU3RhdGljT2JzdGFjbGUgZnJvbSBcIi4vYXV0b25vbXkvU3RhdGljT2JzdGFjbGUuanNcIjtcbmltcG9ydCBEeW5hbWljT2JzdGFjbGUgZnJvbSBcIi4vYXV0b25vbXkvRHluYW1pY09ic3RhY2xlLmpzXCI7XG5pbXBvcnQgTW92aW5nQXZlcmFnZSBmcm9tIFwiLi9hdXRvbm9teS9Nb3ZpbmdBdmVyYWdlLmpzXCI7XG5pbXBvcnQgUGF0aFBsYW5uZXJDb25maWdFZGl0b3IgZnJvbSBcIi4vc2ltdWxhdG9yL1BhdGhQbGFubmVyQ29uZmlnRWRpdG9yLmpzXCI7XG5cbmNvbnN0IFdFTENPTUVfTU9EQUxfS0VZID0gJ2Rhc2hfV2VsY29tZU1vZGFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltdWxhdG9yIHtcbiAgY29uc3RydWN0b3IoZG9tRWxlbWVudCkge1xuICAgIHRoaXMucGF0aFBsYW5uZXJXb3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2AoJHtkYXNoX2luaXRQYXRoUGxhbm5lcldvcmtlci50b1N0cmluZygpfSkoKWBdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pKSk7XG4gICAgdGhpcy5wYXRoUGxhbm5lcldvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVQbGFubmVkUGF0aC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGF0aFBsYW5uZXJDb25maWdFZGl0b3IgPSBuZXcgUGF0aFBsYW5uZXJDb25maWdFZGl0b3IoKTtcblxuICAgIHRoaXMucGh5c2ljcyA9IG5ldyBQaHlzaWNzKCk7XG4gICAgdGhpcy5jYXIgPSB0aGlzLnBoeXNpY3MuY3JlYXRlQ2FyKCk7XG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IHRydWUgfSk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUoZG9tRWxlbWVudC5jbGllbnRXaWR0aCwgZG9tRWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlO1xuICAgIGRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcblxuICAgIHRoaXMubGFzdFBsYW5QYXJhbXMgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZXIuY29udGV4dC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGF0b3I6IHdlYmdsIGNvbnRleHQgbG9zdCcpO1xuICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5sYXN0UGxhblBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXRVcENhbWVyYXModGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcblxuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLnNjZW5lRm9nID0gbnVsbDsvL25ldyBUSFJFRS5Gb2dFeHAyKDB4MTExMTExLCAwLjAwMjUpO1xuICAgIHRoaXMuc2NlbmUuZm9nID0gdGhpcy5zY2VuZUZvZztcbiAgICB0aGlzLnNjZW5lLmJhY2tncm91bmQgPSBuZXcgVEhSRUUuQ29sb3IoMHgxMTExMTEpOyAvLzB4MTExMTExXG5cbiAgICB0aGlzLmVkaXRvciA9IG5ldyBFZGl0b3IodGhpcy5yZW5kZXJlci5kb21FbGVtZW50LCB0aGlzLmVkaXRvckNhbWVyYSwgdGhpcy5zY2VuZSk7XG5cbiAgICBjb25zdCBnZW9sb2NhdGlvbiA9IG51bGw7Ly9bMzMuNTIzOTAwLCAtMTExLjkwODc1Nl07XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcE9iamVjdChnZW9sb2NhdGlvbik7XG4gICAgdGhpcy5zY2VuZS5hZGQobWFwKTtcblxuICAgIHRoaXMuY2FyT2JqZWN0ID0gbmV3IENhck9iamVjdCh0aGlzLmNhcik7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5jYXJPYmplY3QpO1xuXG4gICAgdGhpcy5zY2VuZS5hZGQobmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDY2NjY2NikpO1xuICAgIGNvbnN0IGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuNzUpO1xuICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgxLCAxLCAxKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG5cbiAgICB0aGlzLm1hbnVhbENhckNvbnRyb2xsZXIgPSBuZXcgTWFudWFsQ29udHJvbGxlcigpO1xuICAgIHRoaXMuYXV0b25vbW91c0NhckNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgdGhpcy5kYXNoYm9hcmQgPSBuZXcgRGFzaGJvYXJkKHRoaXMuY2FyKTtcblxuICAgIHRoaXMucGxhbm5lclJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5wbGFubmVyUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMucGxhbm5lclJlc2V0ID0gZmFsc2U7XG4gICAgdGhpcy5jYXJTdGF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnBsYW5uZWRQYXRoR3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5uZWRQYXRoR3JvdXApO1xuXG4gICAgdGhpcy5zdGF0aWNPYnN0YWNsZXNHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuc3RhdGljT2JzdGFjbGVzR3JvdXApO1xuICAgIHRoaXMuZHluYW1pY09ic3RhY2xlc0dyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5keW5hbWljT2JzdGFjbGVzR3JvdXApO1xuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByZXZUaW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuZnJhbWVDb3VudGVyID0gMDtcbiAgICB0aGlzLmZwc1RpbWUgPSAwO1xuICAgIHRoaXMuZnBzID0gMDtcbiAgICB0aGlzLnNpbXVsYXRlZFRpbWUgPSAwO1xuICAgIHRoaXMubGFzdFBsYW5UaW1lID0gbnVsbDtcbiAgICB0aGlzLmF2ZXJhZ2VQbGFuVGltZSA9IG5ldyBNb3ZpbmdBdmVyYWdlKDIwKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBlID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZUNhbWVyYUFzcGVjdHMoZG9tRWxlbWVudC5jbGllbnRXaWR0aCAvIGRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZShkb21FbGVtZW50LmNsaWVudFdpZHRoLCBkb21FbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGUgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN0YXJ0c1dpdGgoJyMvcy8nKSlcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tYW51YWxNb2RlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGUtbWFudWFsJyk7XG4gICAgdGhpcy5tYW51YWxNb2RlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5lbmFibGVNYW51YWxNb2RlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYXV0b25vbW91c01vZGVCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZS1hdXRvbm9tb3VzJyk7XG4gICAgdGhpcy5hdXRvbm9tb3VzTW9kZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZW5hYmxlQXV0b25vbW91c01vZGUuYmluZCh0aGlzKSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdG9yLWVuYWJsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5lbmFibGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1maW5hbGl6ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5maW5hbGl6ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2ltdWxhdG9yLWxvYWQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMubG9hZFNjZW5hcmlvLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5zY2VuYXJpb1BsYXlCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NlbmFyaW8tcGxheScpO1xuICAgIHRoaXMuc2NlbmFyaW9QbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5wbGF5U2NlbmFyaW8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zY2VuYXJpb1BhdXNlQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvLXBhdXNlJyk7XG4gICAgdGhpcy5zY2VuYXJpb1BhdXNlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5wYXVzZVNjZW5hcmlvLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NlbmFyaW9SZXN0YXJ0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjZW5hcmlvLXJlc3RhcnQnKTtcbiAgICB0aGlzLnNjZW5hcmlvUmVzdGFydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVzdGFydFNjZW5hcmlvLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy53ZWxjb21lTW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2VsY29tZS1tb2RhbCcpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LXdlbGNvbWUtbW9kYWwnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy53ZWxjb21lTW9kYWwuY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJykpO1xuXG4gICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShXRUxDT01FX01PREFMX0tFWSkgIT09ICdoaWRlJykge1xuICAgICAgdGhpcy53ZWxjb21lTW9kYWwuY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dlbGNvbWUtbW9kYWwtYmFja2dyb3VuZCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlV2VsY29tZU1vZGFsLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWxjb21lLW1vZGFsLWNsb3NlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhpZGVXZWxjb21lTW9kYWwuYmluZCh0aGlzKSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2VsY29tZS1tb2RhbC1leGFtcGxlcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICB0aGlzLndlbGNvbWVNb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgICAgIHRoaXMubG9hZFNjZW5hcmlvKCk7XG4gICAgICB0aGlzLmVkaXRvci5zY2VuYXJpb01hbmFnZXIuc3dpdGNoVGFiKHRoaXMuZWRpdG9yLnNjZW5hcmlvTWFuYWdlci5leGFtcGxlc1RhYik7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2VsY29tZS1tb2RhbC1jcmVhdGUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgdGhpcy53ZWxjb21lTW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XG4gICAgICB0aGlzLmVuYWJsZUVkaXRvcigpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zaW1Nb2RlQm94ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzaW0tbW9kZS1ib3gnKSwgMCk7XG4gICAgdGhpcy5lZGl0TW9kZUJveGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZWRpdC1tb2RlLWJveCcpLCAwKTtcblxuICAgIHRoaXMuZnBzQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZwcycpO1xuXG4gICAgdGhpcy5lbmFibGVNYW51YWxNb2RlKCk7XG4gICAgdGhpcy5jaGFuZ2VDYW1lcmEoJ2NoYXNlJyk7XG5cbiAgICB0aGlzLmFyb3VuZEFuY2hvckluZGV4ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRpY09ic3RhY2xlcyA9IFtdO1xuICAgIHRoaXMuZHluYW1pY09ic3RhY2xlcyA9IFtdO1xuXG4gICAgdGhpcy5fY2hlY2tIYXNoU2NlbmFyaW8oKTtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnN0ZXAuYmluZCh0aGlzKSk7XG4gIH1cblxuICB0b3NzKCkge1xuICAgIGNvbnN0IHBvc2UgPSB0aGlzLmNhci5wb3NlO1xuICAgIGNvbnN0IHJvdFZlYyA9IFRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlKHBvc2Uucm90KTtcbiAgICBjb25zdCBwb3MgPSByb3RWZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhcig1MCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IyKHJvdFZlYy55LCByb3RWZWMueCkpLmFkZChwb3NlLnBvcyk7XG4gICAgY29uc3Qgb2JzdGFjbGUgPSBuZXcgU3RhdGljT2JzdGFjbGUocG9zLCAwLCAxLjAsIDEuMCk7XG5cbiAgICBjb25zdCBvYnNHZW9tID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkob2JzdGFjbGUud2lkdGgsIG9ic3RhY2xlLmhlaWdodCk7XG4gICAgY29uc3Qgb2JzTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4MDAwMGZmLCBkZXB0aFRlc3Q6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC41IH0pO1xuICAgIGNvbnN0IG9ic09iaiA9IG5ldyBUSFJFRS5NZXNoKG9ic0dlb20sIG9ic01hdCk7XG4gICAgb2JzT2JqLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gICAgb2JzT2JqLnJvdGF0aW9uLnogPSAtb2JzdGFjbGUucm90O1xuICAgIG9ic09iai5wb3NpdGlvbi5zZXQob2JzdGFjbGUucG9zLngsIDAsIG9ic3RhY2xlLnBvcy55KTtcbiAgICB0aGlzLnNjZW5lLmFkZChvYnNPYmopO1xuXG4gICAgdGhpcy5zdGF0aWNPYnN0YWNsZXMucHVzaChvYnN0YWNsZSk7XG4gIH1cblxuICBfY2hlY2tIYXNoU2NlbmFyaW8oKSB7XG4gICAgaWYgKCF3aW5kb3cubG9jYXRpb24uaGFzaC5zdGFydHNXaXRoKCcjL3MvJykpIHJldHVybjtcblxuICAgIGNvbnN0IFtfaGFzaCwgX3MsIGNvZGVdID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoJy8nKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShhdG9iKGRlY29kZVVSSUNvbXBvbmVudChjb2RlKSkpO1xuICAgICAgdGhpcy5lZGl0b3IubG9hZEpTT04oanNvbik7XG4gICAgICB0aGlzLmZpbmFsaXplRWRpdG9yKCk7XG4gICAgICB0aGlzLndlbGNvbWVNb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGltcG9ydGluZyBzY2VuYXJpbyBjb2RlOicpO1xuICAgICAgY29uc29sZS5sb2coY29kZSk7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG4gIH1cblxuICBfc2V0VXBDYW1lcmFzKGRvbUVsZW1lbnQpIHtcbiAgICB0aGlzLmNoYXNlQ2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDU1LCBkb21FbGVtZW50LmNsaWVudFdpZHRoIC8gZG9tRWxlbWVudC5jbGllbnRIZWlnaHQsIDEsIDEwMDAwKTtcbiAgICB0aGlzLmNoYXNlQ2FtZXJhQ29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyh0aGlzLmNoYXNlQ2FtZXJhLCBkb21FbGVtZW50KTtcbiAgICB0aGlzLmNoYXNlQ2FtZXJhQ29udHJvbHMubWluRGlzdGFuY2UgPSA0O1xuICAgIHRoaXMuY2hhc2VDYW1lcmFDb250cm9scy5tYXhEaXN0YW5jZSA9IDUwMDA7XG4gICAgdGhpcy5jaGFzZUNhbWVyYUNvbnRyb2xzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJIC8gMi4wMjtcbiAgICB0aGlzLmNoYXNlQ2FtZXJhQ29udHJvbHMuZW5hYmxlUGFuID0gZmFsc2U7XG4gICAgdGhpcy5jaGFzZUNhbWVyYUNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNldENoYXNlQ2FtZXJhKCk7XG5cbiAgICB0aGlzLmZyZWVDYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNTUsIGRvbUVsZW1lbnQuY2xpZW50V2lkdGggLyBkb21FbGVtZW50LmNsaWVudEhlaWdodCwgMSwgMTAwMDApO1xuICAgIHRoaXMuZnJlZUNhbWVyYUNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHModGhpcy5mcmVlQ2FtZXJhLCBkb21FbGVtZW50KTtcbiAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy5taW5EaXN0YW5jZSA9IDU7XG4gICAgdGhpcy5mcmVlQ2FtZXJhQ29udHJvbHMubWF4RGlzdGFuY2UgPSA1MDAwO1xuICAgIHRoaXMuZnJlZUNhbWVyYUNvbnRyb2xzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJIC8gMi4wMjtcbiAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXNldEZyZWVDYW1lcmEoKTtcblxuICAgIHRoaXMudG9wRG93bkNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg1NSwgZG9tRWxlbWVudC5jbGllbnRXaWR0aCAvIGRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0LCAxLCAxMDAwMCk7XG4gICAgdGhpcy50b3BEb3duQ2FtZXJhLnBvc2l0aW9uLnNldCgwLCA1MCwgMCk7XG4gICAgdGhpcy50b3BEb3duQ2FtZXJhLmxvb2tBdCgwLCAwLCAwKTtcbiAgICB0aGlzLnRvcERvd25Db250cm9scyA9IG5ldyBUb3BEb3duQ2FtZXJhQ29udHJvbHMoZG9tRWxlbWVudCwgdGhpcy50b3BEb3duQ2FtZXJhKTtcbiAgICB0aGlzLnRvcERvd25Db250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy50b3BEb3duQ29udHJvbHMubWluQWx0aXR1ZGUgPSA1O1xuICAgIHRoaXMudG9wRG93bkNvbnRyb2xzLm1heEFsdGl0dWRlID0gMTAwMDA7XG5cbiAgICB0aGlzLmVkaXRvckNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgZG9tRWxlbWVudC5jbGllbnRXaWR0aCAvIGRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0LCAxLCAxMDAwMCk7XG4gICAgdGhpcy5lZGl0b3JDYW1lcmEubGF5ZXJzLmVuYWJsZSgyKTtcbiAgICB0aGlzLmVkaXRvckNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMjAwLCAwKTtcbiAgICB0aGlzLmVkaXRvckNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgdGhpcy5lZGl0b3JDYW1lcmFDb250cm9scyA9IG5ldyBUb3BEb3duQ2FtZXJhQ29udHJvbHMoZG9tRWxlbWVudCwgdGhpcy5lZGl0b3JDYW1lcmEpO1xuICAgIHRoaXMuZWRpdG9yQ2FtZXJhQ29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZWRpdG9yQ2FtZXJhQ29udHJvbHMuZW5hYmxlUGFubmluZyA9IHRydWU7XG4gICAgdGhpcy5lZGl0b3JDYW1lcmFDb250cm9scy5taW5BbHRpdHVkZSA9IDEwO1xuICAgIHRoaXMuZWRpdG9yQ2FtZXJhQ29udHJvbHMubWF4QWx0aXR1ZGUgPSAxMDAwMDtcblxuICAgIHRoaXMuY2FtZXJhQnV0dG9ucyA9IHt9O1xuXG4gICAgWydmcmVlJywgJ2NoYXNlJywgJ3RvcERvd24nXS5mb3JFYWNoKGMgPT4ge1xuICAgICAgY29uc3QgY2FtZXJhQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGNhbWVyYS0ke2N9YCk7XG4gICAgICBjYW1lcmFCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmNoYW5nZUNhbWVyYShjKSk7XG4gICAgICB0aGlzLmNhbWVyYUJ1dHRvbnNbY10gPSBjYW1lcmFCdXR0b247XG4gICAgfSk7XG5cbiAgICB0aGlzLnN3aXRjaFRvMkRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FtZXJhLTJEJyk7XG4gICAgdGhpcy5zd2l0Y2hUbzJEQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zd2l0Y2hUbzJELmJpbmQodGhpcykpO1xuICAgIHRoaXMuc3dpdGNoVG8zREJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW1lcmEtM0QnKTtcbiAgICB0aGlzLnN3aXRjaFRvM0RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnN3aXRjaFRvM0QuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnN3aXRjaFRvM0QoKTtcbiAgfVxuXG4gIF9yZXNldEZyZWVDYW1lcmEoKSB7XG4gICAgdGhpcy5mcmVlQ2FtZXJhQ29udHJvbHMucG9zaXRpb24wLmNvcHkodGhpcy5jaGFzZUNhbWVyYS5wb3NpdGlvbik7XG4gICAgY29uc3QgY2FyUG9zaXRpb24gPSB0aGlzLmNhci5wb3NpdGlvbjtcbiAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy50YXJnZXQwLnNldChjYXJQb3NpdGlvbi54LCAwLCBjYXJQb3NpdGlvbi55KTtcbiAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy5yZXNldCgpO1xuICB9XG5cbiAgX3Jlc2V0Q2hhc2VDYW1lcmEoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5jYXIucG9zaXRpb247XG4gICAgY29uc3QgZGlyVmVjdG9yID0gVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUodGhpcy5jYXIucm90YXRpb24pLm11bHRpcGx5U2NhbGFyKC0yMCk7XG4gICAgdGhpcy5jaGFzZUNhbWVyYS5wb3NpdGlvbi5zZXQocG9zLnggKyBkaXJWZWN0b3IueCwgOCwgcG9zLnkgKyBkaXJWZWN0b3IueSk7XG4gICAgdGhpcy5jaGFzZUNhbWVyYS5sb29rQXQocG9zLngsIDAsIHBvcy55KTtcbiAgfVxuXG4gIF9yZXNldFRvcERvd25DYW1lcmEoKSB7XG4gICAgY29uc3QgY2FyUG9zaXRpb24gPSB0aGlzLmNhci5wb3NpdGlvbjtcbiAgICB0aGlzLnRvcERvd25DYW1lcmEucG9zaXRpb24uc2V0KGNhclBvc2l0aW9uLngsIDUwLCBjYXJQb3NpdGlvbi55KTtcbiAgICB0aGlzLnRvcERvd25DYW1lcmEucm90YXRpb24ueiA9IC10aGlzLmNhci5yb3RhdGlvbiAtIE1hdGguUEkgLyAyXG4gIH1cblxuICBfdXBkYXRlQ2FtZXJhQXNwZWN0cyhhc3BlY3QpIHtcbiAgICB0aGlzLmZyZWVDYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xuICAgIHRoaXMuZnJlZUNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5jaGFzZUNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgdGhpcy5jaGFzZUNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy50b3BEb3duQ2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcbiAgICB0aGlzLnRvcERvd25DYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMuZWRpdG9yQ2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcbiAgICB0aGlzLmVkaXRvckNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICBlbmFibGVFZGl0b3IoKSB7XG4gICAgdGhpcy5lZGl0b3IuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5wbGFubmVyUnVubmluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcmV2aW91c0NhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIHRoaXMuY2FtZXJhID0gdGhpcy5lZGl0b3JDYW1lcmE7XG4gICAgdGhpcy5lZGl0b3JDYW1lcmFDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNoYXNlQ2FtZXJhQ29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMudG9wRG93bkNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNjZW5lLmZvZyA9IG51bGw7XG4gICAgdGhpcy5jYXJPYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBsYW5uZWRQYXRoR3JvdXApIHRoaXMucGxhbm5lZFBhdGhHcm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0aWNPYnN0YWNsZXNHcm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5keW5hbWljT2JzdGFjbGVzR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5zaW1Nb2RlQm94ZXMuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKSk7XG4gICAgdGhpcy5lZGl0TW9kZUJveGVzLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgnaXMtaGlkZGVuJykpO1xuICB9XG5cbiAgZmluYWxpemVFZGl0b3IocmVwbGFjZUNhbWVyYSA9IHRydWUpIHtcbiAgICB0aGlzLmVkaXRvci5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5lZGl0b3JDYW1lcmFDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNjZW5lLmZvZyA9IHRoaXMuc2NlbmVGb2c7XG4gICAgdGhpcy5jYXJPYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnNpbU1vZGVCb3hlcy5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpKTtcbiAgICB0aGlzLmVkaXRNb2RlQm94ZXMuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKSk7XG5cbiAgICBpZiAodGhpcy5lZGl0b3IubGFuZVBhdGguYW5jaG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBjZW50ZXJsaW5lID0gdGhpcy5lZGl0b3IubGFuZVBhdGguY2VudGVybGluZTtcbiAgICAgIGNvbnN0IHBvcyA9IGNlbnRlcmxpbmVbMF0uY2xvbmUoKTtcbiAgICAgIGNvbnN0IGRpciA9IGNlbnRlcmxpbmVbMV0uY2xvbmUoKS5zdWIoY2VudGVybGluZVswXSk7XG4gICAgICBjb25zdCByb3QgPSBNYXRoLmF0YW4yKGRpci55LCBkaXIueCk7XG4gICAgICBjb25zdCBwZXJwaW5kaWN1bGFyID0gcm90ICsgTWF0aC5QSSAvIDIgKiAoTWF0aC5zaWduKHRoaXMuZWRpdG9yLmxhbmVQcmVmZXJlbmNlKSB8fCAwKTtcbiAgICAgIGNvbnN0IGxhdGl0dWRlID0gdGhpcy5wYXRoUGxhbm5lckNvbmZpZ0VkaXRvci5jb25maWcucm9hZFdpZHRoIC8gNDtcblxuICAgICAgdGhpcy5jYXIuc2V0UG9zZShwb3MueCArIE1hdGguY29zKHBlcnBpbmRpY3VsYXIpICogbGF0aXR1ZGUsIHBvcy55ICsgTWF0aC5zaW4ocGVycGluZGljdWxhcikgKiBsYXRpdHVkZSwgcm90KTtcbiAgICAgIHRoaXMuY2FyLnZlbG9jaXR5ID0gdGhpcy5lZGl0b3IuaW5pdGlhbFNwZWVkO1xuXG4gICAgICB0aGlzLmR5bmFtaWNPYnN0YWNsZXMgPSB0aGlzLmVkaXRvci5keW5hbWljT2JzdGFjbGVzO1xuXG4gICAgICAvLyBUaGUgYGZhbHNlYCB2YWx1ZSBtZWFucyB0aGUgY29udHJvbGxlciBpcyB3YWl0aW5nIHRvIGJlIGNyZWF0ZWQgYWZ0ZXIgdGhlIGZpcnN0IHBsYW5uaW5nIGN5Y2xlLlxuICAgICAgLy8gVGhpcyBzaWduYWxzIHRoZSBzaW11bGF0b3IgdG8gdXNlIG5ldXRyYWwgY29udHJvbHMgaW5zdGVhZCBvZiB0aGUgaGFyZCBicmFrZSB1c2VkIGZvciB0aGUgYG51bGxgIHZhbHVlLlxuICAgICAgdGhpcy5hdXRvbm9tb3VzQ2FyQ29udHJvbGxlciA9IGZhbHNlO1xuICAgICAgdGhpcy5lbmFibGVBdXRvbm9tb3VzTW9kZSgpO1xuXG4gICAgICBpZiAoIXRoaXMucGxhbm5lclJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5wbGFubmVyUmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsYW5uZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGxhbm5lclJlc2V0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2ltdWxhdGVkVGltZSA9IDA7XG4gICAgICB0aGlzLmNhclN0YXRpb24gPSAwO1xuICAgICAgdGhpcy5hcm91bmRBbmNob3JJbmRleCA9IG51bGw7XG5cbiAgICAgIHRoaXMucGF1c2VTY2VuYXJpbygpO1xuICAgICAgdGhpcy5hdXRvbm9tb3VzTW9kZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpcy1sb2FkaW5nJyk7XG4gICAgICB0aGlzLndhaXRpbmdGb3JGaXJzdFBsYW4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmR5bmFtaWNPYnN0YWNsZXMgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRpY09ic3RhY2xlcyA9IHRoaXMuZWRpdG9yLnN0YXRpY09ic3RhY2xlcztcbiAgICB0aGlzLnJlY3JlYXRlU3RhdGljT2JzdGFjbGVPYmplY3RzKCk7XG4gICAgdGhpcy5yZWNyZWF0ZUR5bmFtaWNPYnN0YWNsZU9iamVjdHMoKTtcblxuICAgIC8vdGhpcy5kYXNoYm9hcmQudXBkYXRlKHsgc3RlZXI6IDAsIGJyYWtlOiAwLCBnYXM6IDAgfSwgdGhpcy5jYXIudmVsb2NpdHksIG51bGwsIG51bGwsIDAsIHRoaXMuYXZlcmFnZVBsYW5UaW1lLmF2ZXJhZ2UpO1xuXG4gICAgaWYgKHJlcGxhY2VDYW1lcmEpIHtcbiAgICAgIHRoaXMuY2FtZXJhID0gdGhpcy5wcmV2aW91c0NhbWVyYTtcblxuICAgICAgaWYgKHRoaXMucHJldmlvdXNDYW1lcmEgPT0gdGhpcy5jaGFzZUNhbWVyYSlcbiAgICAgICAgdGhpcy5jaGFzZUNhbWVyYUNvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAodGhpcy5wcmV2aW91c0NhbWVyYSA9PSB0aGlzLnRvcERvd25DYW1lcmEpXG4gICAgICAgIHRoaXMudG9wRG93bkNvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAodGhpcy5wcmV2aW91c0NhbWVyYSA9PSB0aGlzLmZyZWVDYW1lcmEpXG4gICAgICAgIHRoaXMuZnJlZUNhbWVyYUNvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmNoYW5nZUNhbWVyYSgnY2hhc2UnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldEZyZWVDYW1lcmEoKTtcbiAgICB0aGlzLl9yZXNldENoYXNlQ2FtZXJhKCk7XG4gICAgdGhpcy5fcmVzZXRUb3BEb3duQ2FtZXJhKCk7XG4gIH1cblxuICByZWNyZWF0ZVN0YXRpY09ic3RhY2xlT2JqZWN0cygpIHtcbiAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnN0YXRpY09ic3RhY2xlc0dyb3VwKTtcbiAgICB0aGlzLnN0YXRpY09ic3RhY2xlc0dyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5zdGF0aWNPYnN0YWNsZXNHcm91cCk7XG5cbiAgICB0aGlzLnN0YXRpY09ic3RhY2xlcy5mb3JFYWNoKG8gPT4ge1xuICAgICAgY29uc3Qgb2JzdGFjbGVPYmplY3QgPSBuZXcgU3RhdGljT2JzdGFjbGVPYmplY3Qobyk7XG4gICAgICB0aGlzLnN0YXRpY09ic3RhY2xlc0dyb3VwLmFkZChvYnN0YWNsZU9iamVjdCk7XG4gICAgfSk7XG4gIH1cblxuICByZWNyZWF0ZUR5bmFtaWNPYnN0YWNsZU9iamVjdHMoKSB7XG4gICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5keW5hbWljT2JzdGFjbGVzR3JvdXApO1xuICAgIHRoaXMuZHluYW1pY09ic3RhY2xlc0dyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5keW5hbWljT2JzdGFjbGVzR3JvdXApO1xuXG4gICAgdGhpcy5keW5hbWljT2JzdGFjbGVzLmZvckVhY2gobyA9PiB7XG4gICAgICBjb25zdCBvYnN0YWNsZU9iamVjdCA9IG5ldyBEeW5hbWljT2JzdGFjbGVPYmplY3QobywgdGhpcy5lZGl0b3IubGFuZVBhdGgpO1xuICAgICAgdGhpcy5keW5hbWljT2JzdGFjbGVzR3JvdXAuYWRkKG9ic3RhY2xlT2JqZWN0KTtcbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlRHluYW1pY09iamVjdHModGhpcy5zaW11bGF0ZWRUaW1lKTtcbiAgfVxuXG4gIHVwZGF0ZUR5bmFtaWNPYmplY3RzKHRpbWUpIHtcbiAgICAvL3RoaXMuZHluYW1pY09ic3RhY2xlc0dyb3VwLmNoaWxkcmVuLmZvckVhY2gobyA9PiBvLnVwZGF0ZSh0aW1lKSk7XG4gIH1cblxuICBwbGF5U2NlbmFyaW8oKSB7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNjZW5hcmlvUGxheUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpcy1oaWRkZW4nKTtcbiAgICB0aGlzLnNjZW5hcmlvUGF1c2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtaGlkZGVuJyk7XG4gIH1cblxuICBwYXVzZVNjZW5hcmlvKCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLnNjZW5hcmlvUGxheUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgICB0aGlzLnNjZW5hcmlvUGF1c2VCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtaGlkZGVuJyk7XG4gIH1cblxuICByZXN0YXJ0U2NlbmFyaW8oKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yLmVuYWJsZWQpIHJldHVybjtcblxuICAgIGlmICh0aGlzLnBsYW5uZWRQYXRoR3JvdXApXG4gICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnBsYW5uZWRQYXRoR3JvdXApO1xuXG4gICAgdGhpcy5maW5hbGl6ZUVkaXRvcihmYWxzZSk7XG4gIH1cblxuICBsb2FkU2NlbmFyaW8oKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHRoaXMuZWRpdG9yLnNjZW5hcmlvTWFuYWdlci5zaG93TW9kYWwodGhpcy5maW5hbGl6ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGVuYWJsZU1hbnVhbE1vZGUoKSB7XG4gICAgdGhpcy5tYW51YWxNb2RlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLW91dGxpbmVkJyk7XG4gICAgdGhpcy5tYW51YWxNb2RlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2lzLXNlbGVjdGVkJyk7XG4gICAgdGhpcy5hdXRvbm9tb3VzTW9kZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpcy1vdXRsaW5lZCcsICdpcy1pbnZlcnRlZCcpO1xuICAgIHRoaXMuYXV0b25vbW91c01vZGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtc2VsZWN0ZWQnLCAnaXMtbGluaycpO1xuXG4gICAgdGhpcy5jYXJDb250cm9sbGVyTW9kZSA9ICdtYW51YWwnO1xuICB9XG5cbiAgZW5hYmxlQXV0b25vbW91c01vZGUoKSB7XG4gICAgdGhpcy5hdXRvbm9tb3VzTW9kZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1vdXRsaW5lZCcsICdpcy1pbnZlcnRlZCcpO1xuICAgIHRoaXMuYXV0b25vbW91c01vZGVCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtc2VsZWN0ZWQnLCAnaXMtbGluaycpO1xuICAgIHRoaXMubWFudWFsTW9kZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpcy1vdXRsaW5lZCcpO1xuICAgIHRoaXMubWFudWFsTW9kZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1zZWxlY3RlZCcpO1xuXG4gICAgdGhpcy5jYXJDb250cm9sbGVyTW9kZSA9ICdhdXRvbm9tb3VzJztcbiAgfVxuXG4gIGNoYW5nZUNhbWVyYShtb2RlKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBcImZyZWVcIjpcbiAgICAgICAgdGhpcy5jaGFzZUNhbWVyYUNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3BEb3duQ29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jYW1lcmEgPT0gdGhpcy5mcmVlQ2FtZXJhKVxuICAgICAgICAgIHRoaXMuX3Jlc2V0RnJlZUNhbWVyYSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5jYW1lcmEgPSB0aGlzLmZyZWVDYW1lcmE7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2hhc2VcIjpcbiAgICAgICAgdGhpcy5mcmVlQ2FtZXJhQ29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcERvd25Db250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhc2VDYW1lcmFDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jYW1lcmEgPT0gdGhpcy5jaGFzZUNhbWVyYSlcbiAgICAgICAgICB0aGlzLl9yZXNldENoYXNlQ2FtZXJhKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmNhbWVyYSA9IHRoaXMuY2hhc2VDYW1lcmE7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wRG93blwiOlxuICAgICAgICB0aGlzLmZyZWVDYW1lcmFDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhc2VDYW1lcmFDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG9wRG93bkNvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbWVyYSA9PSB0aGlzLnRvcERvd25DYW1lcmEpXG4gICAgICAgICAgdGhpcy5fcmVzZXRUb3BEb3duQ2FtZXJhKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmNhbWVyYSA9IHRoaXMudG9wRG93bkNhbWVyYTtcblxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKGBVbmtub3duIGNhbWVyYSBtb2RlOiAke21vZGV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgaW4gdGhpcy5jYW1lcmFCdXR0b25zKSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gdGhpcy5jYW1lcmFCdXR0b25zW2NdLmNsYXNzTGlzdDtcbiAgICAgIGlmIChjID09IG1vZGUpIHtcbiAgICAgICAgY2xhc3Nlcy5yZW1vdmUoJ2lzLW91dGxpbmVkJyk7XG4gICAgICAgIGNsYXNzZXMuYWRkKCdpcy1zZWxlY3RlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3Nlcy5hZGQoJ2lzLW91dGxpbmVkJyk7XG4gICAgICAgIGNsYXNzZXMucmVtb3ZlKCdpcy1zZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaFRvMkQoKSB7XG4gICAgdGhpcy5zd2l0Y2hUbzJEQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLW91dGxpbmVkJyk7XG4gICAgdGhpcy5zd2l0Y2hUbzJEQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2lzLXNlbGVjdGVkJyk7XG4gICAgdGhpcy5zd2l0Y2hUbzNEQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2lzLW91dGxpbmVkJyk7XG4gICAgdGhpcy5zd2l0Y2hUbzNEQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXNlbGVjdGVkJyk7XG5cbiAgICB0aGlzLmNoYXNlQ2FtZXJhLmxheWVycy5lbmFibGUoMik7XG4gICAgdGhpcy50b3BEb3duQ2FtZXJhLmxheWVycy5lbmFibGUoMik7XG4gICAgdGhpcy5mcmVlQ2FtZXJhLmxheWVycy5lbmFibGUoMik7XG4gICAgdGhpcy5jaGFzZUNhbWVyYS5sYXllcnMuZGlzYWJsZSgzKTtcbiAgICB0aGlzLnRvcERvd25DYW1lcmEubGF5ZXJzLmRpc2FibGUoMyk7XG4gICAgdGhpcy5mcmVlQ2FtZXJhLmxheWVycy5kaXNhYmxlKDMpO1xuICB9XG5cbiAgc3dpdGNoVG8zRCgpIHtcbiAgICB0aGlzLnN3aXRjaFRvM0RCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtb3V0bGluZWQnKTtcbiAgICB0aGlzLnN3aXRjaFRvM0RCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtc2VsZWN0ZWQnKTtcbiAgICB0aGlzLnN3aXRjaFRvMkRCdXR0b24uY2xhc3NMaXN0LmFkZCgnaXMtb3V0bGluZWQnKTtcbiAgICB0aGlzLnN3aXRjaFRvMkRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtc2VsZWN0ZWQnKTtcblxuICAgIHRoaXMuY2hhc2VDYW1lcmEubGF5ZXJzLmVuYWJsZSgzKTtcbiAgICB0aGlzLnRvcERvd25DYW1lcmEubGF5ZXJzLmVuYWJsZSgzKTtcbiAgICB0aGlzLmZyZWVDYW1lcmEubGF5ZXJzLmVuYWJsZSgzKTtcbiAgICB0aGlzLmNoYXNlQ2FtZXJhLmxheWVycy5kaXNhYmxlKDIpO1xuICAgIHRoaXMudG9wRG93bkNhbWVyYS5sYXllcnMuZGlzYWJsZSgyKTtcbiAgICB0aGlzLmZyZWVDYW1lcmEubGF5ZXJzLmRpc2FibGUoMik7XG4gIH1cblxuICBoaWRlV2VsY29tZU1vZGFsKCkge1xuICAgIHRoaXMud2VsY29tZU1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShXRUxDT01FX01PREFMX0tFWSwgJ2hpZGUnKTtcbiAgfVxuXG4gIHN0YXJ0UGxhbm5lcihwb3NlLCBzdGF0aW9uKSB7XG4gICAgdGhpcy5wbGFubmVyUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RQbGFuVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gY3JlYXRlIGEgc3RhYmxlIHRyYWplY3RvcnkgYmV0d2VlbiBzdWNjZXNzaXZlIHBsYW5uaW5nXG4gICAgLy8gY3ljbGVzLCB3ZSBtdXN0IGNvbXBlbnNhdGUgZm9yIHRoZSBsYXRlbmN5IGJldHdlZW4gd2hlbiBhIHBsYW5uaW5nIGN5Y2xlXG4gICAgLy8gc3RhcnRzIGFuZCB3aGVuIGl0IGVuZHMuIFRoZSBhdmVyYWdlIHBsYW5uaW5nIHRpbWUgaXMgdXNlZCB0byBmb3J3YXJkXG4gICAgLy8gc2ltdWxhdGUgdGhlIHZlaGljbGUgdG8gdGhlIHBvc2UgaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB3aGVuIHRoZVxuICAgIC8vIHBsYW5uaW5nIGFjdHVhbGx5IGZpbmlzaGVzLlxuXG4gICAgbGV0IHByZWRpY3RlZFBvc2UgPSBwb3NlO1xuICAgIGxldCBwcmVkaWN0ZWRTdGF0aW9uID0gc3RhdGlvbjtcbiAgICBsZXQgc3RhcnRUaW1lID0gdGhpcy5zaW11bGF0ZWRUaW1lO1xuXG4gICAgaWYgKCF0aGlzLnBsYW5uZXJSZXNldCAmJiAhdGhpcy5wYXVzZWQgJiYgdGhpcy5hdXRvbm9tb3VzQ2FyQ29udHJvbGxlciAmJiB0aGlzLmNhckNvbnRyb2xsZXJNb2RlID09ICdhdXRvbm9tb3VzJykge1xuICAgICAgY29uc3QgbGF0ZW5jeSA9IHRoaXMuYXZlcmFnZVBsYW5UaW1lLmF2ZXJhZ2U7XG4gICAgICBwcmVkaWN0ZWRQb3NlID0gdGhpcy5hdXRvbm9tb3VzQ2FyQ29udHJvbGxlci5wcmVkaWN0UG9zZUFmdGVyVGltZShwb3NlLCBsYXRlbmN5KTtcbiAgICAgIGxldCBbcHJlZGljdGVkU3RhdGlvbl0gPSB0aGlzLmVkaXRvci5sYW5lUGF0aC5zdGF0aW9uTGF0aXR1ZGVGcm9tUG9zaXRpb24ocHJlZGljdGVkUG9zZS5wb3MsIHRoaXMuYXJvdW5kQW5jaG9ySW5kZXgpO1xuICAgICAgc3RhcnRUaW1lICs9IGxhdGVuY3k7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXQgPSB0aGlzLnBsYW5uZXJSZXNldDtcbiAgICB0aGlzLnBsYW5uZXJSZXNldCA9IGZhbHNlO1xuXG4gICAgdGhpcy5sYXN0UGxhblBhcmFtcyA9ICB7XG4gICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGF0aFBsYW5uZXJDb25maWdFZGl0b3IuY29uZmlnLCB7IHNwZWVkTGltaXQ6IHRoaXMuZWRpdG9yLnNwZWVkTGltaXQsIGxhbmVQcmVmZXJlbmNlOiB0aGlzLmVkaXRvci5sYW5lUHJlZmVyZW5jZSB9KSxcbiAgICAgIHZlaGljbGVQb3NlOiBwcmVkaWN0ZWRQb3NlLFxuICAgICAgdmVoaWNsZVN0YXRpb246IHByZWRpY3RlZFN0YXRpb24sXG4gICAgICBsYW5lUGF0aDogdGhpcy5lZGl0b3IubGFuZVBhdGgsXG4gICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgIHN0YXRpY09ic3RhY2xlczogdGhpcy5zdGF0aWNPYnN0YWNsZXMsXG4gICAgICBkeW5hbWljT2JzdGFjbGVzOiB0aGlzLmR5bmFtaWNPYnN0YWNsZXMuZmlsdGVyKG8gPT4gby5wb3NpdGlvbkF0VGltZShzdGFydFRpbWUpLnggPj0gMCksXG4gICAgICByZXNldDogcmVzZXRcbiAgICB9O1xuXG4gICAgdGhpcy5wYXRoUGxhbm5lcldvcmtlci5wb3N0TWVzc2FnZSh0aGlzLmxhc3RQbGFuUGFyYW1zKTtcbiAgfVxuXG4gIHJlY2VpdmVQbGFubmVkUGF0aChldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxhbm5lci1lcnJvcicpLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndhaXRpbmdGb3JGaXJzdFBsYW4gJiYgIXRoaXMucGxhbm5lclJlc2V0KSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3JGaXJzdFBsYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuYXV0b25vbW91c01vZGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaXMtbG9hZGluZycpO1xuICAgICAgdGhpcy5wbGF5U2NlbmFyaW8oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lZGl0b3IuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgeyBmcm9tVmVoaWNsZVBhcmFtcywgdmVoaWNsZVBvc2UsIHZlaGljbGVTdGF0aW9uLCBsYXR0aWNlU3RhcnRTdGF0aW9uLCBjb25maWcsIGR5bmFtaWNPYnN0YWNsZUdyaWQgfSA9IGV2ZW50LmRhdGE7XG4gICAgbGV0IHsgcGF0aCwgZnJvbVZlaGljbGVTZWdtZW50IH0gPSBldmVudC5kYXRhO1xuXG4gICAgdGhpcy5hdmVyYWdlUGxhblRpbWUuYWRkU2FtcGxlKChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMubGFzdFBsYW5UaW1lKSAvIDEwMDApO1xuICAgIHRoaXMucGxhbm5lclJlYWR5ID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnBsYW5uZXJSZXNldCkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMucGxhbm5lZFBhdGhHcm91cClcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMucGxhbm5lZFBhdGhHcm91cCk7XG4gICAgdGhpcy5wbGFubmVkUGF0aEdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFubmVkUGF0aEdyb3VwKTtcblxuICAgIGNvbnN0IGNpcmNsZUdlb20gPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoMC4xLCAzMik7XG4gICAgY29uc3QgY2lyY2xlTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4MDBmZjgwLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC43IH0pO1xuXG4gICAgY29uc3QgbGF0dGljZSA9IG5ldyBSb2FkTGF0dGljZSh0aGlzLmVkaXRvci5sYW5lUGF0aCwgbGF0dGljZVN0YXJ0U3RhdGlvbiwgY29uZmlnKTtcbiAgICBsYXR0aWNlLmxhdHRpY2UuZm9yRWFjaChjZWxscyA9PiB7XG4gICAgICBjZWxscy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICBjb25zdCBjaXJjbGUgPSBuZXcgVEhSRUUuTWVzaChjaXJjbGVHZW9tLCBjaXJjbGVNYXQpO1xuICAgICAgICBjaXJjbGUucG9zaXRpb24uc2V0KGMucG9zLngsIDAsIGMucG9zLnkpO1xuICAgICAgICBjaXJjbGUucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgdGhpcy5wbGFubmVkUGF0aEdyb3VwLmFkZChjaXJjbGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBjbGVhciB0aGlzIHVwIG9yIGp1c3QgcmVtb3ZlIGl0XG4gICAgaWYgKGZhbHNlICYmIGR5bmFtaWNPYnN0YWNsZUdyaWQpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNHcmlkVGV4ID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKGR5bmFtaWNPYnN0YWNsZUdyaWQuZGF0YSwgZHluYW1pY09ic3RhY2xlR3JpZC53aWR0aCwgZHluYW1pY09ic3RhY2xlR3JpZC5oZWlnaHQsIFRIUkVFLlJHQkFGb3JtYXQsIFRIUkVFLkZsb2F0VHlwZSk7XG4gICAgICBkeW5hbWljR3JpZFRleC5mbGlwWSA9IHRydWU7XG4gICAgICBkeW5hbWljR3JpZFRleC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIGNvbnN0IFtncmlkU3RhcnRdID0gdGhpcy5lZGl0b3IubGFuZVBhdGguc2FtcGxlU3RhdGlvbnModmVoaWNsZVN0YXRpb24sIDEsIDApO1xuICAgICAgaWYgKGdyaWRTdGFydCkge1xuICAgICAgICBjb25zdCBkeW5hbWljR3JpZEdlb20gPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShkeW5hbWljT2JzdGFjbGVHcmlkLndpZHRoICogY29uZmlnLnNsR3JpZENlbGxTaXplLCBkeW5hbWljT2JzdGFjbGVHcmlkLmhlaWdodCAqIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSk7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNHcmlkTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiBkeW5hbWljR3JpZFRleCwgZGVwdGhUZXN0OiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNSB9KTtcbiAgICAgICAgY29uc3QgZHluYW1pY0dyaWRPYmogPSBuZXcgVEhSRUUuTWVzaChkeW5hbWljR3JpZEdlb20sIGR5bmFtaWNHcmlkTWF0KTtcbiAgICAgICAgZHluYW1pY0dyaWRPYmoucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgZHluYW1pY0dyaWRPYmoucm90YXRpb24ueiA9IC1ncmlkU3RhcnQucm90O1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShncmlkU3RhcnQucm90KS5tdWx0aXBseVNjYWxhcihkeW5hbWljT2JzdGFjbGVHcmlkLndpZHRoICogY29uZmlnLnNsR3JpZENlbGxTaXplIC8gMiAtIGNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIGNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zKTtcbiAgICAgICAgZHluYW1pY0dyaWRPYmoucG9zaXRpb24uc2V0KGdyaWRTdGFydC5wb3MueCArIG9mZnNldC54LCAwLCBncmlkU3RhcnQucG9zLnkgKyBvZmZzZXQueSk7XG5cbiAgICAgICAgdGhpcy5wbGFubmVkUGF0aEdyb3VwLmFkZChkeW5hbWljR3JpZE9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICAgIHRoaXMuYXV0b25vbW91c0NhckNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmcm9tVmVoaWNsZVBhcmFtcy50eXBlID09ICdjdWJpYycpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jYXIucG9zZTtcbiAgICAgIGNvbnN0IGVuZCA9IGZyb21WZWhpY2xlU2VnbWVudFtmcm9tVmVoaWNsZVNlZ21lbnQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGNvbnN0IHBhdGhCdWlsZGVyID0gbmV3IEN1YmljUGF0aChzdGFydCwgZW5kLCBmcm9tVmVoaWNsZVBhcmFtcy5wYXJhbXMpO1xuXG4gICAgICBpZiAocGF0aEJ1aWxkZXIub3B0aW1pemUoKSkge1xuICAgICAgICBmcm9tVmVoaWNsZVNlZ21lbnQgPSBwYXRoQnVpbGRlci5idWlsZFBhdGgoTWF0aC5jZWlsKHBhdGhCdWlsZGVyLnBhcmFtcy5zRyAvIDAuMjUpKTtcblxuICAgICAgICBjb25zdCBwcmV2VmVsb2NpdHlTcSA9IHRoaXMuY2FyLnZlbG9jaXR5ICogdGhpcy5jYXIudmVsb2NpdHk7XG4gICAgICAgIGNvbnN0IGFjY2VsID0gKGVuZC52ZWxvY2l0eSAqIGVuZC52ZWxvY2l0eSAtIHByZXZWZWxvY2l0eVNxKSAvIDIgLyBwYXRoQnVpbGRlci5wYXJhbXMuc0c7XG4gICAgICAgIGNvbnN0IGRzID0gcGF0aEJ1aWxkZXIucGFyYW1zLnNHIC8gKGZyb21WZWhpY2xlU2VnbWVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgbGV0IHMgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgZnJvbVZlaGljbGVTZWdtZW50Lmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgZnJvbVZlaGljbGVTZWdtZW50W3BdLnZlbG9jaXR5ID0gTWF0aC5zcXJ0KDIgKiBhY2NlbCAqIHMgKyBwcmV2VmVsb2NpdHlTcSk7XG4gICAgICAgICAgZnJvbVZlaGljbGVTZWdtZW50W3BdLmFjY2VsZXJhdGlvbiA9IGFjY2VsO1xuICAgICAgICAgIHMgKz0gZHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gZnJvbVZlaGljbGVTZWdtZW50LmNvbmNhdChwYXRoKTtcblxuICAgIHBhdGguZm9yRWFjaChwID0+IE9iamVjdC5zZXRQcm90b3R5cGVPZihwLnBvcywgVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUpKTtcbiAgICBjb25zdCBmb2xsb3dQYXRoID0gbmV3IFBhdGgocGF0aCk7XG5cbiAgICBpZiAodGhpcy5hdXRvbm9tb3VzQ2FyQ29udHJvbGxlcilcbiAgICAgIHRoaXMuYXV0b25vbW91c0NhckNvbnRyb2xsZXIucmVwbGFjZVBhdGgoZm9sbG93UGF0aCk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5hdXRvbm9tb3VzQ2FyQ29udHJvbGxlciA9IG5ldyBGb2xsb3dDb250cm9sbGVyKGZvbGxvd1BhdGgsIHRoaXMuY2FyKTtcblxuICAgIGNvbnN0IHBhdGhHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHBhdGhHZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHBhdGgubWFwKHAgPT4gbmV3IFRIUkVFLlZlY3RvcjMocC5wb3MueCwgMCwgcC5wb3MueSkpKTtcbiAgICBjb25zdCBwYXRoTGluZSA9IG5ldyBNZXNoTGluZSgpO1xuICAgIHBhdGhMaW5lLnNldEdlb21ldHJ5KHBhdGhHZW9tZXRyeSk7XG5cbiAgICBjb25zdCBjb2xvciA9IGZyb21WZWhpY2xlUGFyYW1zLnR5cGUgPT0gJ2N1YmljJyA/IG5ldyBUSFJFRS5Db2xvcigweGZmODgwMCkgOiBuZXcgVEhSRUUuQ29sb3IoMHhmZmZmNDApO1xuICAgIGNvbnN0IHBhdGhPYmplY3QgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgIHBhdGhMaW5lLmdlb21ldHJ5LFxuICAgICAgbmV3IE1lc2hMaW5lTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGxpbmVXaWR0aDogMC4xNSxcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5yZW5kZXJlci5kb21FbGVtZW50LmNsaWVudFdpZHRoLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0KVxuICAgICAgfSlcbiAgICApO1xuICAgIHBhdGhPYmplY3QucmVuZGVyT3JkZXIgPSAxO1xuICAgIHRoaXMucGxhbm5lZFBhdGhHcm91cC5hZGQocGF0aE9iamVjdCk7XG4gIH1cblxuICBzdGVwKHRpbWVzdGFtcCkge1xuICAgIGlmICh0aGlzLnByZXZUaW1lc3RhbXAgPT0gbnVsbCkge1xuICAgICAgdGhpcy5wcmV2VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RlcC5iaW5kKHRoaXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkdCA9ICh0aW1lc3RhbXAgLSB0aGlzLnByZXZUaW1lc3RhbXApIC8gMTAwMDtcblxuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgpO1xuXG4gICAgaWYgKCF0aGlzLmVkaXRvci5lbmFibGVkICYmICF0aGlzLnBhdXNlZCkge1xuICAgICAgdGhpcy5zaW11bGF0ZWRUaW1lICs9IGR0O1xuXG4gICAgICBjb25zdCBwcmV2Q2FyUG9zaXRpb24gPSB0aGlzLmNhci5wb3NpdGlvbjtcbiAgICAgIGNvbnN0IHByZXZDYXJSb3RhdGlvbiA9IHRoaXMuY2FyLnJvdGF0aW9uO1xuXG4gICAgICBjb25zdCBtYW51YWxDb250cm9scyA9IHRoaXMubWFudWFsQ2FyQ29udHJvbGxlci5jb250cm9sKHRoaXMuY2FyLnBvc2UsIHRoaXMuY2FyLndoZWVsQW5nbGUsIHRoaXMuY2FyLnZlbG9jaXR5LCBkdCk7XG4gICAgICBpZiAobWFudWFsQ29udHJvbHMuc3RlZXIgIT0gMCB8fCBtYW51YWxDb250cm9scy5icmFrZSAhPSAwIHx8IG1hbnVhbENvbnRyb2xzLmdhcyAhPSAwKVxuICAgICAgICB0aGlzLmVuYWJsZU1hbnVhbE1vZGUoKTtcblxuICAgICAgbGV0IGF1dG9ub21vdXNDb250cm9scyA9IHsgc3RlZXI6IDAsIGJyYWtlOiAwLCBnYXM6IDB9O1xuICAgICAgaWYgKHRoaXMuYXV0b25vbW91c0NhckNvbnRyb2xsZXIpXG4gICAgICAgIGF1dG9ub21vdXNDb250cm9scyA9IHRoaXMuYXV0b25vbW91c0NhckNvbnRyb2xsZXIuY29udHJvbCh0aGlzLmNhci5wb3NlLCB0aGlzLmNhci53aGVlbEFuZ2xlLCB0aGlzLmNhci52ZWxvY2l0eSwgZHQsIHRoaXMuY2FyQ29udHJvbGxlck1vZGUgPT0gJ2F1dG9ub21vdXMnKSA7XG4gICAgICBlbHNlIGlmICh0aGlzLmF1dG9ub21vdXNDYXJDb250cm9sbGVyID09PSBudWxsKVxuICAgICAgICBhdXRvbm9tb3VzQ29udHJvbHMgPSB7IHN0ZWVyOiAwLCBicmFrZTogMSwgZ2FzOiAwIH07XG5cbiAgICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5jYXJDb250cm9sbGVyTW9kZSA9PSAnYXV0b25vbW91cycgPyBhdXRvbm9tb3VzQ29udHJvbHMgOiBtYW51YWxDb250cm9scztcblxuICAgICAgdGhpcy5jYXIudXBkYXRlKGNvbnRyb2xzLCBkdCk7XG4gICAgICB0aGlzLnBoeXNpY3Muc3RlcChkdCk7XG5cbiAgICAgIHRoaXMudXBkYXRlRHluYW1pY09iamVjdHModGhpcy5zaW11bGF0ZWRUaW1lKTtcblxuICAgICAgY29uc3QgY2FyUG9zaXRpb24gPSB0aGlzLmNhci5wb3NpdGlvbjtcbiAgICAgIGNvbnN0IGNhclJvdGF0aW9uID0gdGhpcy5jYXIucm90YXRpb247XG4gICAgICBjb25zdCBjYXJSZWFyQXhsZSA9IHRoaXMuY2FyLnJlYXJBeGxlUG9zaXRpb247XG4gICAgICBjb25zdCBjYXJWZWxvY2l0eSA9IHRoaXMuY2FyLnZlbG9jaXR5O1xuXG4gICAgICBjb25zdCBwb3NpdGlvbk9mZnNldCA9IHsgeDogY2FyUG9zaXRpb24ueCAtIHByZXZDYXJQb3NpdGlvbi54LCB5OiAwLCB6OiBjYXJQb3NpdGlvbi55IC0gcHJldkNhclBvc2l0aW9uLnkgfTtcbiAgICAgIHRoaXMuY2hhc2VDYW1lcmEucG9zaXRpb24uYWRkKHBvc2l0aW9uT2Zmc2V0KTtcbiAgICAgIHRoaXMuY2hhc2VDYW1lcmFDb250cm9scy50YXJnZXQuc2V0KGNhclBvc2l0aW9uLngsIDAsIGNhclBvc2l0aW9uLnkpO1xuICAgICAgdGhpcy5jaGFzZUNhbWVyYUNvbnRyb2xzLnJvdGF0ZUxlZnQoY2FyUm90YXRpb24gLSBwcmV2Q2FyUm90YXRpb24pO1xuICAgICAgdGhpcy5jaGFzZUNhbWVyYUNvbnRyb2xzLnVwZGF0ZSgpO1xuXG4gICAgICB0aGlzLnRvcERvd25DYW1lcmEucG9zaXRpb24uc2V0WChjYXJQb3NpdGlvbi54KTtcbiAgICAgIHRoaXMudG9wRG93bkNhbWVyYS5wb3NpdGlvbi5zZXRaKGNhclBvc2l0aW9uLnkpO1xuICAgICAgdGhpcy50b3BEb3duQ2FtZXJhLnJvdGF0aW9uLnogPSAtY2FyUm90YXRpb24gLSBNYXRoLlBJIC8gMlxuXG4gICAgICBsZXQgbGF0aXR1ZGUgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5lZGl0b3IubGFuZVBhdGguYW5jaG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IFtzLCBsLCBhcm91bmRBbmNob3JJbmRleF0gPSB0aGlzLmVkaXRvci5sYW5lUGF0aC5zdGF0aW9uTGF0aXR1ZGVGcm9tUG9zaXRpb24oY2FyUmVhckF4bGUsIHRoaXMuYXJvdW5kQW5jaG9ySW5kZXgpO1xuICAgICAgICB0aGlzLmFyb3VuZEFuY2hvckluZGV4ID0gYXJvdW5kQW5jaG9ySW5kZXg7XG5cbiAgICAgICAgdGhpcy5jYXJTdGF0aW9uID0gcztcbiAgICAgICAgbGF0aXR1ZGUgPSBsO1xuICAgICAgfVxuICAgICAgLy90aGlzLmRhc2hib2FyZC51cGRhdGUoY29udHJvbHMsIGNhclZlbG9jaXR5LCB0aGlzLmNhclN0YXRpb24sIGxhdGl0dWRlLCB0aGlzLnNpbXVsYXRlZFRpbWUsIHRoaXMuYXZlcmFnZVBsYW5UaW1lLmF2ZXJhZ2UpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5lZGl0b3IuZW5hYmxlZCAmJiB0aGlzLnBsYW5uZXJSZWFkeSkge1xuICAgICAgdGhpcy5zdGFydFBsYW5uZXIodGhpcy5jYXIucG9zZSwgdGhpcy5jYXJTdGF0aW9uIHx8IDApO1xuICAgICAgdGhpcy5kYXNoYm9hcmQudXBkYXRlUGxhblRpbWUodGhpcy5hdmVyYWdlUGxhblRpbWUuYXZlcmFnZSk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZUNvdW50ZXIrKztcbiAgICB0aGlzLmZwc1RpbWUgKz0gZHQ7XG4gICAgaWYgKHRoaXMuZnBzVGltZSA+PSAxKSB7XG4gICAgICB0aGlzLmZwcyA9IHRoaXMuZnJhbWVDb3VudGVyIC8gdGhpcy5mcHNUaW1lO1xuICAgICAgdGhpcy5mcmFtZUNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5mcHNUaW1lID0gMDtcbiAgICAgIHRoaXMuZnBzQm94LnRleHRDb250ZW50ID0gdGhpcy5mcHMudG9GaXhlZCgxKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG5cbiAgICB0aGlzLnByZXZUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5zdGVwLmJpbmQodGhpcykpO1xuICB9XG59XG4iLCJpbXBvcnQgU2ltdWxhdG9yIGZyb20gXCIuL1NpbXVsYXRvci5qc1wiO1xuaW1wb3J0IFN0YXRpY09ic3RhY2xlIGZyb20gXCIuL2F1dG9ub215L1N0YXRpY09ic3RhY2xlLmpzXCI7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBlID0+IHtcbiAgd2luZG93LnNpbXVsYXRvciA9IG5ldyBTaW11bGF0b3IoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///14\\n')}]);","extractedComments":[]}